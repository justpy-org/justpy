{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JustPy \u00b6 Introduction \u00b6 JustPy is an object-oriented, component based, high-level Python Web Framework that requires no front-end programming. With a few lines of only Python code, you can create interactive websites without any JavaScript programming. JustPy can also be used to create graphic user interfaces for Python programs. Unlike other web frameworks, JustPy has no front-end/back-end distinction. All programming is done on the back-end allowing a simpler, more productive, and more Pythonic web development experience. JustPy removes the front-end/back-end distinction by intercepting the relevant events on the front-end and sending them to the back-end to be processed. Note The best way to understand JustPy is to follow the tutorial in which there are many examples. In JustPy, elements on the web page are instances of component classes. A component in JustPy is a Python class that allows you to instantiate reusable custom elements whose functionality and design is encapsulated away from the rest of your code. Custom components can be created using other components as building blocks. Out of the box, JustPy comes with support for HTML and SVG components as well as more complex components such as charts and grids . It also supports most of the components and the functionality of the Quasar library of Material Design 2.0 components. JustPy encourages creating your own components and reusing them in different projects (and, if applicable, sharing these components with others). JustPy supports visualization using matplotlib and Highcharts . JustPy integrates nicely with pandas and simplifies building web sites based on pandas analysis. JustPy comes with a pandas extension that makes it simple to create interactive charts and grids from pandas data structures. Hopefully, JustPy will enable teaching web development in introductory Python courses by reducing the complexity of web development. Hello World! \u00b6 import justpy as jp def hello_world (): wp = jp . WebPage () d = jp . Div ( text = 'Hello world!' ) wp . add ( d ) return wp jp . justpy ( hello_world ) The program above activates a web server that returns a web page with 'Hello world!' for any request. Locally, you would direct your browser to http://127.0.0.1:8000 or http://localhost:8000/ to see the result. Here is a slightly modified version in which 'Hello world!' changes to 'I was clicked!' when it is clicked. import justpy as jp def my_click ( self , msg ): self . text = 'I was clicked!' def hello_world (): wp = jp . WebPage () d = jp . Div ( text = 'Hello world!' ) d . on ( 'click' , my_click ) wp . add ( d ) return wp jp . justpy ( hello_world ) Under the Hood \u00b6 JustPy's backend is built using: starlette - \"a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services\". uvicorn - \"a lightning-fast ASGI server, built on uvloop and httptools \". JustPy's frontend (which is transparent to JustPy developers) is built using: Vue.js - \"The Progressive JavaScript Framework\" The way JustPy removes the frontend/backend distinction is by intercepting the relevant events on the frontend and sending them to the backend to be processed. News and Updates \u00b6 For news and updates please follow the JustPy Twitter account License \u00b6 Apache License, Version 2.0 Copyright (c) 2019, 2020, 2021 Eliezer Mintz","title":"What is JustPy"},{"location":"#justpy","text":"","title":"JustPy"},{"location":"#introduction","text":"JustPy is an object-oriented, component based, high-level Python Web Framework that requires no front-end programming. With a few lines of only Python code, you can create interactive websites without any JavaScript programming. JustPy can also be used to create graphic user interfaces for Python programs. Unlike other web frameworks, JustPy has no front-end/back-end distinction. All programming is done on the back-end allowing a simpler, more productive, and more Pythonic web development experience. JustPy removes the front-end/back-end distinction by intercepting the relevant events on the front-end and sending them to the back-end to be processed. Note The best way to understand JustPy is to follow the tutorial in which there are many examples. In JustPy, elements on the web page are instances of component classes. A component in JustPy is a Python class that allows you to instantiate reusable custom elements whose functionality and design is encapsulated away from the rest of your code. Custom components can be created using other components as building blocks. Out of the box, JustPy comes with support for HTML and SVG components as well as more complex components such as charts and grids . It also supports most of the components and the functionality of the Quasar library of Material Design 2.0 components. JustPy encourages creating your own components and reusing them in different projects (and, if applicable, sharing these components with others). JustPy supports visualization using matplotlib and Highcharts . JustPy integrates nicely with pandas and simplifies building web sites based on pandas analysis. JustPy comes with a pandas extension that makes it simple to create interactive charts and grids from pandas data structures. Hopefully, JustPy will enable teaching web development in introductory Python courses by reducing the complexity of web development.","title":"Introduction"},{"location":"#hello-world","text":"import justpy as jp def hello_world (): wp = jp . WebPage () d = jp . Div ( text = 'Hello world!' ) wp . add ( d ) return wp jp . justpy ( hello_world ) The program above activates a web server that returns a web page with 'Hello world!' for any request. Locally, you would direct your browser to http://127.0.0.1:8000 or http://localhost:8000/ to see the result. Here is a slightly modified version in which 'Hello world!' changes to 'I was clicked!' when it is clicked. import justpy as jp def my_click ( self , msg ): self . text = 'I was clicked!' def hello_world (): wp = jp . WebPage () d = jp . Div ( text = 'Hello world!' ) d . on ( 'click' , my_click ) wp . add ( d ) return wp jp . justpy ( hello_world )","title":"Hello World!"},{"location":"#under-the-hood","text":"JustPy's backend is built using: starlette - \"a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services\". uvicorn - \"a lightning-fast ASGI server, built on uvloop and httptools \". JustPy's frontend (which is transparent to JustPy developers) is built using: Vue.js - \"The Progressive JavaScript Framework\" The way JustPy removes the frontend/backend distinction is by intercepting the relevant events on the frontend and sending them to the backend to be processed.","title":"Under the Hood"},{"location":"#news-and-updates","text":"For news and updates please follow the JustPy Twitter account","title":"News and Updates"},{"location":"#license","text":"Apache License, Version 2.0 Copyright (c) 2019, 2020, 2021 Eliezer Mintz","title":"License"},{"location":"blog/ag-grid_to_web_page/","text":"From a Pandas DataFrame to a Web Site with an ag-Grid in 10 Lines of Python \u00b6 dev.to link Introduction \u00b6 Pandas is \"a fast, powerful, flexible and easy to use open source data analysis and manipulation tool, built on top of the Python programming language\". It is used by millions of programmer. ag-Grid bills itself as \"The Best JavaScript Grid in the World\" and its extensive list of features as well as its speed make arguing against this assertion difficult. JustPy is a Python package that allows you to build web applications without any JavaScript programming (I am the creator of JustPy). JustPy comes with a Pandas extension that makes it very easy to insert the data from a DataFrame into an ag-Grid and into a web application. Basic Example \u00b6 The following program reads a a CSV file into a DataFrame and creates a web application that serves a web page with the ag-Grid. The data describes the percentage of bachelor's degrees conferred to women by major in the years 1970-2012. import justpy as jp import pandas as pd # Load data showing percent of women in different majors per year wm = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def grid_test (): wp = jp . WebPage () wm . jp . ag_grid ( a = wp ) # a=wp adds the grid to WebPage wp return wp jp . justpy ( grid_test ) That is it. That is the whole program. To run this program you need to have Python version 3.6 or higher and you need to install the pandas and justpy packages. Then, you would create a file with your favorite text editor and copy and paste the program above. If you called the file grid.py you would type python3 grid.py in the command line or you could use an IDE. By default, you would access the web page by pointing your browser to http://127.0.0.1:8000 (it is easy to change the IP address and port that the application uses if you wish) For a more detailed explanation on how to get started using JustPy please see Getting Started from the tutorial. Once the page loads, move the mouse to any of the column headers to try the interactive features of the grid. Several Grids on a Page \u00b6 You can put as many ag-Grids on the page as you like. Below, we create another DataFrame only with the majors in which women started at less than 20% and put the original DataFrame and the new DataFrame on the page. Scroll down the browser tab to see the second grid. import justpy as jp import pandas as pd wm = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) wm_under_20 = wm [ wm . loc [ 0 , wm . loc [ 0 ] < 20 ] . index ] wm_under_20 . insert ( 0 , 'Year' , wm [ 'Year' ]) def grid_test (): wp = jp . WebPage () wm . jp . ag_grid ( a = wp ) wm_under_20 . jp . ag_grid ( a = wp ) return wp jp . justpy ( grid_test ) Customizing Grids \u00b6 You can also specify further options for the ag-Grid after its creation. The Python class of JustPy that models the ag-Grid has an options attribute that is identical in structure to the JavaScript one. When it is modified, the grid on the page will reflect these changes. In the program below we change the options so that: 1) The grid is paginated 2) The grid page size is automatically determined based on the browser tab size 3) The 'Year' column is formatted with CSS classes (JustPy comes with Tailwind CSS classes out of th box) 4) Each data cell is conditionally formatted based on its value import justpy as jp import pandas as pd wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def grid_test (): wp = jp . WebPage () grid = wm_df . jp . ag_grid ( a = wp ) grid . options . pagination = True grid . options . paginationAutoPageSize = True grid . options . columnDefs [ 0 ] . cellClass = [ 'text-white' , 'bg-blue-500' , 'hover:bg-blue-200' ] for col_def in grid . options . columnDefs [ 1 :]: col_def . cellClassRules = { 'font-bold' : 'x < 20' , 'bg-red-300' : 'x < 20' , 'bg-yellow-300' : 'x >= 20 && x < 50' , 'bg-green-300' : 'x >= 50' } return wp jp . justpy ( grid_test ) Routes and Multiple Pages \u00b6 With JustPy it is simple to serve girds with different data based on the URL. In the example below the URL http://127.0.0.1/wm will serve the full grid while the URL http://127.0.0.1/wm_20 will serve a grid only with the majors in which women started under 20%. import justpy as jp import pandas as pd wm = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) wm_under_20 = wm [ wm . loc [ 0 , wm . loc [ 0 ] < 20 ] . index ] wm_under_20 . insert ( 0 , 'Year' , wm [ 'Year' ]) # Tailwind classes to format header div title_classes = 'text-2xl text-white bg-blue-500 text-center mb-2 p-2' # Change grid default style to change height grid_style = 'height: 85vh; width: 99%; margin: 0.25rem; padding: 0.25rem;' @jp . SetRoute ( '/wm' ) def serve_wm (): wp = jp . WebPage () jp . Div ( text = 'All Majors' , classes = title_classes , a = wp ) wm . jp . ag_grid ( a = wp , style = grid_style ) return wp @jp . SetRoute ( '/wm_20' ) def serve_wm (): wp = jp . WebPage () jp . Div ( text = 'Only Majors with Women Starting Under 20%' , classes = title_classes , a = wp ) wm_under_20 . jp . ag_grid ( a = wp , style = grid_style ) return wp jp . justpy () ag-Grid Enterprise \u00b6 By default, JustPy uses the ag-Grid community version which is a free to use product distributed under the MIT License. If you would like to try the enterprise version, create a file called justpy.env in the directory where your program file and include in it the following: AGGRID = False AGGRID_ENTERPRISE = True Learn More \u00b6 In future articles, I will show how to interact with gird events as well as how to create interactive charts that are linked to the gird data. If you would like to learn more how you can move your pandas data quickly onto a web page without any JavaScript programming, please go to the JustPy Docs and Tutorials and feel free to ask me any questions either in the comments below or on GitHub .","title":"From a Pandas DataFrame to a Web Site with an ag-Grid in 10 Lines of Python"},{"location":"blog/ag-grid_to_web_page/#from-a-pandas-dataframe-to-a-web-site-with-an-ag-grid-in-10-lines-of-python","text":"dev.to link","title":"From a Pandas DataFrame to a Web Site with an ag-Grid in 10 Lines of Python"},{"location":"blog/ag-grid_to_web_page/#introduction","text":"Pandas is \"a fast, powerful, flexible and easy to use open source data analysis and manipulation tool, built on top of the Python programming language\". It is used by millions of programmer. ag-Grid bills itself as \"The Best JavaScript Grid in the World\" and its extensive list of features as well as its speed make arguing against this assertion difficult. JustPy is a Python package that allows you to build web applications without any JavaScript programming (I am the creator of JustPy). JustPy comes with a Pandas extension that makes it very easy to insert the data from a DataFrame into an ag-Grid and into a web application.","title":"Introduction"},{"location":"blog/ag-grid_to_web_page/#basic-example","text":"The following program reads a a CSV file into a DataFrame and creates a web application that serves a web page with the ag-Grid. The data describes the percentage of bachelor's degrees conferred to women by major in the years 1970-2012. import justpy as jp import pandas as pd # Load data showing percent of women in different majors per year wm = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def grid_test (): wp = jp . WebPage () wm . jp . ag_grid ( a = wp ) # a=wp adds the grid to WebPage wp return wp jp . justpy ( grid_test ) That is it. That is the whole program. To run this program you need to have Python version 3.6 or higher and you need to install the pandas and justpy packages. Then, you would create a file with your favorite text editor and copy and paste the program above. If you called the file grid.py you would type python3 grid.py in the command line or you could use an IDE. By default, you would access the web page by pointing your browser to http://127.0.0.1:8000 (it is easy to change the IP address and port that the application uses if you wish) For a more detailed explanation on how to get started using JustPy please see Getting Started from the tutorial. Once the page loads, move the mouse to any of the column headers to try the interactive features of the grid.","title":"Basic Example"},{"location":"blog/ag-grid_to_web_page/#several-grids-on-a-page","text":"You can put as many ag-Grids on the page as you like. Below, we create another DataFrame only with the majors in which women started at less than 20% and put the original DataFrame and the new DataFrame on the page. Scroll down the browser tab to see the second grid. import justpy as jp import pandas as pd wm = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) wm_under_20 = wm [ wm . loc [ 0 , wm . loc [ 0 ] < 20 ] . index ] wm_under_20 . insert ( 0 , 'Year' , wm [ 'Year' ]) def grid_test (): wp = jp . WebPage () wm . jp . ag_grid ( a = wp ) wm_under_20 . jp . ag_grid ( a = wp ) return wp jp . justpy ( grid_test )","title":"Several Grids on a Page"},{"location":"blog/ag-grid_to_web_page/#customizing-grids","text":"You can also specify further options for the ag-Grid after its creation. The Python class of JustPy that models the ag-Grid has an options attribute that is identical in structure to the JavaScript one. When it is modified, the grid on the page will reflect these changes. In the program below we change the options so that: 1) The grid is paginated 2) The grid page size is automatically determined based on the browser tab size 3) The 'Year' column is formatted with CSS classes (JustPy comes with Tailwind CSS classes out of th box) 4) Each data cell is conditionally formatted based on its value import justpy as jp import pandas as pd wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def grid_test (): wp = jp . WebPage () grid = wm_df . jp . ag_grid ( a = wp ) grid . options . pagination = True grid . options . paginationAutoPageSize = True grid . options . columnDefs [ 0 ] . cellClass = [ 'text-white' , 'bg-blue-500' , 'hover:bg-blue-200' ] for col_def in grid . options . columnDefs [ 1 :]: col_def . cellClassRules = { 'font-bold' : 'x < 20' , 'bg-red-300' : 'x < 20' , 'bg-yellow-300' : 'x >= 20 && x < 50' , 'bg-green-300' : 'x >= 50' } return wp jp . justpy ( grid_test )","title":"Customizing Grids"},{"location":"blog/ag-grid_to_web_page/#routes-and-multiple-pages","text":"With JustPy it is simple to serve girds with different data based on the URL. In the example below the URL http://127.0.0.1/wm will serve the full grid while the URL http://127.0.0.1/wm_20 will serve a grid only with the majors in which women started under 20%. import justpy as jp import pandas as pd wm = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) wm_under_20 = wm [ wm . loc [ 0 , wm . loc [ 0 ] < 20 ] . index ] wm_under_20 . insert ( 0 , 'Year' , wm [ 'Year' ]) # Tailwind classes to format header div title_classes = 'text-2xl text-white bg-blue-500 text-center mb-2 p-2' # Change grid default style to change height grid_style = 'height: 85vh; width: 99%; margin: 0.25rem; padding: 0.25rem;' @jp . SetRoute ( '/wm' ) def serve_wm (): wp = jp . WebPage () jp . Div ( text = 'All Majors' , classes = title_classes , a = wp ) wm . jp . ag_grid ( a = wp , style = grid_style ) return wp @jp . SetRoute ( '/wm_20' ) def serve_wm (): wp = jp . WebPage () jp . Div ( text = 'Only Majors with Women Starting Under 20%' , classes = title_classes , a = wp ) wm_under_20 . jp . ag_grid ( a = wp , style = grid_style ) return wp jp . justpy ()","title":"Routes and Multiple Pages"},{"location":"blog/ag-grid_to_web_page/#ag-grid-enterprise","text":"By default, JustPy uses the ag-Grid community version which is a free to use product distributed under the MIT License. If you would like to try the enterprise version, create a file called justpy.env in the directory where your program file and include in it the following: AGGRID = False AGGRID_ENTERPRISE = True","title":"ag-Grid Enterprise"},{"location":"blog/ag-grid_to_web_page/#learn-more","text":"In future articles, I will show how to interact with gird events as well as how to create interactive charts that are linked to the gird data. If you would like to learn more how you can move your pandas data quickly onto a web page without any JavaScript programming, please go to the JustPy Docs and Tutorials and feel free to ask me any questions either in the comments below or on GitHub .","title":"Learn More"},{"location":"blog/reactivity/","text":"Reactivity in JustPy \u00b6 Introduction \u00b6 A web framework is reactive if it updates the view whenever the some underlying data in the application changes. In practice, what this means for developers is that they do not need to manipulate the DOM when the state of the application changes. The framework takes care of that. Is JustPy reactive? The answer is yes and this article explains how to use JustPY in a reactive way. Static HTML \u00b6 Before delving into reactive examples, let's see how JustPy can also be used to generate static html that is not reactive. The following program takes a Python list and generates HTML from it: import justpy as jp todos = [ 'Go shopping' , 'Learn JustPy' , 'Do errands' ] def todo_app (): wp = jp . WebPage ( tailwind = False ) ol = jp . Ol ( a = wp ) for todo in todos : jp . Li ( text = todo , a = ol ) return wp jp . justpy ( todo_app ) If you change the todos list in your code, nothing will change in your open browser page. To see change, you need to re-run the program and reload the page. First Step to Reactivity \u00b6 When we use a reactive frontend framework like Vue or React, we can go to the browser console, change a variable, and see the view change in reaction to the variable changing. We cannot do that in JustPy because JustPy programs are Python programs and run on the server, not in the browser. We can only demonstrate reactivity from within the program. In the example below we let the user add an item to todos and change the view. import justpy as jp def todo_app (): todos = [ 'Buy groceries' , 'Learn JustPy' , 'Do errands' ] wp = jp . WebPage ( tailwind = False ) ol = jp . Ol ( a = wp ) for todo in todos : jp . Li ( text = todo , a = ol ) task = jp . Input ( placeholder = 'Enter task' , a = wp ) def add_task ( self , msg ): todos . append ( task . value ) task . value = '' ol . delete_components () for todo in todos : jp . Li ( text = todo , a = ol ) jp . Button ( text = 'Add Task' , a = wp , click = add_task , style = 'margin-left: 10px' ) return wp jp . justpy ( todo_app ) When the Add Task button is clicked, the add_task event handler deletes the children of ol and recreates them based on the new value of todos . On the front end, Vue will update the view based on the new values (the WebPage is converted into a Python dictionary which is fed into Vue). This is still not the full reactivity we are looking for. Yes, the view changes and we are not manipulating the DOM on the frontend, but we are changing instances of objects that represent the DOM on the server side. To get to full reactivity we need to create our own components. Full Reactivity \u00b6 In the example below we define a component called TodoList . JustPy components are Python classes that inherit from more basic components. TodoList inherits from Ol which is the JustPy class that represents the HTML ol tag. import justpy as jp class TodoList ( jp . Ol ): def __init__ ( self , ** kwargs ): self . todos = [] super () . __init__ ( ** kwargs ) def react ( self , data ): self . delete_components () for todo in self . todos : jp . Li ( text = todo , a = self ) def todo_app (): wp = jp . WebPage ( tailwind = False ) todo_list = TodoList ( a = wp , todos = [ 'Buy groceries' , 'Learn JustPy' , 'Do errands' ]) task = jp . Input ( placeholder = 'Enter task' , a = wp ) def add_task ( self , msg ): todo_list . todos . append ( task . value ) task . value = '' jp . Button ( text = 'Add Task' , a = wp , click = add_task , style = 'margin-left: 10px' ) return wp jp . justpy ( todo_app ) In the component we only modify two methods and inherit all other methods. The __init__ method is modified to give a default value to the todos attribute of the component in case it is not specified as a keyword argument when an instance is created. The second method we modify is the react method. This method is run automatically by the framework just before the component is rendered on the server side. Rendering on the server side means converting the object into a Python dictionary that is sent to the frontend in JSON format. Any changes the event handlers or background task have made to attributes of the object, will be reflected on the page. Therefore, all the add_task event handler has to do is modify the todos attribute of todo_list for the result to be reflected on the page. This is full reactivity. You can argue that we are sort of manipulating the DOM inside the react method. However, that is equivalent to saying that we are manipulating the DOM inside the template section of a Vue component. We need to define the HTML of the component at least once somewhere and that is done in the react method. Extending TodoList \u00b6 In the example below the TodoList component is extended to include the input field and the button. They are added to the component in __init__ and not react as they do not need to change when todos change. import justpy as jp class TodoList ( jp . Div ): def __init__ ( self , ** kwargs ): self . todos = [] super () . __init__ ( ** kwargs ) self . ol = jp . Ol ( a = self ) self . task = jp . Input ( placeholder = 'Enter task' , a = self ) jp . Button ( text = 'Add Task' , a = self , click = self . add_task , style = 'margin-left: 10px' ) def add_task ( self , msg ): self . todos . append ( self . task . value ) self . task . value = '' def react ( self , data ): self . ol . delete_components () for todo in self . todos : jp . Li ( text = todo , a = self . ol ) def todo_app (): wp = jp . WebPage ( tailwind = False ) TodoList ( a = wp , todos = [ 'Buy groceries' , 'Learn JustPy' , 'Do errands' ]) return wp jp . justpy ( todo_app )","title":"Reactivity in JustPy"},{"location":"blog/reactivity/#reactivity-in-justpy","text":"","title":"Reactivity in JustPy"},{"location":"blog/reactivity/#introduction","text":"A web framework is reactive if it updates the view whenever the some underlying data in the application changes. In practice, what this means for developers is that they do not need to manipulate the DOM when the state of the application changes. The framework takes care of that. Is JustPy reactive? The answer is yes and this article explains how to use JustPY in a reactive way.","title":"Introduction"},{"location":"blog/reactivity/#static-html","text":"Before delving into reactive examples, let's see how JustPy can also be used to generate static html that is not reactive. The following program takes a Python list and generates HTML from it: import justpy as jp todos = [ 'Go shopping' , 'Learn JustPy' , 'Do errands' ] def todo_app (): wp = jp . WebPage ( tailwind = False ) ol = jp . Ol ( a = wp ) for todo in todos : jp . Li ( text = todo , a = ol ) return wp jp . justpy ( todo_app ) If you change the todos list in your code, nothing will change in your open browser page. To see change, you need to re-run the program and reload the page.","title":"Static HTML"},{"location":"blog/reactivity/#first-step-to-reactivity","text":"When we use a reactive frontend framework like Vue or React, we can go to the browser console, change a variable, and see the view change in reaction to the variable changing. We cannot do that in JustPy because JustPy programs are Python programs and run on the server, not in the browser. We can only demonstrate reactivity from within the program. In the example below we let the user add an item to todos and change the view. import justpy as jp def todo_app (): todos = [ 'Buy groceries' , 'Learn JustPy' , 'Do errands' ] wp = jp . WebPage ( tailwind = False ) ol = jp . Ol ( a = wp ) for todo in todos : jp . Li ( text = todo , a = ol ) task = jp . Input ( placeholder = 'Enter task' , a = wp ) def add_task ( self , msg ): todos . append ( task . value ) task . value = '' ol . delete_components () for todo in todos : jp . Li ( text = todo , a = ol ) jp . Button ( text = 'Add Task' , a = wp , click = add_task , style = 'margin-left: 10px' ) return wp jp . justpy ( todo_app ) When the Add Task button is clicked, the add_task event handler deletes the children of ol and recreates them based on the new value of todos . On the front end, Vue will update the view based on the new values (the WebPage is converted into a Python dictionary which is fed into Vue). This is still not the full reactivity we are looking for. Yes, the view changes and we are not manipulating the DOM on the frontend, but we are changing instances of objects that represent the DOM on the server side. To get to full reactivity we need to create our own components.","title":"First Step to Reactivity"},{"location":"blog/reactivity/#full-reactivity","text":"In the example below we define a component called TodoList . JustPy components are Python classes that inherit from more basic components. TodoList inherits from Ol which is the JustPy class that represents the HTML ol tag. import justpy as jp class TodoList ( jp . Ol ): def __init__ ( self , ** kwargs ): self . todos = [] super () . __init__ ( ** kwargs ) def react ( self , data ): self . delete_components () for todo in self . todos : jp . Li ( text = todo , a = self ) def todo_app (): wp = jp . WebPage ( tailwind = False ) todo_list = TodoList ( a = wp , todos = [ 'Buy groceries' , 'Learn JustPy' , 'Do errands' ]) task = jp . Input ( placeholder = 'Enter task' , a = wp ) def add_task ( self , msg ): todo_list . todos . append ( task . value ) task . value = '' jp . Button ( text = 'Add Task' , a = wp , click = add_task , style = 'margin-left: 10px' ) return wp jp . justpy ( todo_app ) In the component we only modify two methods and inherit all other methods. The __init__ method is modified to give a default value to the todos attribute of the component in case it is not specified as a keyword argument when an instance is created. The second method we modify is the react method. This method is run automatically by the framework just before the component is rendered on the server side. Rendering on the server side means converting the object into a Python dictionary that is sent to the frontend in JSON format. Any changes the event handlers or background task have made to attributes of the object, will be reflected on the page. Therefore, all the add_task event handler has to do is modify the todos attribute of todo_list for the result to be reflected on the page. This is full reactivity. You can argue that we are sort of manipulating the DOM inside the react method. However, that is equivalent to saying that we are manipulating the DOM inside the template section of a Vue component. We need to define the HTML of the component at least once somewhere and that is done in the react method.","title":"Full Reactivity"},{"location":"blog/reactivity/#extending-todolist","text":"In the example below the TodoList component is extended to include the input field and the button. They are added to the component in __init__ and not react as they do not need to change when todos change. import justpy as jp class TodoList ( jp . Div ): def __init__ ( self , ** kwargs ): self . todos = [] super () . __init__ ( ** kwargs ) self . ol = jp . Ol ( a = self ) self . task = jp . Input ( placeholder = 'Enter task' , a = self ) jp . Button ( text = 'Add Task' , a = self , click = self . add_task , style = 'margin-left: 10px' ) def add_task ( self , msg ): self . todos . append ( self . task . value ) self . task . value = '' def react ( self , data ): self . ol . delete_components () for todo in self . todos : jp . Li ( text = todo , a = self . ol ) def todo_app (): wp = jp . WebPage ( tailwind = False ) TodoList ( a = wp , todos = [ 'Buy groceries' , 'Learn JustPy' , 'Do errands' ]) return wp jp . justpy ( todo_app )","title":"Extending TodoList"},{"location":"blog/vue_comparison/","text":"Comparing Vue.js to JustPy \u00b6 Example from Vue Guide \u00b6 https://vuejs.org/v2/guide/components.html#Base-Example import justpy as jp class ButtonCounter ( jp . Button ): def __init__ ( self , ** kwargs ): self . count = 0 super () . __init__ ( ** kwargs ) self . on ( 'click' , self . button_clicked ) def button_clicked ( self , msg ): self . count += 1 def react ( self , data ): self . text = f 'You clicked me {self.count} times.' async def button_counter_demo (): wp = jp . WebPage ( tailwind = False ) for i in range ( 5 ): ButtonCounter ( a = wp , count = i , style = 'margin: 10px' ) return wp jp . justpy ( button_counter_demo ) Vue video example \u00b6 import justpy as jp products = [ { 'id' : 1 , 'quantity' : 1 , 'name' : 'Compass' }, { 'id' : 2 , 'quantity' : 0 , 'name' : 'Jacket' }, { 'id' : 3 , 'quantity' : 5 , 'name' : 'Hiking Socks' }, { 'id' : 4 , 'quantity' : 2 , 'name' : 'Suntan Lotion' }, ] class Products ( jp . Div ): def __init__ ( self , ** kwargs ): self . products = products super () . __init__ ( ** kwargs ) self . ul = jp . Ul ( a = self ) self . total_inventory = jp . H2 ( text = 'Totals' , a = self ) def total_products ( self ): total = 0 for product in self . products : total += product [ \"quantity\" ] return total def react ( self , data ): self . ul . delete_components () for product in self . products : item = jp . Li ( a = self . ul ) jp . Input ( type = 'number' , product = product , a = item , value = product [ \"quantity\" ], input = 'self.product[\"quantity\"] = self.value' ) jp . Span ( text = f ' {product[\"quantity\"]} {product[\"name\"]} ' , a = item , style = 'margin-left: 10px' ) if product [ \"quantity\" ] == 0 : jp . Span ( text = ' - OUT OF STOCK' , a = item ) jp . Button ( text = 'Add' , a = item , product = product , click = 'self.product[\"quantity\"] += 1' , style = 'margin-left: 10px' ) self . total_inventory . text = f 'Total Inventory: {self.total_products()}' def product_app (): wp = jp . WebPage ( tailwind = False ) Products ( a = wp ) return wp jp . justpy ( product_app ) Todo list example \u00b6 import justpy as jp class TodoList ( jp . Div ): def __init__ ( self , ** kwargs ): self . todos = [] super () . __init__ ( ** kwargs ) self . ol = jp . Ol ( a = self ) self . task = jp . Input ( placeholder = 'Enter task' , a = self ) jp . Button ( text = 'Add Task' , a = self , click = self . add_task , style = 'margin-left: 10px' ) def add_task ( self , msg ): self . todos . append ( self . task . value ) self . task . value = '' def react ( self , data ): self . ol . delete_components () for todo in self . todos : jp . Li ( text = todo , a = self . ol ) def todo_app (): wp = jp . WebPage ( tailwind = False ) TodoList ( a = wp , todos = [ 'Buy groceries' , 'Learn JustPy' , 'Do errands' ]) return wp jp . justpy ( todo_app ) First things first: JustPY uses Vue on the front end. Without Vue there is no JustPy. It is important to understand how JustPy uses Vue to understand the differences between the two. In JustPy, web pages as well as HTML components are represented as instances of classes. The HTML div element is represented by the JustPy class Div. You add a div to web page in JustPY by adding a Div instance to a WebPage instance like so: import justpy as jp wp = jp . WebPage () my_div = jp . Div ( text = 'hello' ) wp . add ( my_div ) All JustPy elements have a method called convert_object_to_dict that do just that. import justpy as jp my_div = jp . Div ( text = 'hello' ) my_div . add ( jp . Span ( text = 'span text' , style = 'margin: 5px' )) print ( my_div . convert_object_to_dict ()) would give the following result: { 'attrs' : {}, 'id' : None , 'vue_type' : 'html_component' , 'show' : True , 'events' : [], 'event_modifiers' : {}, 'classes' : '' , 'style' : '' , 'set_focus' : False , 'html_tag' : 'div' , 'class_name' : 'Div' , 'event_propagation' : True , 'inner_html' : '' , 'animation' : False , 'debug' : False , 'directives' : {}, 'scoped_slots' : {}, 'object_props' : [{ 'attrs' : {}, 'id' : None , 'vue_type' : 'html_component' , 'show' : True , 'events' : [], 'event_modifiers' : {}, 'classes' : '' , 'style' : 'margin: 5px' , 'set_focus' : False , 'html_tag' : 'span' , 'class_name' : 'Span' , 'event_propagation' : True , 'inner_html' : '' , 'animation' : False , 'debug' : False , 'directives' : {}, 'scoped_slots' : {}, 'object_props' : [], 'text' : 'span text' }], 'text' : 'hello' } This dictionary is converted to JSON and sent to the browser. It is then used as the props for the Vue component that renders the element on the page. To recap, JustPy creates a JSON object representing the page, and that object is fed into the Vue app which renders the page. Creating the dictionary on the server side is very cheap computationally. All the rendering heavy lifting is done by Vue. If as a consequence of an event handler a page changes, a new dictionary is sent to the page and again fed to the Vue app which re-renders the required elements. When JustPy renders a page in a browser tab using the following steps: 1) For all instances on the page, a Python dictionary that describes their attributes is generated. T explain how vue is used This comparison is meant to help people familiar with Vue understand JustPy better. JustPy is not a backend or frontend framework. When working with JustPy there is no distinction between the backend and the frontend. The reason you would use JustPy instead of Vue is if you are interested working predominantly in Python This comparison is not meant to convince you to use one or the other In vue there is distinction between html and javascript (render function means you don't need html). In JustPY it is all python (but you can use html if you like parse_html). Main difference is reactivity. How to solve this? Example with react function. But how to automate. Show how to make reactive list based on object. You need to do this with components. A component that is a list. You can make it reactive. Show example of for without component and then with component. List Rendering (v-for) \u00b6 The Vue.js examples are here . Example of rendering a simple list: ```python import justpy as jp def for_example(): wp = jp.WebPage(tailwind=False) items = [{'message': 'Foo'}, {'message': 'Bar'}] ul = jp.Ul(a=wp) for item in items: jp.Li(text=f'{item[\"message\"]}', a=ul) return wp jp.justpy(for_example) Second example with index : `` ` python import justpy as jp def for_example (): wp = jp . WebPage ( tailwind = False ) ul = jp . Ul ( a = wp ) ul . items = [{ 'message' : 'Foo' }, { 'message' : 'Bar' }] ul . parent_message = 'Parent' for index , item in enumerate ( ul . items ): jp . Li ( text = f '{ul.parent_message}-{index}-{item[\"message\"]}' , a = ul ) return wp jp . justpy ( for_example ) Note that the HTML elements are Python class instances and therefore we can assign values to their attributes. Rendering an object \u00b6 https://vuejs.org/v2/guide/list.html#v-for-with-an-Object Rendering keys and values of an object: import justpy as jp def for_example (): wp = jp . WebPage ( tailwind = False ) ul = jp . Ul ( a = wp ) object = { 'title' : 'How to do lists in Vue' , 'author' : 'Jane Doe' , 'publishedAt' : '2016-04-10' } for name , value in object . items (): jp . Li ( text = f ' {name} : {value} ' , a = ul ) return wp jp . justpy ( for_example ) With index: import justpy as jp def for_example (): wp = jp . WebPage ( tailwind = False ) object = { 'title' : 'How to do lists in Vue' , 'author' : 'Jane Doe' , 'publishedAt' : '2016-04-10' } for index , ( name , value ) in enumerate ( object . items ()): jp . Div ( text = f ' {index} . {name} : {value} ' , a = wp ) return wp jp . justpy ( for_example ) Displaying Filtered/Sorted Results \u00b6 https://vuejs.org/v2/guide/list.html#Displaying-Filtered-Sorted-Results Reactivity \u00b6 JustPy is not reactive in the sense that if you change the value of an object, the rendered view will change automatically. This manifests itself when items are added or deleted, not when their property changes like text x-for \u00b6 <template x-for= \"(item, index) in items\" :key= \"index\" > <!-- You can also reference \"index\" inside the iteration if you need. --> <div x-text= \"index\" ></div> </template> from justpy import WebPage , Div , SetRoute SetRoute ( '/for' ) def for_example (): wp = WebPage () items = [ 'car' , 'plane' , 'train' ] for index , item in enumerate ( items ): Div ( text = f 'Item: {item} , Index: {index} ' , a = wp ) return wp Only applicable part: items = [ 'car' , 'plane' , 'train' ] for index , item in enumerate ( items ): Div ( text = f 'Item: {item} , Index: {index} ' , a = some_container ) Nesting: from justpy import WebPage , Div , SetRoute SetRoute ( '/nested_for' ) def for_example (): wp = WebPage () items = { 'car' : [ 'Ford' , 'Toyota' , 'GM' ], 'plane' : [ 'Boeing' , 'Airbus' ], 'train' : [ 'Amtrak' , 'NJ Transit' ]} for index , item in enumerate ( items ): for sub_item in items [ item ]: Div ( text = f 'Item: {item} , Sub Item: {sub_item} ' , a = wp ) return wp x-data vs class \u00b6 https://github.com/alpinejs/alpine#use import justpy as jp class SimpleDropdown ( jp . Div ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) b = jp . Button ( text = 'Open Dropdown' , a = self , click = 'self.u.show = not self.u.show' ) b . u = jp . Ul ( a = self , text = 'Drop Down Body' , show = False , click__out = 'self.show = False' ) def alpine_test (): wp = jp . WebPage () SimpleDropdown ( a = wp ) return wp jp . justpy ( alpine_test )","title":"Comparing Vue.js to JustPy"},{"location":"blog/vue_comparison/#comparing-vuejs-to-justpy","text":"","title":"Comparing Vue.js to JustPy"},{"location":"blog/vue_comparison/#example-from-vue-guide","text":"https://vuejs.org/v2/guide/components.html#Base-Example import justpy as jp class ButtonCounter ( jp . Button ): def __init__ ( self , ** kwargs ): self . count = 0 super () . __init__ ( ** kwargs ) self . on ( 'click' , self . button_clicked ) def button_clicked ( self , msg ): self . count += 1 def react ( self , data ): self . text = f 'You clicked me {self.count} times.' async def button_counter_demo (): wp = jp . WebPage ( tailwind = False ) for i in range ( 5 ): ButtonCounter ( a = wp , count = i , style = 'margin: 10px' ) return wp jp . justpy ( button_counter_demo )","title":"Example from Vue Guide"},{"location":"blog/vue_comparison/#vue-video-example","text":"import justpy as jp products = [ { 'id' : 1 , 'quantity' : 1 , 'name' : 'Compass' }, { 'id' : 2 , 'quantity' : 0 , 'name' : 'Jacket' }, { 'id' : 3 , 'quantity' : 5 , 'name' : 'Hiking Socks' }, { 'id' : 4 , 'quantity' : 2 , 'name' : 'Suntan Lotion' }, ] class Products ( jp . Div ): def __init__ ( self , ** kwargs ): self . products = products super () . __init__ ( ** kwargs ) self . ul = jp . Ul ( a = self ) self . total_inventory = jp . H2 ( text = 'Totals' , a = self ) def total_products ( self ): total = 0 for product in self . products : total += product [ \"quantity\" ] return total def react ( self , data ): self . ul . delete_components () for product in self . products : item = jp . Li ( a = self . ul ) jp . Input ( type = 'number' , product = product , a = item , value = product [ \"quantity\" ], input = 'self.product[\"quantity\"] = self.value' ) jp . Span ( text = f ' {product[\"quantity\"]} {product[\"name\"]} ' , a = item , style = 'margin-left: 10px' ) if product [ \"quantity\" ] == 0 : jp . Span ( text = ' - OUT OF STOCK' , a = item ) jp . Button ( text = 'Add' , a = item , product = product , click = 'self.product[\"quantity\"] += 1' , style = 'margin-left: 10px' ) self . total_inventory . text = f 'Total Inventory: {self.total_products()}' def product_app (): wp = jp . WebPage ( tailwind = False ) Products ( a = wp ) return wp jp . justpy ( product_app )","title":"Vue video example"},{"location":"blog/vue_comparison/#todo-list-example","text":"import justpy as jp class TodoList ( jp . Div ): def __init__ ( self , ** kwargs ): self . todos = [] super () . __init__ ( ** kwargs ) self . ol = jp . Ol ( a = self ) self . task = jp . Input ( placeholder = 'Enter task' , a = self ) jp . Button ( text = 'Add Task' , a = self , click = self . add_task , style = 'margin-left: 10px' ) def add_task ( self , msg ): self . todos . append ( self . task . value ) self . task . value = '' def react ( self , data ): self . ol . delete_components () for todo in self . todos : jp . Li ( text = todo , a = self . ol ) def todo_app (): wp = jp . WebPage ( tailwind = False ) TodoList ( a = wp , todos = [ 'Buy groceries' , 'Learn JustPy' , 'Do errands' ]) return wp jp . justpy ( todo_app ) First things first: JustPY uses Vue on the front end. Without Vue there is no JustPy. It is important to understand how JustPy uses Vue to understand the differences between the two. In JustPy, web pages as well as HTML components are represented as instances of classes. The HTML div element is represented by the JustPy class Div. You add a div to web page in JustPY by adding a Div instance to a WebPage instance like so: import justpy as jp wp = jp . WebPage () my_div = jp . Div ( text = 'hello' ) wp . add ( my_div ) All JustPy elements have a method called convert_object_to_dict that do just that. import justpy as jp my_div = jp . Div ( text = 'hello' ) my_div . add ( jp . Span ( text = 'span text' , style = 'margin: 5px' )) print ( my_div . convert_object_to_dict ()) would give the following result: { 'attrs' : {}, 'id' : None , 'vue_type' : 'html_component' , 'show' : True , 'events' : [], 'event_modifiers' : {}, 'classes' : '' , 'style' : '' , 'set_focus' : False , 'html_tag' : 'div' , 'class_name' : 'Div' , 'event_propagation' : True , 'inner_html' : '' , 'animation' : False , 'debug' : False , 'directives' : {}, 'scoped_slots' : {}, 'object_props' : [{ 'attrs' : {}, 'id' : None , 'vue_type' : 'html_component' , 'show' : True , 'events' : [], 'event_modifiers' : {}, 'classes' : '' , 'style' : 'margin: 5px' , 'set_focus' : False , 'html_tag' : 'span' , 'class_name' : 'Span' , 'event_propagation' : True , 'inner_html' : '' , 'animation' : False , 'debug' : False , 'directives' : {}, 'scoped_slots' : {}, 'object_props' : [], 'text' : 'span text' }], 'text' : 'hello' } This dictionary is converted to JSON and sent to the browser. It is then used as the props for the Vue component that renders the element on the page. To recap, JustPy creates a JSON object representing the page, and that object is fed into the Vue app which renders the page. Creating the dictionary on the server side is very cheap computationally. All the rendering heavy lifting is done by Vue. If as a consequence of an event handler a page changes, a new dictionary is sent to the page and again fed to the Vue app which re-renders the required elements. When JustPy renders a page in a browser tab using the following steps: 1) For all instances on the page, a Python dictionary that describes their attributes is generated. T explain how vue is used This comparison is meant to help people familiar with Vue understand JustPy better. JustPy is not a backend or frontend framework. When working with JustPy there is no distinction between the backend and the frontend. The reason you would use JustPy instead of Vue is if you are interested working predominantly in Python This comparison is not meant to convince you to use one or the other In vue there is distinction between html and javascript (render function means you don't need html). In JustPY it is all python (but you can use html if you like parse_html). Main difference is reactivity. How to solve this? Example with react function. But how to automate. Show how to make reactive list based on object. You need to do this with components. A component that is a list. You can make it reactive. Show example of for without component and then with component.","title":"Todo list example"},{"location":"blog/vue_comparison/#list-rendering-v-for","text":"The Vue.js examples are here . Example of rendering a simple list: ```python import justpy as jp def for_example(): wp = jp.WebPage(tailwind=False) items = [{'message': 'Foo'}, {'message': 'Bar'}] ul = jp.Ul(a=wp) for item in items: jp.Li(text=f'{item[\"message\"]}', a=ul) return wp jp.justpy(for_example) Second example with index : `` ` python import justpy as jp def for_example (): wp = jp . WebPage ( tailwind = False ) ul = jp . Ul ( a = wp ) ul . items = [{ 'message' : 'Foo' }, { 'message' : 'Bar' }] ul . parent_message = 'Parent' for index , item in enumerate ( ul . items ): jp . Li ( text = f '{ul.parent_message}-{index}-{item[\"message\"]}' , a = ul ) return wp jp . justpy ( for_example ) Note that the HTML elements are Python class instances and therefore we can assign values to their attributes.","title":"List Rendering (v-for)"},{"location":"blog/vue_comparison/#rendering-an-object","text":"https://vuejs.org/v2/guide/list.html#v-for-with-an-Object Rendering keys and values of an object: import justpy as jp def for_example (): wp = jp . WebPage ( tailwind = False ) ul = jp . Ul ( a = wp ) object = { 'title' : 'How to do lists in Vue' , 'author' : 'Jane Doe' , 'publishedAt' : '2016-04-10' } for name , value in object . items (): jp . Li ( text = f ' {name} : {value} ' , a = ul ) return wp jp . justpy ( for_example ) With index: import justpy as jp def for_example (): wp = jp . WebPage ( tailwind = False ) object = { 'title' : 'How to do lists in Vue' , 'author' : 'Jane Doe' , 'publishedAt' : '2016-04-10' } for index , ( name , value ) in enumerate ( object . items ()): jp . Div ( text = f ' {index} . {name} : {value} ' , a = wp ) return wp jp . justpy ( for_example )","title":"Rendering an object"},{"location":"blog/vue_comparison/#displaying-filteredsorted-results","text":"https://vuejs.org/v2/guide/list.html#Displaying-Filtered-Sorted-Results","title":"Displaying Filtered/Sorted Results"},{"location":"blog/vue_comparison/#reactivity","text":"JustPy is not reactive in the sense that if you change the value of an object, the rendered view will change automatically. This manifests itself when items are added or deleted, not when their property changes like text","title":"Reactivity"},{"location":"blog/vue_comparison/#x-for","text":"<template x-for= \"(item, index) in items\" :key= \"index\" > <!-- You can also reference \"index\" inside the iteration if you need. --> <div x-text= \"index\" ></div> </template> from justpy import WebPage , Div , SetRoute SetRoute ( '/for' ) def for_example (): wp = WebPage () items = [ 'car' , 'plane' , 'train' ] for index , item in enumerate ( items ): Div ( text = f 'Item: {item} , Index: {index} ' , a = wp ) return wp Only applicable part: items = [ 'car' , 'plane' , 'train' ] for index , item in enumerate ( items ): Div ( text = f 'Item: {item} , Index: {index} ' , a = some_container ) Nesting: from justpy import WebPage , Div , SetRoute SetRoute ( '/nested_for' ) def for_example (): wp = WebPage () items = { 'car' : [ 'Ford' , 'Toyota' , 'GM' ], 'plane' : [ 'Boeing' , 'Airbus' ], 'train' : [ 'Amtrak' , 'NJ Transit' ]} for index , item in enumerate ( items ): for sub_item in items [ item ]: Div ( text = f 'Item: {item} , Sub Item: {sub_item} ' , a = wp ) return wp","title":"x-for"},{"location":"blog/vue_comparison/#x-data-vs-class","text":"https://github.com/alpinejs/alpine#use import justpy as jp class SimpleDropdown ( jp . Div ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) b = jp . Button ( text = 'Open Dropdown' , a = self , click = 'self.u.show = not self.u.show' ) b . u = jp . Ul ( a = self , text = 'Drop Down Body' , show = False , click__out = 'self.show = False' ) def alpine_test (): wp = jp . WebPage () SimpleDropdown ( a = wp ) return wp jp . justpy ( alpine_test )","title":"x-data vs class"},{"location":"blog/vue_examples/","text":"JustPy Implementation of Vue.js Examples \u00b6 Base Example from Vue Guide \u00b6 Example in Vue.js Guide import justpy as jp class ButtonCounter ( jp . Button ): def __init__ ( self , ** kwargs ): self . count = 0 super () . __init__ ( ** kwargs ) self . on ( 'click' , self . button_clicked ) def button_clicked ( self , msg ): self . count += 1 def react ( self , data ): self . text = f 'You clicked me {self.count} times.' async def button_counter_demo (): wp = jp . WebPage ( tailwind = False ) for i in range ( 5 ): ButtonCounter ( a = wp , count = i , style = 'margin: 10px' ) return wp jp . justpy ( button_counter_demo ) Vue.js Introductory Video Example \u00b6 import justpy as jp products = [ { 'id' : 1 , 'quantity' : 1 , 'name' : 'Compass' }, { 'id' : 2 , 'quantity' : 0 , 'name' : 'Jacket' }, { 'id' : 3 , 'quantity' : 5 , 'name' : 'Hiking Socks' }, { 'id' : 4 , 'quantity' : 2 , 'name' : 'Suntan Lotion' }, ] class Products ( jp . Div ): def __init__ ( self , ** kwargs ): self . products = products super () . __init__ ( ** kwargs ) self . ul = jp . Ul ( a = self ) self . total_inventory = jp . H2 ( text = 'Totals' , a = self ) def total_products ( self ): total = 0 for product in self . products : total += product [ \"quantity\" ] return total def react ( self , data ): self . ul . delete_components () for product in self . products : item = jp . Li ( a = self . ul ) jp . Input ( type = 'number' , product = product , a = item , value = product [ \"quantity\" ], input = 'self.product[\"quantity\"] = self.value' ) jp . Span ( text = f ' {product[\"quantity\"]} {product[\"name\"]} ' , a = item , style = 'margin-left: 10px' ) if product [ \"quantity\" ] == 0 : jp . Span ( text = ' - OUT OF STOCK' , a = item ) jp . Button ( text = 'Add' , a = item , product = product , click = 'self.product[\"quantity\"] += 1' , style = 'margin-left: 10px' ) self . total_inventory . text = f 'Total Inventory: {self.total_products()}' def product_app (): wp = jp . WebPage ( tailwind = False ) Products ( a = wp ) return wp jp . justpy ( product_app ) Todo List Example \u00b6 import justpy as jp class TodoList ( jp . Div ): def __init__ ( self , ** kwargs ): self . todos = [] super () . __init__ ( ** kwargs ) self . ol = jp . Ol ( a = self ) self . task = jp . Input ( placeholder = 'Enter task' , a = self ) jp . Button ( text = 'Add Task' , a = self , click = self . add_task , style = 'margin-left: 10px' ) def add_task ( self , msg ): self . todos . append ( self . task . value ) self . task . value = '' def react ( self , data ): self . ol . delete_components () for todo in self . todos : jp . Li ( text = todo , a = self . ol ) def todo_app (): wp = jp . WebPage ( tailwind = False ) TodoList ( a = wp , todos = [ 'Buy groceries' , 'Learn JustPy' , 'Do errands' ]) return wp jp . justpy ( todo_app )","title":"Vue.js Examples in JustPy"},{"location":"blog/vue_examples/#justpy-implementation-of-vuejs-examples","text":"","title":"JustPy Implementation of Vue.js Examples"},{"location":"blog/vue_examples/#base-example-from-vue-guide","text":"Example in Vue.js Guide import justpy as jp class ButtonCounter ( jp . Button ): def __init__ ( self , ** kwargs ): self . count = 0 super () . __init__ ( ** kwargs ) self . on ( 'click' , self . button_clicked ) def button_clicked ( self , msg ): self . count += 1 def react ( self , data ): self . text = f 'You clicked me {self.count} times.' async def button_counter_demo (): wp = jp . WebPage ( tailwind = False ) for i in range ( 5 ): ButtonCounter ( a = wp , count = i , style = 'margin: 10px' ) return wp jp . justpy ( button_counter_demo )","title":"Base Example from Vue Guide"},{"location":"blog/vue_examples/#vuejs-introductory-video-example","text":"import justpy as jp products = [ { 'id' : 1 , 'quantity' : 1 , 'name' : 'Compass' }, { 'id' : 2 , 'quantity' : 0 , 'name' : 'Jacket' }, { 'id' : 3 , 'quantity' : 5 , 'name' : 'Hiking Socks' }, { 'id' : 4 , 'quantity' : 2 , 'name' : 'Suntan Lotion' }, ] class Products ( jp . Div ): def __init__ ( self , ** kwargs ): self . products = products super () . __init__ ( ** kwargs ) self . ul = jp . Ul ( a = self ) self . total_inventory = jp . H2 ( text = 'Totals' , a = self ) def total_products ( self ): total = 0 for product in self . products : total += product [ \"quantity\" ] return total def react ( self , data ): self . ul . delete_components () for product in self . products : item = jp . Li ( a = self . ul ) jp . Input ( type = 'number' , product = product , a = item , value = product [ \"quantity\" ], input = 'self.product[\"quantity\"] = self.value' ) jp . Span ( text = f ' {product[\"quantity\"]} {product[\"name\"]} ' , a = item , style = 'margin-left: 10px' ) if product [ \"quantity\" ] == 0 : jp . Span ( text = ' - OUT OF STOCK' , a = item ) jp . Button ( text = 'Add' , a = item , product = product , click = 'self.product[\"quantity\"] += 1' , style = 'margin-left: 10px' ) self . total_inventory . text = f 'Total Inventory: {self.total_products()}' def product_app (): wp = jp . WebPage ( tailwind = False ) Products ( a = wp ) return wp jp . justpy ( product_app )","title":"Vue.js Introductory Video Example"},{"location":"blog/vue_examples/#todo-list-example","text":"import justpy as jp class TodoList ( jp . Div ): def __init__ ( self , ** kwargs ): self . todos = [] super () . __init__ ( ** kwargs ) self . ol = jp . Ol ( a = self ) self . task = jp . Input ( placeholder = 'Enter task' , a = self ) jp . Button ( text = 'Add Task' , a = self , click = self . add_task , style = 'margin-left: 10px' ) def add_task ( self , msg ): self . todos . append ( self . task . value ) self . task . value = '' def react ( self , data ): self . ol . delete_components () for todo in self . todos : jp . Li ( text = todo , a = self . ol ) def todo_app (): wp = jp . WebPage ( tailwind = False ) TodoList ( a = wp , todos = [ 'Buy groceries' , 'Learn JustPy' , 'Do errands' ]) return wp jp . justpy ( todo_app )","title":"Todo List Example"},{"location":"charts_tutorial/chart_components/","text":"Chart Custom Components \u00b6 Components in JustPy are Python classes that inherit from other JustPy components. Components that inherit from HighCharts can also be defined. For example, below we define and use a pie chart component. Pie Chart Component \u00b6 import justpy as jp class MyPie ( jp . HighCharts ): _options = \"\"\" { chart: { type: 'pie' }, title: { text: 'Pie Chart' }, tooltip: { pointFormat: ' {series.name} : <b> {point.percentage:.1f} %</b>' }, plotOptions: { pie: { allowPointSelect: true, cursor: 'pointer', dataLabels: { enabled: true, format: '<b> {point.name} </b>: {point.percentage:.1f} %', } } }, series: [] } \"\"\" def __init__ ( self , data , ** kwargs ): self . labels = [] super () . __init__ ( ** kwargs ) self . load_json ( self . _options ) pie_series = jp . Dict () pie_series . data = [] for i , value in enumerate ( data ): c = jp . Dict () try : c . name = self . labels [ i ] except : c . name = str ( value ) c . y = value pie_series . data . append ( c ) self . options . series . append ( pie_series ) def pie_test ( request ): wp = jp . WebPage () chart = MyPie ([ 2 , 3 , 4 , 5 ], labels = [ 'Apples' , 'Pears' , 'Bananas' , 'Melons' ], a = wp , classes = 'm-2 p-2 border w-1/2' ) chart . options . title . text = 'Fruit Distribution' chart . options . series [ 0 ] . name = 'Fruits' return wp jp . justpy ( pie_test ) The chart instance that is created can be further modified by changing its options. In the example above we change the chart title and the name of the series. Histogram Component \u00b6 A component that comes with JustPy is Histogram. It simplifies creating a histogram chart. In this example, we include the definition. Warning In order to run this example, you need to install numpy import justpy as jp import random import numpy class Histogram ( jp . HighCharts ): _options = \"\"\" { title: { text: 'Highcharts Histogram' }, xAxis: [{ title: { text: 'Data' }, alignTicks: false }, { title: { text: 'Histogram' }, alignTicks: false, opposite: true }], yAxis: [{ title: { text: 'Data' } }, { title: { text: 'Histogram' }, opposite: true }], series: [{ name: 'Histogram', type: 'histogram', xAxis: 1, yAxis: 1, baseSeries: 's1', zIndex: -1 }, { name: 'Data', type: 'scatter', data: [], id: 's1', marker: { radius: 1.5 } }] } \"\"\" def __init__ ( self , data , ** kwargs ): super () . __init__ ( ** kwargs ) self . load_json ( self . _options ) self . options . series [ 1 ] . data = list ( data ) def histogram_test ( request ): wp = jp . WebPage () # Uniform distribution data = [ random . randrange ( 10 ) for i in range ( 100 )] chart = jp . Histogram ( data , a = wp , classes = 'm-2 border w-1/2' ) chart . options . title . text = 'Uniform Distribution Histogram' # Normal distribution data = [ numpy . random . normal () for i in range ( 1000 )] chart = jp . Histogram ( data , a = wp , classes = 'm-2 border w-1/2' ) chart . options . title . text = 'Normal Distribution Histogram' return wp jp . justpy ( histogram_test ) The Histogram class relies on a chart definition from the Highcharts documentation. Encompassing the chart definition in a class simplifies its use. If you build such classes for your favorite charts, please send them to me to include in JustPy. Once the Histogram class (component) is defined, reusing it is simple and does not require remembering the specifics of the Highcharts API. The instance of HighCharts can be further modified. In the example above, we change the chart titles after the chart has been created. Scatter with Regression \u00b6 Let's build a component that automatically adds a regression line to a scatter chart. We will use the predefined JustPy Scatter component. import justpy as jp import numpy as np class ScatterWithRegression ( jp . Scatter ): def __init__ ( self , x , y , ** kwargs ): super () . __init__ ( x , y , ** kwargs ) x = np . asarray ( x ) y = np . asarray ( y ) m = ( len ( x ) * np . sum ( x * y ) - np . sum ( x ) * np . sum ( y )) / ( len ( x ) * np . sum ( x * x ) - np . sum ( x ) ** 2 ) b = ( np . sum ( y ) - m * np . sum ( x )) / len ( x ) s = jp . Dict () # The new series s . type = 'line' s . marker . enabled = False s . enableMouseTracking = False min = float ( x . min ()) max = float ( x . max ()) s . data = [[ min , m * min + b ], [ max , m * max + b ]] s . name = f 'Regression, m: {round(m, 3)}, b: {round(b, 3)}' self . options . series . append ( s ) def scatter_test ( request ): wp = jp . WebPage ( highcharts_theme = 'grid-light' ) x = [ 108 , 19 , 13 , 124 , 40 , 57 , 23 , 14 , 45 , 10 , 5 , 48 , 11 , 23 , 7 , 2 , 24 , 6 , 3 , 23 , 6 , 9 , 9 , 3 , 29 , 7 , 4 , 20 , 7 , 4 , 0 , 25 , 6 , 5 , 22 , 11 , 61 , 12 , 4 , 16 , 13 , 60 , 41 , 37 , 55 , 41 , 11 , 27 , 8 , 3 , 17 , 13 , 13 , 15 , 8 , 29 , 30 , 24 , 9 , 31 , 14 , 53 , 26 ] y = [ 392.5 , 46.2 , 15.7 , 422.2 , 119.4 , 170.9 , 56.9 , 77.5 , 214 , 65.3 , 20.9 , 248.1 , 23.5 , 39.6 , 48.8 , 6.6 , 134.9 , 50.9 , 4.4 , 113 , 14.8 , 48.7 , 52.1 , 13.2 , 103.9 , 77.5 , 11.8 , 98.1 , 27.9 , 38.1 , 0 , 69.2 , 14.6 , 40.3 , 161.5 , 57.2 , 217.6 , 58.1 , 12.6 , 59.6 , 89.9 , 202.4 , 181.3 , 152.8 , 162.8 , 73.4 , 21.3 , 92.6 , 76.1 , 39.9 , 142.1 , 93 , 31.9 , 32.1 , 55.6 , 133.3 , 194.5 , 137.9 , 87.4 , 209.8 , 95.5 , 244.6 , 187.5 ] jp . Scatter ( x , y , a = wp , classes = 'm-2 w-1/2 border' , style = 'height: 300px' ) sr = ScatterWithRegression ( x , y , a = wp , classes = 'm-2 w-1/2 border' , style = 'height: 300px' ) sr . options . title . text = 'Scatter Chart with Regression' return wp jp . justpy ( scatter_test ) The new component adds another series to the chart. This series has only two points which are the regression values of the smallest and largest x values. The line between them is the regression line. We now have a component we can reuse to plot a scatter plot with a regression line.","title":"Chart Components"},{"location":"charts_tutorial/chart_components/#chart-custom-components","text":"Components in JustPy are Python classes that inherit from other JustPy components. Components that inherit from HighCharts can also be defined. For example, below we define and use a pie chart component.","title":"Chart Custom Components"},{"location":"charts_tutorial/chart_components/#pie-chart-component","text":"import justpy as jp class MyPie ( jp . HighCharts ): _options = \"\"\" { chart: { type: 'pie' }, title: { text: 'Pie Chart' }, tooltip: { pointFormat: ' {series.name} : <b> {point.percentage:.1f} %</b>' }, plotOptions: { pie: { allowPointSelect: true, cursor: 'pointer', dataLabels: { enabled: true, format: '<b> {point.name} </b>: {point.percentage:.1f} %', } } }, series: [] } \"\"\" def __init__ ( self , data , ** kwargs ): self . labels = [] super () . __init__ ( ** kwargs ) self . load_json ( self . _options ) pie_series = jp . Dict () pie_series . data = [] for i , value in enumerate ( data ): c = jp . Dict () try : c . name = self . labels [ i ] except : c . name = str ( value ) c . y = value pie_series . data . append ( c ) self . options . series . append ( pie_series ) def pie_test ( request ): wp = jp . WebPage () chart = MyPie ([ 2 , 3 , 4 , 5 ], labels = [ 'Apples' , 'Pears' , 'Bananas' , 'Melons' ], a = wp , classes = 'm-2 p-2 border w-1/2' ) chart . options . title . text = 'Fruit Distribution' chart . options . series [ 0 ] . name = 'Fruits' return wp jp . justpy ( pie_test ) The chart instance that is created can be further modified by changing its options. In the example above we change the chart title and the name of the series.","title":"Pie Chart Component"},{"location":"charts_tutorial/chart_components/#histogram-component","text":"A component that comes with JustPy is Histogram. It simplifies creating a histogram chart. In this example, we include the definition. Warning In order to run this example, you need to install numpy import justpy as jp import random import numpy class Histogram ( jp . HighCharts ): _options = \"\"\" { title: { text: 'Highcharts Histogram' }, xAxis: [{ title: { text: 'Data' }, alignTicks: false }, { title: { text: 'Histogram' }, alignTicks: false, opposite: true }], yAxis: [{ title: { text: 'Data' } }, { title: { text: 'Histogram' }, opposite: true }], series: [{ name: 'Histogram', type: 'histogram', xAxis: 1, yAxis: 1, baseSeries: 's1', zIndex: -1 }, { name: 'Data', type: 'scatter', data: [], id: 's1', marker: { radius: 1.5 } }] } \"\"\" def __init__ ( self , data , ** kwargs ): super () . __init__ ( ** kwargs ) self . load_json ( self . _options ) self . options . series [ 1 ] . data = list ( data ) def histogram_test ( request ): wp = jp . WebPage () # Uniform distribution data = [ random . randrange ( 10 ) for i in range ( 100 )] chart = jp . Histogram ( data , a = wp , classes = 'm-2 border w-1/2' ) chart . options . title . text = 'Uniform Distribution Histogram' # Normal distribution data = [ numpy . random . normal () for i in range ( 1000 )] chart = jp . Histogram ( data , a = wp , classes = 'm-2 border w-1/2' ) chart . options . title . text = 'Normal Distribution Histogram' return wp jp . justpy ( histogram_test ) The Histogram class relies on a chart definition from the Highcharts documentation. Encompassing the chart definition in a class simplifies its use. If you build such classes for your favorite charts, please send them to me to include in JustPy. Once the Histogram class (component) is defined, reusing it is simple and does not require remembering the specifics of the Highcharts API. The instance of HighCharts can be further modified. In the example above, we change the chart titles after the chart has been created.","title":"Histogram Component"},{"location":"charts_tutorial/chart_components/#scatter-with-regression","text":"Let's build a component that automatically adds a regression line to a scatter chart. We will use the predefined JustPy Scatter component. import justpy as jp import numpy as np class ScatterWithRegression ( jp . Scatter ): def __init__ ( self , x , y , ** kwargs ): super () . __init__ ( x , y , ** kwargs ) x = np . asarray ( x ) y = np . asarray ( y ) m = ( len ( x ) * np . sum ( x * y ) - np . sum ( x ) * np . sum ( y )) / ( len ( x ) * np . sum ( x * x ) - np . sum ( x ) ** 2 ) b = ( np . sum ( y ) - m * np . sum ( x )) / len ( x ) s = jp . Dict () # The new series s . type = 'line' s . marker . enabled = False s . enableMouseTracking = False min = float ( x . min ()) max = float ( x . max ()) s . data = [[ min , m * min + b ], [ max , m * max + b ]] s . name = f 'Regression, m: {round(m, 3)}, b: {round(b, 3)}' self . options . series . append ( s ) def scatter_test ( request ): wp = jp . WebPage ( highcharts_theme = 'grid-light' ) x = [ 108 , 19 , 13 , 124 , 40 , 57 , 23 , 14 , 45 , 10 , 5 , 48 , 11 , 23 , 7 , 2 , 24 , 6 , 3 , 23 , 6 , 9 , 9 , 3 , 29 , 7 , 4 , 20 , 7 , 4 , 0 , 25 , 6 , 5 , 22 , 11 , 61 , 12 , 4 , 16 , 13 , 60 , 41 , 37 , 55 , 41 , 11 , 27 , 8 , 3 , 17 , 13 , 13 , 15 , 8 , 29 , 30 , 24 , 9 , 31 , 14 , 53 , 26 ] y = [ 392.5 , 46.2 , 15.7 , 422.2 , 119.4 , 170.9 , 56.9 , 77.5 , 214 , 65.3 , 20.9 , 248.1 , 23.5 , 39.6 , 48.8 , 6.6 , 134.9 , 50.9 , 4.4 , 113 , 14.8 , 48.7 , 52.1 , 13.2 , 103.9 , 77.5 , 11.8 , 98.1 , 27.9 , 38.1 , 0 , 69.2 , 14.6 , 40.3 , 161.5 , 57.2 , 217.6 , 58.1 , 12.6 , 59.6 , 89.9 , 202.4 , 181.3 , 152.8 , 162.8 , 73.4 , 21.3 , 92.6 , 76.1 , 39.9 , 142.1 , 93 , 31.9 , 32.1 , 55.6 , 133.3 , 194.5 , 137.9 , 87.4 , 209.8 , 95.5 , 244.6 , 187.5 ] jp . Scatter ( x , y , a = wp , classes = 'm-2 w-1/2 border' , style = 'height: 300px' ) sr = ScatterWithRegression ( x , y , a = wp , classes = 'm-2 w-1/2 border' , style = 'height: 300px' ) sr . options . title . text = 'Scatter Chart with Regression' return wp jp . justpy ( scatter_test ) The new component adds another series to the chart. This series has only two points which are the regression values of the smallest and largest x values. The line between them is the regression line. We now have a component we can reuse to plot a scatter plot with a regression line.","title":"Scatter with Regression"},{"location":"charts_tutorial/chart_events/","text":"Chart Events and Methods \u00b6 Events \u00b6 The HighCharts component supports events that allow making charts more interactive: point_click - fires when a point is clicked point_select - fires when a point is selected point_unselect - fires when point is unselected series_hide - fires when series is hidden series_show - fires when series is shown series_click - fires when series is clicked tooltip - fires when chart requests a tooltip (covered in its own chapter in the tutorial) For all chart events, JustPy adds the following fields to the second argument of the event handler ( msg in this tutorial): - msg.x - the x value of the point - msg.y - the y value of the point - msg.category - the category value of the point - msg.color - the point's color - msg.series_name - the name of the series the point is in - msg.series_index - the index of the series the point is in - msg.point_index - the index of the point in the series Methods \u00b6 async def draw_crosshair(self, point_list, websocket) \u00b6 Draw crosshairs for designated points. async def draw_crosshair ( self , point_list , websocket ): # data is list of of dictionaries whose keys are: # 'id': the chart id # 'series': the series index # 'point': the point index # Values are all integers # Example: # {'id': chart_id, 'series': msg.series_index, 'point': msg.point_index} await websocket . send_json ({ 'type' : 'draw_crosshair' , 'data' : point_list }) # So the page itself does not update, only the tooltip, return True not None return True See example of usage in Iris Flower Dataset Visualization async def select_point(self, point_list, websocket) \u00b6 Selects designated points. async def select_point ( self , point_list , websocket ): # data is list of of dictionaries whose keys are: # 'id': the chart id # 'series': the series index # 'point': the point index # Values are all integers # Example: # {'id': chart_id, 'series': msg.series_index, 'point': msg.point_index} await websocket . send_json ({ 'type' : 'select_point' , 'data' : point_list }) # So the page itself does not update, only the tooltip, return True not None return True See example of usage in Iris Flower Dataset Visualization","title":"Chart Events"},{"location":"charts_tutorial/chart_events/#chart-events-and-methods","text":"","title":"Chart Events and Methods"},{"location":"charts_tutorial/chart_events/#events","text":"The HighCharts component supports events that allow making charts more interactive: point_click - fires when a point is clicked point_select - fires when a point is selected point_unselect - fires when point is unselected series_hide - fires when series is hidden series_show - fires when series is shown series_click - fires when series is clicked tooltip - fires when chart requests a tooltip (covered in its own chapter in the tutorial) For all chart events, JustPy adds the following fields to the second argument of the event handler ( msg in this tutorial): - msg.x - the x value of the point - msg.y - the y value of the point - msg.category - the category value of the point - msg.color - the point's color - msg.series_name - the name of the series the point is in - msg.series_index - the index of the series the point is in - msg.point_index - the index of the point in the series","title":"Events"},{"location":"charts_tutorial/chart_events/#methods","text":"","title":"Methods"},{"location":"charts_tutorial/chart_events/#async-def-draw_crosshairself-point_list-websocket","text":"Draw crosshairs for designated points. async def draw_crosshair ( self , point_list , websocket ): # data is list of of dictionaries whose keys are: # 'id': the chart id # 'series': the series index # 'point': the point index # Values are all integers # Example: # {'id': chart_id, 'series': msg.series_index, 'point': msg.point_index} await websocket . send_json ({ 'type' : 'draw_crosshair' , 'data' : point_list }) # So the page itself does not update, only the tooltip, return True not None return True See example of usage in Iris Flower Dataset Visualization","title":"async def draw_crosshair(self, point_list, websocket)"},{"location":"charts_tutorial/chart_events/#async-def-select_pointself-point_list-websocket","text":"Selects designated points. async def select_point ( self , point_list , websocket ): # data is list of of dictionaries whose keys are: # 'id': the chart id # 'series': the series index # 'point': the point index # Values are all integers # Example: # {'id': chart_id, 'series': msg.series_index, 'point': msg.point_index} await websocket . send_json ({ 'type' : 'select_point' , 'data' : point_list }) # So the page itself does not update, only the tooltip, return True not None return True See example of usage in Iris Flower Dataset Visualization","title":"async def select_point(self, point_list, websocket)"},{"location":"charts_tutorial/creating_charts/","text":"Creating Charts \u00b6 Your First Chart \u00b6 To begin, we'll use the Highchart's documentation Your First Chart example. In JustPy this example would look like this: import justpy as jp # Example from https://www.highcharts.com/docs/getting-started/your-first-chart my_chart_def = \"\"\" { chart: { type: 'bar' }, title: { text: 'Fruit Consumption' }, xAxis: { categories: ['Apples', 'Bananas', 'Oranges'] }, yAxis: { title: { text: 'Fruit eaten' } }, series: [{ name: 'Jane', data: [1, 0, 4] }, { name: 'John', data: [5, 7, 3] }] } \"\"\" def chart_test (): wp = jp . WebPage () my_chart = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border' , style = 'width: 600px' ) my_chart . options = my_chart_def return wp jp . justpy ( chart_test ) Run the program above as explained here . We create a chart using the JustPy HighCharts class. Like other JustPy components, it recognizes keyword arguments like classes , style and a . In this example the variable my_chart_def defines the chart's options (settings). It is a string which can be converted directly to a valid JavaScript object. This JavaScript object is not however a valid Python dictionary because the keys of the object (for example chart and title ) do not have single quotes or double quotes around them and therefore are not valid Python keys. When my_chart_def is assigned to my_chart.options the code in HighCharts (a Python class) checks if a string is being assigned, and if that is the case, it is converted to a Python dictionary that also allows dot notation . If a standard Python dictionary is assigned to the options attribute, it is also converted to a dictionary that allows dot notation access. Don't worry if this is not completely clear at this stage. There are plenty of examples coming that will make things clearer. Try for example, changing the text of the chart title in my_chart_def and running the program again. Chart Types \u00b6 Let's do something a little more complex. Change chart_test in the above example to the following: def chart_test (): wp = jp . WebPage () for chart_type in [ 'bar' , 'column' , 'line' , 'spline' ]: my_chart = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) my_chart . options . chart . type = chart_type my_chart . options . title . text = f 'Chart of Type {chart_type.capitalize()}' my_chart . options . subtitle . text = f 'Subtitle {chart_type.capitalize()}' return wp Four charts are created and put on the page, each one of a different type. We accomplish this by iterating over a list with four different chart types that Highcharts supports. When we create each chart, we load the same options (via a keyword argument) to all of them. Info The reference for the Highcharts chart options can be found at https://api.highcharts.com/highcharts/ However, we then proceed to change the options. Using the dot notation, we assign different values to options.chart.type , options.title.text and options.subtitle.text . Note Notice that options.subtitle was not specified in my_chart_def . The addict library Dict structure creates sub dictionaries automatically when required. Using Highcharts Online Examples \u00b6 There are many examples of Highcharts charts online and particularly in the Highcharts documentation . The structure of the options attribute of HighCharts (the Python class defined by JustPy) matches exactly the structure of the JavaScript object that defines the settings of a Highchart JavaScript chart. This is very convenient and allows you to use the numerous JavaScript examples of Highcharts charts as a starting point for your own charts. The Highcharts library is a JavaScript library and the the chart examples are all in JavaScript. That is why JustPy's HighCharts supports converting strings that represent simple Javascript objects to Python dictionaries. Let's look at a concrete example from the Highcharts documentation. Please go to https://api.highcharts.com/highcharts/chart.type and follow the link under \"Try it\" labeled \"Bar\" . In the Highcharts documentation and in other discussions of Highcharts it is common to link to a JavaScript jsfiddle or codepen working example. In this case, a jsfiddle window opens. Look at the JavaScript window in the lower left of the page. The second argument to Highcharts.chart is the JavaScript object that defines the chart. Let's copy this object and assign it to a Python string and try replicating this chart. If you simply copy the object like I did below, you will get an error. Run the program and see for yourself there is an issue. import justpy as jp my_chart_def = \"\"\" { chart: { type: 'bar' }, xAxis: { categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }, legend: { layout: 'vertical', floating: true, backgroundColor: '#FFFFFF', align: 'right', verticalAlign: 'top', y: 60, x: -60 }, tooltip: { formatter: function () { return '<b>' + this.series.name + '</b><br/>' + this.x + ': ' + this.y; } }, series: [{ data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4] }] } \"\"\" def chart_test (): wp = jp . WebPage () my_chart = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) return wp jp . justpy ( chart_test ) The problem is that the value of the tooltip.formatter key is a JavaScript function definition. JustPy does not support this. We will soon see how to define tooltip formatters in JustPy, but for now, please remove the whole tooltip section and run the program. Your program should look like this: import justpy as jp my_chart_def = \"\"\" { chart: { type: 'bar' }, xAxis: { categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }, legend: { layout: 'vertical', floating: true, backgroundColor: '#FFFFFF', align: 'right', verticalAlign: 'top', y: 60, x: -60 }, series: [{ data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4] }] } \"\"\" def chart_test (): wp = jp . WebPage () my_chart = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) my_chart . options . series [ 0 ] . name = 'Tourists in \\' 000' my_chart . options . title . text = 'Tourists in Middle Earth' return wp jp . justpy ( chart_test ) This time, there is no error. When you copy a JavaScript object, make sure that it does not include function definitions or uses JavaScript language functions to compute values. These will cause errors. Warning JustPy can only parse JavaScript objects that look like a Python dictionary except for the missing quotes around the dictionary keys. Also, mixing single and double quotes in the JavaScript object may cause problems. Use only single quotes as is the norm with most Highcharts examples. Tip It is very likely someone has already created a chart like that one you need and put it online. Use that chart as a stepping stone to create yours. Eventually, you may need to make use of the excellent Highcharts docs Chart Series \u00b6 Notice that we have added two lines to chart_test above. The first of these lines gives the series a name and makes the legend more informative. Note The Dicts that describe the series of a chart are held in a list so the first series is options.series[0] Here is an example of how you create a chart with multiple series. Warning numpy needs to be installed for this example to work import justpy as jp import numpy as np def sine_test (): wp = jp . WebPage () chart = jp . HighCharts ( a = wp , classes = 'border m-2 p-2 w-3/4' ) o = chart . options o . title . text = 'Sines Galore' x = np . linspace ( - np . pi , np . pi , 201 ) for frequency in range ( 1 , 11 ): y = np . sin ( frequency * x ) s = jp . Dict () s . name = f 'F {frequency} ' s . data = list ( zip ( x , y )) o . series . append ( s ) return wp jp . justpy ( sine_test ) This example uses numpy to generate sines with different frequencies and adds them as separate series to a chart (numpy needs to be installed for this example to work). This and other examples will use the Python standard library function zip . Using zip , it is very simple to create lists of x, y pairs which is one data format Highcharts supports for its series (it supports other formats also such as dictionaries). Try moving the mouse over different areas of the chart to see its interactive features. For example, when you hover over a series name in the legend, it highlights the series. When you click the series name in the legend, it is disabled. Sharing Charts \u00b6 In many cases, having created a chart, you would like to share it with others. One way is to deploy JustPy and have people access the charts via a URL. import justpy as jp # https://github.com/elimintz/elimintz.github.io/tree/master/charts # Try https://127.0.0.1:8000/ + any one of the entries in charts # For example: http://127.0.0.1:8000/bubbles charts = [ 'org' , 'bubbles' , 'item' , 'timeline' , 'states' , 'browsers' , 'wheel' ] @jp . SetRoute ( '/ {chart_name} ' ) async def chart_test ( request ): wp = jp . WebPage () chart_name = request . path_params . get ( 'chart_name' , 'item' ) # Default chart is item if chart_name not in charts : chart_name = 'item' chart_options = await jp . get ( f 'https://elimintz.github.io/charts/ {chart_name} ' , 'text' ) my_chart = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-3/4' , options = chart_options ) return wp jp . justpy ( chart_test ) The program above fetches chart definitions from a static page server (a github repository in this case) based on the URL. Take a look at the different charts for a small taste of what Highcharts can do (these are all taken from the Highcharts website where there are many more examples). You could deploy the program above and have others accessing the charts via the appropriate URLs. The chart definitions can be found here . Another option is to send people the code snippet above to run by themselves. Of course, they would need to have the appropriate environment installed on their computer. The advantage of reading the chart definition remotely is that you can change these remote files and additional files without needing to resend or restart your program.","title":"Creating Charts"},{"location":"charts_tutorial/creating_charts/#creating-charts","text":"","title":"Creating Charts"},{"location":"charts_tutorial/creating_charts/#your-first-chart","text":"To begin, we'll use the Highchart's documentation Your First Chart example. In JustPy this example would look like this: import justpy as jp # Example from https://www.highcharts.com/docs/getting-started/your-first-chart my_chart_def = \"\"\" { chart: { type: 'bar' }, title: { text: 'Fruit Consumption' }, xAxis: { categories: ['Apples', 'Bananas', 'Oranges'] }, yAxis: { title: { text: 'Fruit eaten' } }, series: [{ name: 'Jane', data: [1, 0, 4] }, { name: 'John', data: [5, 7, 3] }] } \"\"\" def chart_test (): wp = jp . WebPage () my_chart = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border' , style = 'width: 600px' ) my_chart . options = my_chart_def return wp jp . justpy ( chart_test ) Run the program above as explained here . We create a chart using the JustPy HighCharts class. Like other JustPy components, it recognizes keyword arguments like classes , style and a . In this example the variable my_chart_def defines the chart's options (settings). It is a string which can be converted directly to a valid JavaScript object. This JavaScript object is not however a valid Python dictionary because the keys of the object (for example chart and title ) do not have single quotes or double quotes around them and therefore are not valid Python keys. When my_chart_def is assigned to my_chart.options the code in HighCharts (a Python class) checks if a string is being assigned, and if that is the case, it is converted to a Python dictionary that also allows dot notation . If a standard Python dictionary is assigned to the options attribute, it is also converted to a dictionary that allows dot notation access. Don't worry if this is not completely clear at this stage. There are plenty of examples coming that will make things clearer. Try for example, changing the text of the chart title in my_chart_def and running the program again.","title":"Your First Chart"},{"location":"charts_tutorial/creating_charts/#chart-types","text":"Let's do something a little more complex. Change chart_test in the above example to the following: def chart_test (): wp = jp . WebPage () for chart_type in [ 'bar' , 'column' , 'line' , 'spline' ]: my_chart = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) my_chart . options . chart . type = chart_type my_chart . options . title . text = f 'Chart of Type {chart_type.capitalize()}' my_chart . options . subtitle . text = f 'Subtitle {chart_type.capitalize()}' return wp Four charts are created and put on the page, each one of a different type. We accomplish this by iterating over a list with four different chart types that Highcharts supports. When we create each chart, we load the same options (via a keyword argument) to all of them. Info The reference for the Highcharts chart options can be found at https://api.highcharts.com/highcharts/ However, we then proceed to change the options. Using the dot notation, we assign different values to options.chart.type , options.title.text and options.subtitle.text . Note Notice that options.subtitle was not specified in my_chart_def . The addict library Dict structure creates sub dictionaries automatically when required.","title":"Chart Types"},{"location":"charts_tutorial/creating_charts/#using-highcharts-online-examples","text":"There are many examples of Highcharts charts online and particularly in the Highcharts documentation . The structure of the options attribute of HighCharts (the Python class defined by JustPy) matches exactly the structure of the JavaScript object that defines the settings of a Highchart JavaScript chart. This is very convenient and allows you to use the numerous JavaScript examples of Highcharts charts as a starting point for your own charts. The Highcharts library is a JavaScript library and the the chart examples are all in JavaScript. That is why JustPy's HighCharts supports converting strings that represent simple Javascript objects to Python dictionaries. Let's look at a concrete example from the Highcharts documentation. Please go to https://api.highcharts.com/highcharts/chart.type and follow the link under \"Try it\" labeled \"Bar\" . In the Highcharts documentation and in other discussions of Highcharts it is common to link to a JavaScript jsfiddle or codepen working example. In this case, a jsfiddle window opens. Look at the JavaScript window in the lower left of the page. The second argument to Highcharts.chart is the JavaScript object that defines the chart. Let's copy this object and assign it to a Python string and try replicating this chart. If you simply copy the object like I did below, you will get an error. Run the program and see for yourself there is an issue. import justpy as jp my_chart_def = \"\"\" { chart: { type: 'bar' }, xAxis: { categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }, legend: { layout: 'vertical', floating: true, backgroundColor: '#FFFFFF', align: 'right', verticalAlign: 'top', y: 60, x: -60 }, tooltip: { formatter: function () { return '<b>' + this.series.name + '</b><br/>' + this.x + ': ' + this.y; } }, series: [{ data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4] }] } \"\"\" def chart_test (): wp = jp . WebPage () my_chart = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) return wp jp . justpy ( chart_test ) The problem is that the value of the tooltip.formatter key is a JavaScript function definition. JustPy does not support this. We will soon see how to define tooltip formatters in JustPy, but for now, please remove the whole tooltip section and run the program. Your program should look like this: import justpy as jp my_chart_def = \"\"\" { chart: { type: 'bar' }, xAxis: { categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }, legend: { layout: 'vertical', floating: true, backgroundColor: '#FFFFFF', align: 'right', verticalAlign: 'top', y: 60, x: -60 }, series: [{ data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4] }] } \"\"\" def chart_test (): wp = jp . WebPage () my_chart = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) my_chart . options . series [ 0 ] . name = 'Tourists in \\' 000' my_chart . options . title . text = 'Tourists in Middle Earth' return wp jp . justpy ( chart_test ) This time, there is no error. When you copy a JavaScript object, make sure that it does not include function definitions or uses JavaScript language functions to compute values. These will cause errors. Warning JustPy can only parse JavaScript objects that look like a Python dictionary except for the missing quotes around the dictionary keys. Also, mixing single and double quotes in the JavaScript object may cause problems. Use only single quotes as is the norm with most Highcharts examples. Tip It is very likely someone has already created a chart like that one you need and put it online. Use that chart as a stepping stone to create yours. Eventually, you may need to make use of the excellent Highcharts docs","title":"Using Highcharts Online Examples"},{"location":"charts_tutorial/creating_charts/#chart-series","text":"Notice that we have added two lines to chart_test above. The first of these lines gives the series a name and makes the legend more informative. Note The Dicts that describe the series of a chart are held in a list so the first series is options.series[0] Here is an example of how you create a chart with multiple series. Warning numpy needs to be installed for this example to work import justpy as jp import numpy as np def sine_test (): wp = jp . WebPage () chart = jp . HighCharts ( a = wp , classes = 'border m-2 p-2 w-3/4' ) o = chart . options o . title . text = 'Sines Galore' x = np . linspace ( - np . pi , np . pi , 201 ) for frequency in range ( 1 , 11 ): y = np . sin ( frequency * x ) s = jp . Dict () s . name = f 'F {frequency} ' s . data = list ( zip ( x , y )) o . series . append ( s ) return wp jp . justpy ( sine_test ) This example uses numpy to generate sines with different frequencies and adds them as separate series to a chart (numpy needs to be installed for this example to work). This and other examples will use the Python standard library function zip . Using zip , it is very simple to create lists of x, y pairs which is one data format Highcharts supports for its series (it supports other formats also such as dictionaries). Try moving the mouse over different areas of the chart to see its interactive features. For example, when you hover over a series name in the legend, it highlights the series. When you click the series name in the legend, it is disabled.","title":"Chart Series"},{"location":"charts_tutorial/creating_charts/#sharing-charts","text":"In many cases, having created a chart, you would like to share it with others. One way is to deploy JustPy and have people access the charts via a URL. import justpy as jp # https://github.com/elimintz/elimintz.github.io/tree/master/charts # Try https://127.0.0.1:8000/ + any one of the entries in charts # For example: http://127.0.0.1:8000/bubbles charts = [ 'org' , 'bubbles' , 'item' , 'timeline' , 'states' , 'browsers' , 'wheel' ] @jp . SetRoute ( '/ {chart_name} ' ) async def chart_test ( request ): wp = jp . WebPage () chart_name = request . path_params . get ( 'chart_name' , 'item' ) # Default chart is item if chart_name not in charts : chart_name = 'item' chart_options = await jp . get ( f 'https://elimintz.github.io/charts/ {chart_name} ' , 'text' ) my_chart = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-3/4' , options = chart_options ) return wp jp . justpy ( chart_test ) The program above fetches chart definitions from a static page server (a github repository in this case) based on the URL. Take a look at the different charts for a small taste of what Highcharts can do (these are all taken from the Highcharts website where there are many more examples). You could deploy the program above and have others accessing the charts via the appropriate URLs. The chart definitions can be found here . Another option is to send people the code snippet above to run by themselves. Of course, they would need to have the appropriate environment installed on their computer. The advantage of reading the chart definition remotely is that you can change these remote files and additional files without needing to resend or restart your program.","title":"Sharing Charts"},{"location":"charts_tutorial/introduction/","text":"Highcharts Introduction \u00b6 Note It is recommended to go through the general tutorial first. JustPy makes it simple to create charts using the Highcharts JavaScript charting library. Info JustPy also supports matplotlib charts There are several JavaScript charting libraries available, but my personal favorite is Highcharts. It is not too difficult to integrate other charting libraries with JustPy, so perhaps more charting libraries will be supported in the future. The Highcharts and JustPy combination is great for creating and sharing interactive charts, even if you don't plan to develop a web application. JustPy allows you to share your visualizations by providing access to the charts through any browser. Highcharts is free for non-commercial use and this includes individuals using the software for personal use, testing and demonstration. A Highcharts chart in JustPy is a component. It is represented by a Python class, just like any other component. Because Highcharts is a JavaScript library it uses a JavaScript object to define the options or settings of a chart. In JustPy however, charts are defined using a dictionary that allows values to be set using the dot notation. To facilitate using chart examples written in JavaScript, the chart options in JustPy can also be a Python string representing a subset of JavaScript objects. This will become clearer when we look at some examples.","title":"Introduction"},{"location":"charts_tutorial/introduction/#highcharts-introduction","text":"Note It is recommended to go through the general tutorial first. JustPy makes it simple to create charts using the Highcharts JavaScript charting library. Info JustPy also supports matplotlib charts There are several JavaScript charting libraries available, but my personal favorite is Highcharts. It is not too difficult to integrate other charting libraries with JustPy, so perhaps more charting libraries will be supported in the future. The Highcharts and JustPy combination is great for creating and sharing interactive charts, even if you don't plan to develop a web application. JustPy allows you to share your visualizations by providing access to the charts through any browser. Highcharts is free for non-commercial use and this includes individuals using the software for personal use, testing and demonstration. A Highcharts chart in JustPy is a component. It is represented by a Python class, just like any other component. Because Highcharts is a JavaScript library it uses a JavaScript object to define the options or settings of a chart. In JustPy however, charts are defined using a dictionary that allows values to be set using the dot notation. To facilitate using chart examples written in JavaScript, the chart options in JustPy can also be a Python string representing a subset of JavaScript objects. This will become clearer when we look at some examples.","title":"Highcharts Introduction"},{"location":"charts_tutorial/iris/","text":"Iris Flower Dataset Visualization \u00b6 Introduction \u00b6 The Iris flower dataset is used as a test case in machine learning. The data set consists of 50 samples from each of three species of Iris (Iris setosa, Iris virginica and Iris versicolor). Four features were measured from each sample: the length and the width of the sepals and petals, in centimeters. Based on the combination of these four features, Fisher developed a linear discriminant model to distinguish the species from each other. - Wikipedia The idea for this visualization comes from seaborn which uses the Iris dataset to demonstrate its pairplot and PairGrid features. ## The Visualization Please run the program below: import justpy as jp import pandas as pd iris = pd . read_csv ( 'https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv' ) iris_stats = iris . describe () . round ( 3 ) iris_stats . insert ( loc = 0 , column = 'stats' , value = iris_stats . index ) iris_species = list ( iris [ 'species' ] . unique ()) # Create a dictionary of frames per iris species iris_species_frames = {} for s in iris_species : iris_species_frames [ s ] = iris . loc [ iris [ 'species' ] == s ] async def click_point ( self , msg ): print ( msg ) return await self . select_point ([{ 'id' : chart_id , 'series' : msg . series_index , 'point' : msg . point_index } for chart_id in self . chart_list if self . id != chart_id ], msg . websocket ) async def tooltip_formatter ( self , msg ): # print(msg) tooltip_html = f \"\"\" <div style=\"color: {msg.color} \"><span>&#x25CF;</span> {msg.series_name} </div> <div style=\"color: {msg.color} \"> {self.col2} : {msg.x} </div> <div style=\"color: {msg.color} \"> {self.col1} : {msg.y} </div> \"\"\" await self . draw_crosshair ([{ 'id' : chart_id , 'series' : msg . series_index , 'point' : msg . point_index } for chart_id in self . chart_list ], msg . websocket ) return await self . tooltip_update ( tooltip_html , msg . websocket ) def iris_data (): wp = jp . WebPage ( highcharts_theme = 'gray' , title = 'Iris Dataset' ) jp . Div ( text = 'Iris Dataset' , classes = 'text-3xl m-2 p-2 font-medium tracking-wider text-yellow-300 bg-gray-800 text-center' , a = wp ) d1 = jp . Div ( classes = 'm-2 p-2 border-2' , a = wp ) chart_list = [] for i , col1 in enumerate ( iris . columns [: 4 ]): d2 = jp . Div ( classes = 'flex' , a = d1 ) for j , col2 in enumerate ( iris . columns [: 4 ]): if i != j : # Not on the diagonal chart = jp . HighCharts ( a = d2 , style = 'width: 300px; height: 300px' , classes = 'flex-grow m-1' ) chart_list . append ( chart . id ) chart . chart_list = chart_list chart . on ( 'tooltip' , tooltip_formatter ) chart . tooltip_y = 85 chart . on ( 'point_click' , click_point ) chart . col1 = col1 chart . col2 = col2 o = chart . options o . chart . type = 'scatter' o . chart . zoomType = 'xy' o . title . text = '' o . legend . enabled = False o . credits . enabled = False if i < 3 or j < 3 else True # https://api.highcharts.com/highcharts/credits.enabled o . xAxis . title . text = col2 if i == 3 else '' o . yAxis . title . text = col1 if j == 0 else '' o . xAxis . crosshair = o . yAxis . crosshair = True for k , v in iris_species_frames . items (): s = jp . Dict () s . name = k s . allowPointSelect = True # https://api.highcharts.com/highcharts/series.scatter.allowPointSelect s . marker . states . select . radius = 8 s . data = list ( zip ( v . iloc [:, j ], v . iloc [:, i ])) o . series . append ( s ) else : chart = jp . Histogram ( list ( iris . iloc [:, j ]), a = d2 , style = 'width: 300px; height: 300px' , classes = 'flex-grow m-1' ) o = chart . options o . title . text = '' o . legend . enabled = False o . xAxis [ 0 ] . title . text = col2 if i == 3 else '' o . xAxis [ 1 ] . title . text = '' o . yAxis [ 0 ] . title . text = col1 if j == 0 else '' o . yAxis [ 1 ] . title . text = '' o . credits . enabled = False if i < 3 or j < 3 else True # Add two grids, first with the data and second with statistics describing the data iris . jp . ag_grid ( a = wp , classes = 'm-2 p-2' , style = 'height: 500px; width: 800px' , auto_size = True , theme = 'ag-theme-balham-dark' ) iris_stats . jp . ag_grid ( a = wp , classes = 'm-2 p-2 border' , style = 'height: 500px; width: 950px' , auto_size = True , theme = 'ag-theme-material' ) return wp jp . justpy ( iris_data ) On the page you will see 16 charts. The charts show the pairwise scatter plots between the four features in the dataset (the length and the width of the sepals and petals in centimeters) except for the charts on the diagonal which are histograms of each feature. When you mouse over one of the pairwise charts, you will see a tooltip with information about the point the mouse is over. Also, you will see crosshairs in the other pariwise charts highlighting the same point on those charts. If you click a point, it will also be shown as selected in the other charts. The program uses pandas' capabilities to read CSV files and manipulate the data. This code could be used as a basis for a component that could be reused with different data sets.","title":"Iris Dataset Visualization"},{"location":"charts_tutorial/iris/#iris-flower-dataset-visualization","text":"","title":"Iris Flower Dataset Visualization"},{"location":"charts_tutorial/iris/#introduction","text":"The Iris flower dataset is used as a test case in machine learning. The data set consists of 50 samples from each of three species of Iris (Iris setosa, Iris virginica and Iris versicolor). Four features were measured from each sample: the length and the width of the sepals and petals, in centimeters. Based on the combination of these four features, Fisher developed a linear discriminant model to distinguish the species from each other. - Wikipedia The idea for this visualization comes from seaborn which uses the Iris dataset to demonstrate its pairplot and PairGrid features. ## The Visualization Please run the program below: import justpy as jp import pandas as pd iris = pd . read_csv ( 'https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv' ) iris_stats = iris . describe () . round ( 3 ) iris_stats . insert ( loc = 0 , column = 'stats' , value = iris_stats . index ) iris_species = list ( iris [ 'species' ] . unique ()) # Create a dictionary of frames per iris species iris_species_frames = {} for s in iris_species : iris_species_frames [ s ] = iris . loc [ iris [ 'species' ] == s ] async def click_point ( self , msg ): print ( msg ) return await self . select_point ([{ 'id' : chart_id , 'series' : msg . series_index , 'point' : msg . point_index } for chart_id in self . chart_list if self . id != chart_id ], msg . websocket ) async def tooltip_formatter ( self , msg ): # print(msg) tooltip_html = f \"\"\" <div style=\"color: {msg.color} \"><span>&#x25CF;</span> {msg.series_name} </div> <div style=\"color: {msg.color} \"> {self.col2} : {msg.x} </div> <div style=\"color: {msg.color} \"> {self.col1} : {msg.y} </div> \"\"\" await self . draw_crosshair ([{ 'id' : chart_id , 'series' : msg . series_index , 'point' : msg . point_index } for chart_id in self . chart_list ], msg . websocket ) return await self . tooltip_update ( tooltip_html , msg . websocket ) def iris_data (): wp = jp . WebPage ( highcharts_theme = 'gray' , title = 'Iris Dataset' ) jp . Div ( text = 'Iris Dataset' , classes = 'text-3xl m-2 p-2 font-medium tracking-wider text-yellow-300 bg-gray-800 text-center' , a = wp ) d1 = jp . Div ( classes = 'm-2 p-2 border-2' , a = wp ) chart_list = [] for i , col1 in enumerate ( iris . columns [: 4 ]): d2 = jp . Div ( classes = 'flex' , a = d1 ) for j , col2 in enumerate ( iris . columns [: 4 ]): if i != j : # Not on the diagonal chart = jp . HighCharts ( a = d2 , style = 'width: 300px; height: 300px' , classes = 'flex-grow m-1' ) chart_list . append ( chart . id ) chart . chart_list = chart_list chart . on ( 'tooltip' , tooltip_formatter ) chart . tooltip_y = 85 chart . on ( 'point_click' , click_point ) chart . col1 = col1 chart . col2 = col2 o = chart . options o . chart . type = 'scatter' o . chart . zoomType = 'xy' o . title . text = '' o . legend . enabled = False o . credits . enabled = False if i < 3 or j < 3 else True # https://api.highcharts.com/highcharts/credits.enabled o . xAxis . title . text = col2 if i == 3 else '' o . yAxis . title . text = col1 if j == 0 else '' o . xAxis . crosshair = o . yAxis . crosshair = True for k , v in iris_species_frames . items (): s = jp . Dict () s . name = k s . allowPointSelect = True # https://api.highcharts.com/highcharts/series.scatter.allowPointSelect s . marker . states . select . radius = 8 s . data = list ( zip ( v . iloc [:, j ], v . iloc [:, i ])) o . series . append ( s ) else : chart = jp . Histogram ( list ( iris . iloc [:, j ]), a = d2 , style = 'width: 300px; height: 300px' , classes = 'flex-grow m-1' ) o = chart . options o . title . text = '' o . legend . enabled = False o . xAxis [ 0 ] . title . text = col2 if i == 3 else '' o . xAxis [ 1 ] . title . text = '' o . yAxis [ 0 ] . title . text = col1 if j == 0 else '' o . yAxis [ 1 ] . title . text = '' o . credits . enabled = False if i < 3 or j < 3 else True # Add two grids, first with the data and second with statistics describing the data iris . jp . ag_grid ( a = wp , classes = 'm-2 p-2' , style = 'height: 500px; width: 800px' , auto_size = True , theme = 'ag-theme-balham-dark' ) iris_stats . jp . ag_grid ( a = wp , classes = 'm-2 p-2 border' , style = 'height: 500px; width: 950px' , auto_size = True , theme = 'ag-theme-material' ) return wp jp . justpy ( iris_data ) On the page you will see 16 charts. The charts show the pairwise scatter plots between the four features in the dataset (the length and the width of the sepals and petals in centimeters) except for the charts on the diagonal which are histograms of each feature. When you mouse over one of the pairwise charts, you will see a tooltip with information about the point the mouse is over. Also, you will see crosshairs in the other pariwise charts highlighting the same point on those charts. If you click a point, it will also be shown as selected in the other charts. The program uses pandas' capabilities to read CSV files and manipulate the data. This code could be used as a basis for a component that could be reused with different data sets.","title":"Introduction"},{"location":"charts_tutorial/pandas/","text":"Using Pandas to Create Charts \u00b6 If you work with pandas or plan to do so, using JustPy and Highcharts is an option for visualization or building interactive charts and dashboards. Using the Pandas Extension \u00b6 JustPy comes with a pandas extension called jp that makes it simple to create charts from pandas frames . The program below loads a csv file into a pandas frame and then creates a chart based on the data in the frame. Note The examples in this section were inspired by this blog post. Many thanks to Randal Olson for creating and hosting the data set. Warning To run the program below you will need to have pandas installed. import justpy as jp import pandas as pd wm = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) # Create list of majors which start under 20% women students wm_under_20 = list ( wm . loc [ 0 , wm . loc [ 0 ] < 20 ] . index ) def women_majors (): wp = jp . WebPage () wm . jp . plot ( 0 , wm_under_20 , kind = 'spline' , a = wp , title = 'The gender gap is transitory - even for extreme cases' , subtitle = 'Percentage of Bachelors conferred to women form 1970 to 2011 in the US for extreme cases where the percentage was less than 20 % i n 1970' , classes = 'm-2 p-2 w-3/4' ) return wp jp . justpy ( women_majors ) The JustPy pandas extension jp includes the function plot that creates and returns a chart instance. It has two positional arguments: The frame column to use as the x value, can either be the index of the column or its name A list of the columns to plot as y values. Items on the list can either be column indexes or names The plot function also accepts several keyword arguments: - kind : String describing the type of the chart, default is \"column\" - title : The title of the chart, default is the empty string - subtitle : The subtitle of the chart, default is the empty string - categories : Boolean indicating whether to treat x values as categories or numbers, default is True - stacking : One of \"\", \"normal\", \"percent\". The default is \"\" (the empty string) meaning no stacking of series - All the other keyword arguments HighCharts accepts Customizing the Chart \u00b6 Sometimes you will need to customise the result you get from plot . As it returns a HighCharts instance this is simple to do. The program below puts two charts on the page. The first is the result of running plot without any customization and the second is the customized chart. import justpy as jp import pandas as pd wm = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) wm_under_20 = list ( wm . loc [ 0 , wm . loc [ 0 ] < 20 ] . index ) # Create list of majors which start under 20% def women_majors (): wp = jp . WebPage () # First chart wm . jp . plot ( 0 , wm_under_20 , kind = 'spline' , a = wp , title = 'The gender gap is transitory - even for extreme cases' , subtitle = 'Percentage of Bachelors conferred to women form 1970 to 2011 in the US for extreme cases where the percentage was less than 20 % i n 1970' , classes = 'm-2 p-2 w-3/4' ) # Second Chart wm_chart = wm . jp . plot ( 0 , wm_under_20 , kind = 'spline' , a = wp , categories = False , title = 'The gender gap is transitory - even for extreme cases' , subtitle = 'Percentage of Bachelors conferred to women form 1970 to 2011 in the US for extreme cases where the percentage was less than 20 % i n 1970' , classes = 'm-2 p-2 w-3/4 border' , style = 'height: 700px' ) o = wm_chart . options o . title . align = 'left' o . title . style . fontSize = '24px' o . subtitle . align = 'left' o . subtitle . style . fontSize = '20px' o . xAxis . title . text = 'Year' o . xAxis . gridLineWidth = 1 o . yAxis . title . text = '% Women in Major' o . yAxis . labels . format = ' {value} %' o . legend . layout = 'proximate' o . legend . align = 'right' o . plotOptions . series . marker . enabled = False return wp jp . justpy ( women_majors ) Since plot returns a HighChart instance, we just modify its options to customize it. We also set categories to False in the second chart so that not all the years are displayed on the x axis. Modifying a Series \u00b6 By default, all series on the chart created by plot are of the same kind. We can modify this after the chart is created. For example add the following line at the end of women_majors (just before return wp ) amd re-run: o . series [ 3 ] . type = 'column' Using Pandas without the Extension \u00b6 For completeness, below is how you would get the same result without using the extension. This method provides more control but requires more code. import justpy as jp import pandas as pd import itertools wm = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) wm_under_20 = list ( wm . loc [ 0 , wm . loc [ 0 ] < 20 ] . index ) # Create list of majors which start under 20% def make_pairs_list ( x_data , y_data ): return list ( map ( list , itertools . zip_longest ( x_data , y_data ))) def women_majors (): wp = jp . WebPage ( highcharts_theme = 'grid' ) wm_chart = jp . HighCharts ( a = wp , classes = 'm-2 p-2 w-3/4' ) o = wm_chart . options # Will save us some typing and make code cleaner o . title . text = 'The gender gap is transitory - even for extreme cases' o . title . align = 'left' o . xAxis . title . text = 'Year' o . xAxis . gridLineWidth = 1 o . yAxis . title . text = '% Women in Major' o . yAxis . labels . format = ' {value} %' o . legend . layout = 'proximate' o . legend . align = 'right' o . series = [] x_data = wm . iloc [:, 0 ] . tolist () for major in wm_under_20 : s = jp . Dict () y_data = wm [ major ] . tolist () s . data = make_pairs_list ( x_data , y_data ) s . name = major s . type = 'spline' o . series . append ( s ) s . marker . enabled = False return wp jp . justpy ( women_majors ) The form of a series' data in JustPy mirrors that of the series in Highcharts , with JavaScript arrays corresponding to Python lists and JavaScript objects corresponding to Python dictionaries. In our specific case, the data of each series is a list of lists of pairs, each pair representing the x and y of each point respectively. It is simple to create such lists in Python using the zip and list functions. In this example, we used the itertools library function zip_longest to make sure missing values are handled correctly. Since the zip family of functions returns tuples, we need to convert them to lists (this is not strictly true since the standard library json.dumps function converts python tuples to JavaScript arrays). All this is done in the function make_pairs_list above. Info JustPy comes with several Highcharts themes. The theme of all charts on a page must be the same and therefore highcharts_theme is a WebPage attribute. In this example we set the theme to 'grid'.","title":"Using Pandas to Create Charts"},{"location":"charts_tutorial/pandas/#using-pandas-to-create-charts","text":"If you work with pandas or plan to do so, using JustPy and Highcharts is an option for visualization or building interactive charts and dashboards.","title":"Using Pandas to Create Charts"},{"location":"charts_tutorial/pandas/#using-the-pandas-extension","text":"JustPy comes with a pandas extension called jp that makes it simple to create charts from pandas frames . The program below loads a csv file into a pandas frame and then creates a chart based on the data in the frame. Note The examples in this section were inspired by this blog post. Many thanks to Randal Olson for creating and hosting the data set. Warning To run the program below you will need to have pandas installed. import justpy as jp import pandas as pd wm = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) # Create list of majors which start under 20% women students wm_under_20 = list ( wm . loc [ 0 , wm . loc [ 0 ] < 20 ] . index ) def women_majors (): wp = jp . WebPage () wm . jp . plot ( 0 , wm_under_20 , kind = 'spline' , a = wp , title = 'The gender gap is transitory - even for extreme cases' , subtitle = 'Percentage of Bachelors conferred to women form 1970 to 2011 in the US for extreme cases where the percentage was less than 20 % i n 1970' , classes = 'm-2 p-2 w-3/4' ) return wp jp . justpy ( women_majors ) The JustPy pandas extension jp includes the function plot that creates and returns a chart instance. It has two positional arguments: The frame column to use as the x value, can either be the index of the column or its name A list of the columns to plot as y values. Items on the list can either be column indexes or names The plot function also accepts several keyword arguments: - kind : String describing the type of the chart, default is \"column\" - title : The title of the chart, default is the empty string - subtitle : The subtitle of the chart, default is the empty string - categories : Boolean indicating whether to treat x values as categories or numbers, default is True - stacking : One of \"\", \"normal\", \"percent\". The default is \"\" (the empty string) meaning no stacking of series - All the other keyword arguments HighCharts accepts","title":"Using the Pandas Extension"},{"location":"charts_tutorial/pandas/#customizing-the-chart","text":"Sometimes you will need to customise the result you get from plot . As it returns a HighCharts instance this is simple to do. The program below puts two charts on the page. The first is the result of running plot without any customization and the second is the customized chart. import justpy as jp import pandas as pd wm = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) wm_under_20 = list ( wm . loc [ 0 , wm . loc [ 0 ] < 20 ] . index ) # Create list of majors which start under 20% def women_majors (): wp = jp . WebPage () # First chart wm . jp . plot ( 0 , wm_under_20 , kind = 'spline' , a = wp , title = 'The gender gap is transitory - even for extreme cases' , subtitle = 'Percentage of Bachelors conferred to women form 1970 to 2011 in the US for extreme cases where the percentage was less than 20 % i n 1970' , classes = 'm-2 p-2 w-3/4' ) # Second Chart wm_chart = wm . jp . plot ( 0 , wm_under_20 , kind = 'spline' , a = wp , categories = False , title = 'The gender gap is transitory - even for extreme cases' , subtitle = 'Percentage of Bachelors conferred to women form 1970 to 2011 in the US for extreme cases where the percentage was less than 20 % i n 1970' , classes = 'm-2 p-2 w-3/4 border' , style = 'height: 700px' ) o = wm_chart . options o . title . align = 'left' o . title . style . fontSize = '24px' o . subtitle . align = 'left' o . subtitle . style . fontSize = '20px' o . xAxis . title . text = 'Year' o . xAxis . gridLineWidth = 1 o . yAxis . title . text = '% Women in Major' o . yAxis . labels . format = ' {value} %' o . legend . layout = 'proximate' o . legend . align = 'right' o . plotOptions . series . marker . enabled = False return wp jp . justpy ( women_majors ) Since plot returns a HighChart instance, we just modify its options to customize it. We also set categories to False in the second chart so that not all the years are displayed on the x axis.","title":"Customizing the Chart"},{"location":"charts_tutorial/pandas/#modifying-a-series","text":"By default, all series on the chart created by plot are of the same kind. We can modify this after the chart is created. For example add the following line at the end of women_majors (just before return wp ) amd re-run: o . series [ 3 ] . type = 'column'","title":"Modifying a Series"},{"location":"charts_tutorial/pandas/#using-pandas-without-the-extension","text":"For completeness, below is how you would get the same result without using the extension. This method provides more control but requires more code. import justpy as jp import pandas as pd import itertools wm = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) wm_under_20 = list ( wm . loc [ 0 , wm . loc [ 0 ] < 20 ] . index ) # Create list of majors which start under 20% def make_pairs_list ( x_data , y_data ): return list ( map ( list , itertools . zip_longest ( x_data , y_data ))) def women_majors (): wp = jp . WebPage ( highcharts_theme = 'grid' ) wm_chart = jp . HighCharts ( a = wp , classes = 'm-2 p-2 w-3/4' ) o = wm_chart . options # Will save us some typing and make code cleaner o . title . text = 'The gender gap is transitory - even for extreme cases' o . title . align = 'left' o . xAxis . title . text = 'Year' o . xAxis . gridLineWidth = 1 o . yAxis . title . text = '% Women in Major' o . yAxis . labels . format = ' {value} %' o . legend . layout = 'proximate' o . legend . align = 'right' o . series = [] x_data = wm . iloc [:, 0 ] . tolist () for major in wm_under_20 : s = jp . Dict () y_data = wm [ major ] . tolist () s . data = make_pairs_list ( x_data , y_data ) s . name = major s . type = 'spline' o . series . append ( s ) s . marker . enabled = False return wp jp . justpy ( women_majors ) The form of a series' data in JustPy mirrors that of the series in Highcharts , with JavaScript arrays corresponding to Python lists and JavaScript objects corresponding to Python dictionaries. In our specific case, the data of each series is a list of lists of pairs, each pair representing the x and y of each point respectively. It is simple to create such lists in Python using the zip and list functions. In this example, we used the itertools library function zip_longest to make sure missing values are handled correctly. Since the zip family of functions returns tuples, we need to convert them to lists (this is not strictly true since the standard library json.dumps function converts python tuples to JavaScript arrays). All this is done in the function make_pairs_list above. Info JustPy comes with several Highcharts themes. The theme of all charts on a page must be the same and therefore highcharts_theme is a WebPage attribute. In this example we set the theme to 'grid'.","title":"Using Pandas without the Extension"},{"location":"charts_tutorial/stock_charts/","text":"Stock Charts \u00b6 In addition to Highcharts, Highsoft offers a great stock charting product called Highstock . To use Highstock, set the attribute stock of an HighCharts instance to True or use the HighStock class. The program below serves a chart of stock price data. Warning You need to install pandas to run the program import justpy as jp import pandas as pd import datetime epoch = datetime . datetime ( 1970 , 1 , 1 ) def convert_date ( date_string ): date = datetime . datetime . strptime ( date_string , '%Y-%m- %d ' ) return ( date - epoch ) . total_seconds () * 1000 def stock_test ( request ): wp = jp . WebPage () ticker = request . query_params . get ( 'ticker' , 'MSFT' ) if ticker not in [ 'AAPL' , 'IBM' , 'INTC' , 'MSFT' ]: ticker = 'MSFT' data = pd . read_csv ( f 'https://elimintz.github.io/stocks/{ticker.upper()}.csv' ) chart = jp . HighStock ( a = wp , classes = 'm-1 p-2 border w-10/12' ) o = chart . options o . title . text = 'Historical Stock Price' o . legend = { 'enabled' : True , 'align' : 'right' , 'layout' : 'proximate' } o . rangeSelector . selected = 4 # Set default range to 1 year x = list ( data [ 'Date' ] . map ( convert_date )) y = data [ 'Adj Close' ] . to_list () s = jp . Dict ({ 'name' : ticker . upper (), 'data' : jp . make_pairs_list ( x , y )}) o . series = [ s ] s . tooltip . valueDecimals = 2 # Price displayed by tooltip will have 2 decimal values return wp jp . justpy ( stock_test ) I used yahoo finance to download data in CSV format. The first few lines of the file look like this: Date,Open,High,Low,Close,Adj Close,Volume 2005-01-03,4.627143,4.650714,4.471428,4.520714,3.945287,172998000 2005-01-04,4.556428,4.676429,4.497857,4.567143,3.985806,274202600 2005-01-05,4.604286,4.660714,4.575000,4.607143,4.020715,170108400 2005-01-06,4.619286,4.636428,4.523571,4.610714,4.023832,176388800 2005-01-07,4.642857,4.973571,4.625000,4.946429,4.316814,556862600 2005-01-10,4.987857,5.050000,4.848571,4.925714,4.298736,431327400 2005-01-11,4.875000,4.939286,4.581429,4.611429,4.024456,652906800 2005-01-12,4.675000,4.707143,4.521429,4.675714,4.080557,479925600 2005-01-13,5.265000,5.315714,4.980714,4.985714,4.351099,791179200 2005-01-14,5.017857,5.122857,4.942143,5.014286,4.376033,442685600 2005-01-18,4.989286,5.050000,4.839286,5.046429,4.404085,251615000 2005-01-19,5.035000,5.104286,4.982143,4.991428,4.356086,187973800 2005-01-20,4.975000,5.090714,4.962143,5.032857,4.392241,228730600 The program uses pandas to read a CSV file corresponding to the ticker parameter (only the tickers MSFT, AAPL, IBM and INTC have data behind them, the rest default to MSFT). Try http://127.0.0.1:8000/?ticker=intc for example. The program needs to convert the dates to support the Highcharts (standard JavaScript) format which is number of milliseconds since the Epoch (1/1/1970). The short function convert_date does this using the Python datetime library. We use map to apply convert_date to all values in the 'Date' column in order to generate the list of x values for the series. Stock Chart with Volume \u00b6 The CSV file contains additional data, not just the end of day price. We will now create a more sophisticated chart that uses this data. import justpy as jp import pandas as pd import datetime epoch = datetime . datetime ( 1970 , 1 , 1 ) grouping_units = [[ 'week' , [ 1 ]], [ 'month' , [ 1 , 2 , 3 , 4 , 6 ]]] chart_dict = { 'rangeSelector' : { 'selected' : 1 }, 'yAxis' : [ { 'labels' : { 'align' : 'right' , 'x' : - 3 }, 'title' : { 'text' : 'OHLC' }, 'height' : '60%' , 'lineWidth' : 2 , 'resize' : { 'enabled' : True }}, { 'labels' : { 'align' : 'right' , 'x' : - 3 }, 'title' : { 'text' : 'Volume' }, 'top' : '65%' , 'height' : '35%' , 'offset' : 0 , 'lineWidth' : 2 } ], 'tooltip' : { 'split' : True }, 'series' : [ { 'type' : 'candlestick' , 'tooltip' : { 'valueDecimals' : 2 }, 'dataGrouping' : { 'units' : grouping_units }}, { 'type' : 'column' , 'name' : 'Volume' , 'yAxis' : 1 , 'dataGrouping' : { 'units' : grouping_units }} ] } def convert_date ( date_string ): date = datetime . datetime . strptime ( date_string , '%Y-%m- %d ' ) return ( date - epoch ) . total_seconds () * 1000 async def stock_test ( request ): wp = jp . WebPage ( highcharts_theme = 'grid' ) ticker = request . query_params . get ( 'ticker' , 'MSFT' ) . upper () if ticker not in [ 'AAPL' , 'IBM' , 'INTC' , 'MSFT' ]: ticker = 'MSFT' data = await jp . JustPy . loop . run_in_executor ( None , pd . read_csv , f 'https://elimintz.github.io/stocks/ {ticker} .csv' ) chart = jp . HighStock ( a = wp , classes = 'm-1 p-2 border w-10/12' , options = chart_dict , style = 'height: 600px' ) o = chart . options o . title . text = f ' {ticker} Historical Prices' x = list ( data [ 'Date' ] . map ( convert_date )) o . series [ 0 ] . data = list ( zip ( x , data [ 'Open' ], data [ 'High' ], data [ 'Low' ], data [ 'Close' ])) o . series [ 0 ] . name = ticker o . series [ 1 ] . data = list ( zip ( x , data [ 'Volume' ])) return wp jp . justpy ( stock_test ) The chart is defined in this case using a standard Python dictionary. When assigned to the chart options attribute, it is automatically converted to a Dict in order to enable dot notation. In this example, reading the remote CSV file is done in a non-blocking manner (if you are unfamiliar with asyncio , please skip this paragraph). The loop that JustPy runs in can be found in JustPy.loop . It is used to run pd.read_csv in the default thread or process pool. In order to allow awaiting a coroutine, stock_test is also defined as a coroutine using the async keyword. The chart has two series with two different Y axis. The first series is a candlestick series and shows the OHLC (open high low close) data succinctly, and the second series is a simple column series that shows the volume. The data list for each series is created by zipping together the appropriate columns of the pandas frame. We also use the Highcharts theme 'grid' to give the chart a different look.","title":"Stock Charts"},{"location":"charts_tutorial/stock_charts/#stock-charts","text":"In addition to Highcharts, Highsoft offers a great stock charting product called Highstock . To use Highstock, set the attribute stock of an HighCharts instance to True or use the HighStock class. The program below serves a chart of stock price data. Warning You need to install pandas to run the program import justpy as jp import pandas as pd import datetime epoch = datetime . datetime ( 1970 , 1 , 1 ) def convert_date ( date_string ): date = datetime . datetime . strptime ( date_string , '%Y-%m- %d ' ) return ( date - epoch ) . total_seconds () * 1000 def stock_test ( request ): wp = jp . WebPage () ticker = request . query_params . get ( 'ticker' , 'MSFT' ) if ticker not in [ 'AAPL' , 'IBM' , 'INTC' , 'MSFT' ]: ticker = 'MSFT' data = pd . read_csv ( f 'https://elimintz.github.io/stocks/{ticker.upper()}.csv' ) chart = jp . HighStock ( a = wp , classes = 'm-1 p-2 border w-10/12' ) o = chart . options o . title . text = 'Historical Stock Price' o . legend = { 'enabled' : True , 'align' : 'right' , 'layout' : 'proximate' } o . rangeSelector . selected = 4 # Set default range to 1 year x = list ( data [ 'Date' ] . map ( convert_date )) y = data [ 'Adj Close' ] . to_list () s = jp . Dict ({ 'name' : ticker . upper (), 'data' : jp . make_pairs_list ( x , y )}) o . series = [ s ] s . tooltip . valueDecimals = 2 # Price displayed by tooltip will have 2 decimal values return wp jp . justpy ( stock_test ) I used yahoo finance to download data in CSV format. The first few lines of the file look like this: Date,Open,High,Low,Close,Adj Close,Volume 2005-01-03,4.627143,4.650714,4.471428,4.520714,3.945287,172998000 2005-01-04,4.556428,4.676429,4.497857,4.567143,3.985806,274202600 2005-01-05,4.604286,4.660714,4.575000,4.607143,4.020715,170108400 2005-01-06,4.619286,4.636428,4.523571,4.610714,4.023832,176388800 2005-01-07,4.642857,4.973571,4.625000,4.946429,4.316814,556862600 2005-01-10,4.987857,5.050000,4.848571,4.925714,4.298736,431327400 2005-01-11,4.875000,4.939286,4.581429,4.611429,4.024456,652906800 2005-01-12,4.675000,4.707143,4.521429,4.675714,4.080557,479925600 2005-01-13,5.265000,5.315714,4.980714,4.985714,4.351099,791179200 2005-01-14,5.017857,5.122857,4.942143,5.014286,4.376033,442685600 2005-01-18,4.989286,5.050000,4.839286,5.046429,4.404085,251615000 2005-01-19,5.035000,5.104286,4.982143,4.991428,4.356086,187973800 2005-01-20,4.975000,5.090714,4.962143,5.032857,4.392241,228730600 The program uses pandas to read a CSV file corresponding to the ticker parameter (only the tickers MSFT, AAPL, IBM and INTC have data behind them, the rest default to MSFT). Try http://127.0.0.1:8000/?ticker=intc for example. The program needs to convert the dates to support the Highcharts (standard JavaScript) format which is number of milliseconds since the Epoch (1/1/1970). The short function convert_date does this using the Python datetime library. We use map to apply convert_date to all values in the 'Date' column in order to generate the list of x values for the series.","title":"Stock Charts"},{"location":"charts_tutorial/stock_charts/#stock-chart-with-volume","text":"The CSV file contains additional data, not just the end of day price. We will now create a more sophisticated chart that uses this data. import justpy as jp import pandas as pd import datetime epoch = datetime . datetime ( 1970 , 1 , 1 ) grouping_units = [[ 'week' , [ 1 ]], [ 'month' , [ 1 , 2 , 3 , 4 , 6 ]]] chart_dict = { 'rangeSelector' : { 'selected' : 1 }, 'yAxis' : [ { 'labels' : { 'align' : 'right' , 'x' : - 3 }, 'title' : { 'text' : 'OHLC' }, 'height' : '60%' , 'lineWidth' : 2 , 'resize' : { 'enabled' : True }}, { 'labels' : { 'align' : 'right' , 'x' : - 3 }, 'title' : { 'text' : 'Volume' }, 'top' : '65%' , 'height' : '35%' , 'offset' : 0 , 'lineWidth' : 2 } ], 'tooltip' : { 'split' : True }, 'series' : [ { 'type' : 'candlestick' , 'tooltip' : { 'valueDecimals' : 2 }, 'dataGrouping' : { 'units' : grouping_units }}, { 'type' : 'column' , 'name' : 'Volume' , 'yAxis' : 1 , 'dataGrouping' : { 'units' : grouping_units }} ] } def convert_date ( date_string ): date = datetime . datetime . strptime ( date_string , '%Y-%m- %d ' ) return ( date - epoch ) . total_seconds () * 1000 async def stock_test ( request ): wp = jp . WebPage ( highcharts_theme = 'grid' ) ticker = request . query_params . get ( 'ticker' , 'MSFT' ) . upper () if ticker not in [ 'AAPL' , 'IBM' , 'INTC' , 'MSFT' ]: ticker = 'MSFT' data = await jp . JustPy . loop . run_in_executor ( None , pd . read_csv , f 'https://elimintz.github.io/stocks/ {ticker} .csv' ) chart = jp . HighStock ( a = wp , classes = 'm-1 p-2 border w-10/12' , options = chart_dict , style = 'height: 600px' ) o = chart . options o . title . text = f ' {ticker} Historical Prices' x = list ( data [ 'Date' ] . map ( convert_date )) o . series [ 0 ] . data = list ( zip ( x , data [ 'Open' ], data [ 'High' ], data [ 'Low' ], data [ 'Close' ])) o . series [ 0 ] . name = ticker o . series [ 1 ] . data = list ( zip ( x , data [ 'Volume' ])) return wp jp . justpy ( stock_test ) The chart is defined in this case using a standard Python dictionary. When assigned to the chart options attribute, it is automatically converted to a Dict in order to enable dot notation. In this example, reading the remote CSV file is done in a non-blocking manner (if you are unfamiliar with asyncio , please skip this paragraph). The loop that JustPy runs in can be found in JustPy.loop . It is used to run pd.read_csv in the default thread or process pool. In order to allow awaiting a coroutine, stock_test is also defined as a coroutine using the async keyword. The chart has two series with two different Y axis. The first series is a candlestick series and shows the OHLC (open high low close) data succinctly, and the second series is a simple column series that shows the volume. The data list for each series is created by zipping together the appropriate columns of the pandas frame. We also use the Highcharts theme 'grid' to give the chart a different look.","title":"Stock Chart with Volume"},{"location":"charts_tutorial/tooltips/","text":"Tooltips \u00b6 Basic Use \u00b6 The tooltip is the popup that is shown when you hover over a point on the chart. It provides one of the advantages of using interactive charts as it makes the chart more informative. Highcharts allows defining a tooltip using a very versatile formatting function (in JavaScript). JustPy allows writing tooltip formatters for Highcharts charts in Python just like any other event handler. Let's look at a concrete example. import justpy as jp my_chart_def = \"\"\" { chart: { type: 'column' }, title: { text: 'Tourists in Middle Earth' }, xAxis: { categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }, series: [{ name: \"Tourists in '000\", data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4] }] } \"\"\" async def tooltip_formatter ( self , msg ): return await self . tooltip_update ( '<div>My tooltip!</div>' , msg . websocket ) def chart_test (): wp = jp . WebPage () # First chart wp . css = '.h-chart {height: 300px;}' chart1 = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) chart1 . options . subtitle . text = 'Default Tooltip' # Second chart chart2 = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) chart2 . options . subtitle . text = 'Custom Tooltip' chart2 . on ( 'tooltip' , tooltip_formatter ) return wp jp . justpy ( chart_test ) In this example we put two charts on the page. They are identical except for their subtitle and the fact that that the second one has a custom tooltip formatter. The tooltip formatting function (the handler for the tooltip event) is called tooltip_formatter and has one line in it: return await self . tooltip_update ( '<div>My tooltip!</div>' , msg . websocket ) This line returns the result of running the method tooltip_update of the HighCharts component. The method has two arguments (in addition to self). The first is an HTML string which determines the content of the tooltip and the second is the websocket over which this HTML needs to be transmitted. The websocket of the page on which the event occurred can be found in msg.websocket and this is the websocket we use ( msg is the second argument of the event handler). Note Since the method tooltip_update is a coroutine, it needs be awaited and the tooltip event handler needs to be defined with the keyword async. Tooltip Debouncing \u00b6 If you quickly mouseover several points on charts with user defined formatters, you will see the \"Loading\u2026\" inscription instead of the information you expect. Only when no new tooltip event occurs for 100ms (0.1 second), JustPy notifies its backend that a tooltip event has happened. This prevents the server from being inundated with irrelevant tooltip requests as the user moves the mouse over the chart. The debouncing delay can be changed by setting the attribute tooltip_debounce which is by default 100ms. The following command changes the debounce period to 500ms: chart2 . tooltip_debounce = 500 # Assign value of debounce period in ms Using Point Data to Format Tooltip \u00b6 So far, the tooltip we return for all points is the same. That is not very interesting. We would like the tooltip to be much more descriptive. The second argument to the tooltip formatter ( msg in our case) has values specific to tooltip events to assist us with this. In addition to the usual fields it contains the fields: - msg.x - The x coordinate of the point - msg.category - If the x value is not a number, for example 'Jan' or 'Feb', it will show up here - msg.y - The y coordinate of the point - msg.color - The color of the point - msg.series_name - The name of the series the point is in - msg.series_index - The index the series the point is in - msg.point_index - The index the point in its series Let's use some of the fields above to create a more informative tooltip. Please replace tooltip_formatter with this new version and run the program: async def tooltip_formatter ( self , msg ): tooltip_html = f \"\"\" <div style=\"color: {msg.color} ;\"> {msg.series_name} </div> <div> {msg.category} </div> <div>x: {msg.x} , y: {msg.y} </div> \"\"\" return await self . tooltip_update ( tooltip_html , msg . websocket ) We use the Python f-string template like features to create a tooltip that includes information about each point. Notice how msg.color is used to give the series name the color of the point. In charts with multiple series, this becomes very useful. There is another way to create the HTML string used to update the tooltip. Try using the following tooltip_formatter instead of the one above: async def tooltip_formatter ( self , msg ): d1 = jp . Div ( text = msg . series_name , style = f 'color: {msg.color} ;' ) d2 = jp . Div ( text = msg . category ) d3 = jp . Div ( text = f 'x: {msg.x} , y: {msg.y} ' ) tooltip_html = d1 . to_html () + d2 . to_html () + d3 . to_html () return await self . tooltip_update ( tooltip_html , msg . websocket ) This time we create JustPy components and then use the to_html() method to convert them to HTML. Both methods work well and you should use the one you are most comfortable with. Tooltip Positioning \u00b6 You may have noticed in the example above, that the tooltip covers part of the column instead of showing up above it. When we create custom tooltips, we need to help Highcharts position them correctly. We do this using the tooltip_x and tooltip_y attributes of the JustPy HighCharts class. These attributes determine the offset in pixels for the tooltip relative to where Higcharts estimates it needs to show it. In practice, you will need to experiment with different values to get the positioning you want. Here is the same example as above but with the tooltip position changed: import justpy as jp my_chart_def = \"\"\" { chart: { type: 'column' }, title: { text: 'Tourists in Middle Earth' }, xAxis: { categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }, series: [{ name: \"Tourists in '000\", data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4] } ] } \"\"\" async def tooltip_formatter ( self , msg ): tooltip_html = f \"\"\" <div style=\"color: {msg.color} ;\"> {msg.series_name} </div> <div> {msg.category} </div> <div>x: {msg.x} y: {msg.y} </div> \"\"\" return await self . tooltip_update ( tooltip_html , msg . websocket ) def chart_test (): wp = jp . WebPage () # First chart chart1 = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) chart1 . options . subtitle . text = 'Default Tooltip' # Second chart chart2 = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) chart2 . options . subtitle . text = 'Custom Tooltip' chart2 . on ( 'tooltip' , tooltip_formatter ) chart2 . tooltip_y = 80 chart2 . tooltip_x = - 55 return wp jp . justpy ( chart_test ) We added the lines: chart2 . tooltip_y = 80 chart2 . tooltip_x = - 55 to get the desired positioning. Fixed Tooltip \u00b6 A tooltip can be fixed to one position. This is done by setting the chart attribute tooltip_fixed to True . When the tooltip is fixed, tooltip_x and tooltip_y designate the absolute position in the chart to place the tooltip. Here is the example above but this time with a fixed tooltip: import justpy as jp my_chart_def = \"\"\" { chart: { type: 'column' }, title: { text: 'Tourists in Middle Earth' }, xAxis: { categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }, series: [{ name: \"Tourists in '000\", data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4] } ] } \"\"\" async def tooltip_formatter ( self , msg ): tooltip_html = f \"\"\" <div style=\"color: {msg.color} ;\"> {msg.series_name} </div> <div> {msg.category} </div> <div>x: {msg.x} y: {msg.y} </div> \"\"\" return await self . tooltip_update ( tooltip_html , msg . websocket ) def chart_test (): wp = jp . WebPage () # First chart chart1 = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) chart1 . options . subtitle . text = 'Default Tooltip' # Second chart chart2 = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) chart2 . options . subtitle . text = 'Custom Tooltip' chart2 . on ( 'tooltip' , tooltip_formatter ) chart2 . tooltip_fixed = True chart2 . tooltip_y = 100 chart2 . tooltip_x = 100 return wp jp . justpy ( chart_test ) The lines that make the difference are: chart2 . tooltip_fixed = True chart2 . tooltip_y = 100 chart2 . tooltip_x = 100 Shared and Split Tooltips \u00b6 Default Tooltips \u00b6 Highcharts supports shared and split tooltips in addition to the regular tooltip. To see the difference between the three, run the example below which includes the same chart three times, each time with a different kind of tooltip. This is how the Highcharts default tooltip looks like. import justpy as jp # https://www.highcharts.com/demo/line-basic chart_def = \"\"\" { chart: { type: 'spline' }, title: { text: '' }, subtitle: { text: 'JustPy Tooltip Demo' }, yAxis: { title: { text: 'Number of Employees' } }, legend: { layout: 'vertical', align: 'right', verticalAlign: 'middle' }, plotOptions: { series: { pointStart: 2010 } }, series: [{ name: 'Installation', data: [43934, 52503, 57177, 69658, 97031, 119931, 137133, 154175] }, { name: 'Manufacturing', data: [24916, 24064, 29742, 29851, 32490, 30282, 38121, 40434] }, { name: 'Sales & Distribution', data: [11744, 17722, 16005, 19771, 20185, 24377, 32147, 39387] }, { name: 'Project Development', data: [null, null, 7988, 12169, 15112, 22452, 34400, 34227] }, { name: 'Other', data: [12908, 5948, 8105, 11248, 8989, 11816, 18274, 18111] }] } \"\"\" def tool_tip_demo (): wp = jp . WebPage () jp . Div ( text = 'Charts with default Highcharts tooltip' , classes = 'm-2 p-2 text-xl bg-blue-500 text-white' , a = wp ) d = jp . Div ( classes = 'flex flex-wrap ' , a = wp ) my_charts = [] for i in range ( 3 ): my_charts . append ( jp . HighCharts ( a = d , classes = 'm-2 p-2 border' , options = chart_def )) my_charts [ 0 ] . options . tooltip . shared = False my_charts [ 1 ] . options . tooltip . shared = True my_charts [ 2 ] . options . tooltip . split = True my_charts [ 0 ] . options . title . text = 'Simple Tooltip' my_charts [ 1 ] . options . title . text = 'Shared Tooltip' my_charts [ 2 ] . options . title . text = 'Split Tooltip' return wp jp . justpy ( tool_tip_demo ) Custom Tooltips \u00b6 In the example below we add three additional charts with custom tooltips to the page. In total, there are now six charts on the page. The first three use the default Highcharts tooltip and the second three use custom tooltips. The first custom tooltip is of type single, the second is of type shared and the third is a split tooltip. For single and shared tooltip handlers the first argument ofthe tooltip_update is an HTML string. For split tooltip the first argument is a list of HTML strings. The first string is for the x value and the following strings on the list are the HTML strings per series. In the case of shared and split tooltips, the msg argument of the tooltip formatter includes a list of the properties of all the points with the corresponding x value. It is accessed as msg.points . As you will see in the example below, we iterate over this list in the tooltip handlers to generate the required output. import justpy as jp # https://www.highcharts.com/demo/line-basic chart_def = \"\"\" { chart: { type: 'spline' }, title: { text: '' }, subtitle: { text: 'JustPy Tooltip Demo' }, yAxis: { title: { text: 'Number of Employees' } }, legend: { layout: 'vertical', align: 'right', verticalAlign: 'middle' }, plotOptions: { series: { pointStart: 2010 } }, series: [{ name: 'Installation', data: [43934, 52503, 57177, 69658, 97031, 119931, 137133, 154175] }, { name: 'Manufacturing', data: [24916, 24064, 29742, 29851, 32490, 30282, 38121, 40434] }, { name: 'Sales & Distribution', data: [11744, 17722, 16005, 19771, 20185, 24377, 32147, 39387] }, { name: 'Project Development', data: [null, null, 7988, 12169, 15112, 22452, 34400, 34227] }, { name: 'Other', data: [12908, 5948, 8105, 11248, 8989, 11816, 18274, 18111] }] } \"\"\" def tool_tip_demo (): wp = jp . WebPage () jp . Div ( text = 'Charts with default Highcharts tooltip' , classes = 'm-2 p-2 text-xl bg-blue-500 text-white' , a = wp ) d = jp . Div ( classes = 'flex flex-wrap ' , a = wp ) my_charts = [] for i in range ( 3 ): my_charts . append ( jp . HighCharts ( a = d , classes = 'm-2 p-2 border' , options = chart_def )) my_charts [ 0 ] . options . tooltip . shared = False my_charts [ 1 ] . options . tooltip . shared = True my_charts [ 2 ] . options . tooltip . split = True my_charts [ 0 ] . options . title . text = 'Simple Tooltip' my_charts [ 1 ] . options . title . text = 'Shared Tooltip' my_charts [ 2 ] . options . title . text = 'Split Tooltip' jp . Div ( text = 'Charts with user defined tooltip formatter functions' , classes = 'm-2 p-2 text-xl bg-blue-500 text-white' , a = wp ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) my_charts = [] for i in range ( 3 ): my_charts . append ( jp . HighCharts ( a = d , classes = 'm-2 p-2 border' , options = chart_def )) my_charts [ 0 ] . options . tooltip . shared = False my_charts [ 1 ] . options . tooltip . shared = True my_charts [ 2 ] . options . tooltip . split = True my_charts [ 0 ] . options . title . text = 'Simple Tooltip - Formatter Example' my_charts [ 1 ] . options . title . text = 'Shared Tooltip - Formatter Example' my_charts [ 2 ] . options . title . text = 'Split Tooltip - Formatter Example' my_charts [ 0 ] . on ( 'tooltip' , simple_tooltip_formatter ) my_charts [ 1 ] . on ( 'tooltip' , shared_tooltip_formatter ) my_charts [ 2 ] . on ( 'tooltip' , split_tooltip_formatter ) return wp async def simple_tooltip_formatter ( self , msg ): tooltip_html = f \"\"\" <div class=\"text-red-500\"> <div><span style=\"color: {msg.color} \">&#x25CF;&nbsp;</span> {msg.series_name} </div> <div>Year: {msg.x} </div> <div>Number of employees: {\" {:,} \".format(msg.y)}</div> </div> \"\"\" return await self . tooltip_update ( tooltip_html , msg . websocket ) async def shared_tooltip_formatter ( self , msg ): tooltip_div = jp . Div ( classes = \"text-white bg-blue-400\" ) jp . Span ( text = f 'Year: {msg.x} ' , classes = 'text-lg' , a = tooltip_div ) for point in msg . points : point_div = jp . Div ( a = tooltip_div ) jp . Span ( text = f '&#x25CF; {point.series_name} ' , classes = 'bg-white' , style = f 'color: {point.color} ' , a = point_div ) jp . Span ( text = f 'Number of employees: {\" {:,} \".format(point.y)}' , a = point_div ) return await self . tooltip_update ( tooltip_div . to_html (), msg . websocket ) async def split_tooltip_formatter ( self , msg ): tooltip_array = [ f 'The x value is {msg.x} ' ] for point in msg . points : point_div = jp . Div () jp . Span ( text = '&#x25CF;' , classes = 'bg-white' , style = f 'color: {point.color} ' , a = point_div ) jp . Span ( text = f ' {point.series_name} ' , a = point_div ) jp . Span ( text = f 'Year: {point.x} ' , a = point_div ) jp . Span ( text = f 'Number of employees: {\" {:,} \".format(point.y)}' , a = point_div ) tooltip_array . append ( point_div . to_html ()) return await self . tooltip_update ( tooltip_array , msg . websocket ) jp . justpy ( tool_tip_demo ) The split_tooltip_formatter function is a little more complex as can be seen above. A split tooltip means that each series has its own separate popup box and therefore the HTML for each series needs to be returned. The tooltip_update method therefore takes as its first argument a list of strings instead of a string as in the other cases. The first string in the list represents the HTML for the x axis value.","title":"Tooltips"},{"location":"charts_tutorial/tooltips/#tooltips","text":"","title":"Tooltips"},{"location":"charts_tutorial/tooltips/#basic-use","text":"The tooltip is the popup that is shown when you hover over a point on the chart. It provides one of the advantages of using interactive charts as it makes the chart more informative. Highcharts allows defining a tooltip using a very versatile formatting function (in JavaScript). JustPy allows writing tooltip formatters for Highcharts charts in Python just like any other event handler. Let's look at a concrete example. import justpy as jp my_chart_def = \"\"\" { chart: { type: 'column' }, title: { text: 'Tourists in Middle Earth' }, xAxis: { categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }, series: [{ name: \"Tourists in '000\", data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4] }] } \"\"\" async def tooltip_formatter ( self , msg ): return await self . tooltip_update ( '<div>My tooltip!</div>' , msg . websocket ) def chart_test (): wp = jp . WebPage () # First chart wp . css = '.h-chart {height: 300px;}' chart1 = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) chart1 . options . subtitle . text = 'Default Tooltip' # Second chart chart2 = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) chart2 . options . subtitle . text = 'Custom Tooltip' chart2 . on ( 'tooltip' , tooltip_formatter ) return wp jp . justpy ( chart_test ) In this example we put two charts on the page. They are identical except for their subtitle and the fact that that the second one has a custom tooltip formatter. The tooltip formatting function (the handler for the tooltip event) is called tooltip_formatter and has one line in it: return await self . tooltip_update ( '<div>My tooltip!</div>' , msg . websocket ) This line returns the result of running the method tooltip_update of the HighCharts component. The method has two arguments (in addition to self). The first is an HTML string which determines the content of the tooltip and the second is the websocket over which this HTML needs to be transmitted. The websocket of the page on which the event occurred can be found in msg.websocket and this is the websocket we use ( msg is the second argument of the event handler). Note Since the method tooltip_update is a coroutine, it needs be awaited and the tooltip event handler needs to be defined with the keyword async.","title":"Basic Use"},{"location":"charts_tutorial/tooltips/#tooltip-debouncing","text":"If you quickly mouseover several points on charts with user defined formatters, you will see the \"Loading\u2026\" inscription instead of the information you expect. Only when no new tooltip event occurs for 100ms (0.1 second), JustPy notifies its backend that a tooltip event has happened. This prevents the server from being inundated with irrelevant tooltip requests as the user moves the mouse over the chart. The debouncing delay can be changed by setting the attribute tooltip_debounce which is by default 100ms. The following command changes the debounce period to 500ms: chart2 . tooltip_debounce = 500 # Assign value of debounce period in ms","title":"Tooltip Debouncing"},{"location":"charts_tutorial/tooltips/#using-point-data-to-format-tooltip","text":"So far, the tooltip we return for all points is the same. That is not very interesting. We would like the tooltip to be much more descriptive. The second argument to the tooltip formatter ( msg in our case) has values specific to tooltip events to assist us with this. In addition to the usual fields it contains the fields: - msg.x - The x coordinate of the point - msg.category - If the x value is not a number, for example 'Jan' or 'Feb', it will show up here - msg.y - The y coordinate of the point - msg.color - The color of the point - msg.series_name - The name of the series the point is in - msg.series_index - The index the series the point is in - msg.point_index - The index the point in its series Let's use some of the fields above to create a more informative tooltip. Please replace tooltip_formatter with this new version and run the program: async def tooltip_formatter ( self , msg ): tooltip_html = f \"\"\" <div style=\"color: {msg.color} ;\"> {msg.series_name} </div> <div> {msg.category} </div> <div>x: {msg.x} , y: {msg.y} </div> \"\"\" return await self . tooltip_update ( tooltip_html , msg . websocket ) We use the Python f-string template like features to create a tooltip that includes information about each point. Notice how msg.color is used to give the series name the color of the point. In charts with multiple series, this becomes very useful. There is another way to create the HTML string used to update the tooltip. Try using the following tooltip_formatter instead of the one above: async def tooltip_formatter ( self , msg ): d1 = jp . Div ( text = msg . series_name , style = f 'color: {msg.color} ;' ) d2 = jp . Div ( text = msg . category ) d3 = jp . Div ( text = f 'x: {msg.x} , y: {msg.y} ' ) tooltip_html = d1 . to_html () + d2 . to_html () + d3 . to_html () return await self . tooltip_update ( tooltip_html , msg . websocket ) This time we create JustPy components and then use the to_html() method to convert them to HTML. Both methods work well and you should use the one you are most comfortable with.","title":"Using Point Data to Format Tooltip"},{"location":"charts_tutorial/tooltips/#tooltip-positioning","text":"You may have noticed in the example above, that the tooltip covers part of the column instead of showing up above it. When we create custom tooltips, we need to help Highcharts position them correctly. We do this using the tooltip_x and tooltip_y attributes of the JustPy HighCharts class. These attributes determine the offset in pixels for the tooltip relative to where Higcharts estimates it needs to show it. In practice, you will need to experiment with different values to get the positioning you want. Here is the same example as above but with the tooltip position changed: import justpy as jp my_chart_def = \"\"\" { chart: { type: 'column' }, title: { text: 'Tourists in Middle Earth' }, xAxis: { categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }, series: [{ name: \"Tourists in '000\", data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4] } ] } \"\"\" async def tooltip_formatter ( self , msg ): tooltip_html = f \"\"\" <div style=\"color: {msg.color} ;\"> {msg.series_name} </div> <div> {msg.category} </div> <div>x: {msg.x} y: {msg.y} </div> \"\"\" return await self . tooltip_update ( tooltip_html , msg . websocket ) def chart_test (): wp = jp . WebPage () # First chart chart1 = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) chart1 . options . subtitle . text = 'Default Tooltip' # Second chart chart2 = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) chart2 . options . subtitle . text = 'Custom Tooltip' chart2 . on ( 'tooltip' , tooltip_formatter ) chart2 . tooltip_y = 80 chart2 . tooltip_x = - 55 return wp jp . justpy ( chart_test ) We added the lines: chart2 . tooltip_y = 80 chart2 . tooltip_x = - 55 to get the desired positioning.","title":"Tooltip Positioning"},{"location":"charts_tutorial/tooltips/#fixed-tooltip","text":"A tooltip can be fixed to one position. This is done by setting the chart attribute tooltip_fixed to True . When the tooltip is fixed, tooltip_x and tooltip_y designate the absolute position in the chart to place the tooltip. Here is the example above but this time with a fixed tooltip: import justpy as jp my_chart_def = \"\"\" { chart: { type: 'column' }, title: { text: 'Tourists in Middle Earth' }, xAxis: { categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }, series: [{ name: \"Tourists in '000\", data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4] } ] } \"\"\" async def tooltip_formatter ( self , msg ): tooltip_html = f \"\"\" <div style=\"color: {msg.color} ;\"> {msg.series_name} </div> <div> {msg.category} </div> <div>x: {msg.x} y: {msg.y} </div> \"\"\" return await self . tooltip_update ( tooltip_html , msg . websocket ) def chart_test (): wp = jp . WebPage () # First chart chart1 = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) chart1 . options . subtitle . text = 'Default Tooltip' # Second chart chart2 = jp . HighCharts ( a = wp , classes = 'm-2 p-2 border w-1/2' , options = my_chart_def ) chart2 . options . subtitle . text = 'Custom Tooltip' chart2 . on ( 'tooltip' , tooltip_formatter ) chart2 . tooltip_fixed = True chart2 . tooltip_y = 100 chart2 . tooltip_x = 100 return wp jp . justpy ( chart_test ) The lines that make the difference are: chart2 . tooltip_fixed = True chart2 . tooltip_y = 100 chart2 . tooltip_x = 100","title":"Fixed Tooltip"},{"location":"charts_tutorial/tooltips/#shared-and-split-tooltips","text":"","title":"Shared and Split Tooltips"},{"location":"charts_tutorial/tooltips/#default-tooltips","text":"Highcharts supports shared and split tooltips in addition to the regular tooltip. To see the difference between the three, run the example below which includes the same chart three times, each time with a different kind of tooltip. This is how the Highcharts default tooltip looks like. import justpy as jp # https://www.highcharts.com/demo/line-basic chart_def = \"\"\" { chart: { type: 'spline' }, title: { text: '' }, subtitle: { text: 'JustPy Tooltip Demo' }, yAxis: { title: { text: 'Number of Employees' } }, legend: { layout: 'vertical', align: 'right', verticalAlign: 'middle' }, plotOptions: { series: { pointStart: 2010 } }, series: [{ name: 'Installation', data: [43934, 52503, 57177, 69658, 97031, 119931, 137133, 154175] }, { name: 'Manufacturing', data: [24916, 24064, 29742, 29851, 32490, 30282, 38121, 40434] }, { name: 'Sales & Distribution', data: [11744, 17722, 16005, 19771, 20185, 24377, 32147, 39387] }, { name: 'Project Development', data: [null, null, 7988, 12169, 15112, 22452, 34400, 34227] }, { name: 'Other', data: [12908, 5948, 8105, 11248, 8989, 11816, 18274, 18111] }] } \"\"\" def tool_tip_demo (): wp = jp . WebPage () jp . Div ( text = 'Charts with default Highcharts tooltip' , classes = 'm-2 p-2 text-xl bg-blue-500 text-white' , a = wp ) d = jp . Div ( classes = 'flex flex-wrap ' , a = wp ) my_charts = [] for i in range ( 3 ): my_charts . append ( jp . HighCharts ( a = d , classes = 'm-2 p-2 border' , options = chart_def )) my_charts [ 0 ] . options . tooltip . shared = False my_charts [ 1 ] . options . tooltip . shared = True my_charts [ 2 ] . options . tooltip . split = True my_charts [ 0 ] . options . title . text = 'Simple Tooltip' my_charts [ 1 ] . options . title . text = 'Shared Tooltip' my_charts [ 2 ] . options . title . text = 'Split Tooltip' return wp jp . justpy ( tool_tip_demo )","title":"Default Tooltips"},{"location":"charts_tutorial/tooltips/#custom-tooltips","text":"In the example below we add three additional charts with custom tooltips to the page. In total, there are now six charts on the page. The first three use the default Highcharts tooltip and the second three use custom tooltips. The first custom tooltip is of type single, the second is of type shared and the third is a split tooltip. For single and shared tooltip handlers the first argument ofthe tooltip_update is an HTML string. For split tooltip the first argument is a list of HTML strings. The first string is for the x value and the following strings on the list are the HTML strings per series. In the case of shared and split tooltips, the msg argument of the tooltip formatter includes a list of the properties of all the points with the corresponding x value. It is accessed as msg.points . As you will see in the example below, we iterate over this list in the tooltip handlers to generate the required output. import justpy as jp # https://www.highcharts.com/demo/line-basic chart_def = \"\"\" { chart: { type: 'spline' }, title: { text: '' }, subtitle: { text: 'JustPy Tooltip Demo' }, yAxis: { title: { text: 'Number of Employees' } }, legend: { layout: 'vertical', align: 'right', verticalAlign: 'middle' }, plotOptions: { series: { pointStart: 2010 } }, series: [{ name: 'Installation', data: [43934, 52503, 57177, 69658, 97031, 119931, 137133, 154175] }, { name: 'Manufacturing', data: [24916, 24064, 29742, 29851, 32490, 30282, 38121, 40434] }, { name: 'Sales & Distribution', data: [11744, 17722, 16005, 19771, 20185, 24377, 32147, 39387] }, { name: 'Project Development', data: [null, null, 7988, 12169, 15112, 22452, 34400, 34227] }, { name: 'Other', data: [12908, 5948, 8105, 11248, 8989, 11816, 18274, 18111] }] } \"\"\" def tool_tip_demo (): wp = jp . WebPage () jp . Div ( text = 'Charts with default Highcharts tooltip' , classes = 'm-2 p-2 text-xl bg-blue-500 text-white' , a = wp ) d = jp . Div ( classes = 'flex flex-wrap ' , a = wp ) my_charts = [] for i in range ( 3 ): my_charts . append ( jp . HighCharts ( a = d , classes = 'm-2 p-2 border' , options = chart_def )) my_charts [ 0 ] . options . tooltip . shared = False my_charts [ 1 ] . options . tooltip . shared = True my_charts [ 2 ] . options . tooltip . split = True my_charts [ 0 ] . options . title . text = 'Simple Tooltip' my_charts [ 1 ] . options . title . text = 'Shared Tooltip' my_charts [ 2 ] . options . title . text = 'Split Tooltip' jp . Div ( text = 'Charts with user defined tooltip formatter functions' , classes = 'm-2 p-2 text-xl bg-blue-500 text-white' , a = wp ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) my_charts = [] for i in range ( 3 ): my_charts . append ( jp . HighCharts ( a = d , classes = 'm-2 p-2 border' , options = chart_def )) my_charts [ 0 ] . options . tooltip . shared = False my_charts [ 1 ] . options . tooltip . shared = True my_charts [ 2 ] . options . tooltip . split = True my_charts [ 0 ] . options . title . text = 'Simple Tooltip - Formatter Example' my_charts [ 1 ] . options . title . text = 'Shared Tooltip - Formatter Example' my_charts [ 2 ] . options . title . text = 'Split Tooltip - Formatter Example' my_charts [ 0 ] . on ( 'tooltip' , simple_tooltip_formatter ) my_charts [ 1 ] . on ( 'tooltip' , shared_tooltip_formatter ) my_charts [ 2 ] . on ( 'tooltip' , split_tooltip_formatter ) return wp async def simple_tooltip_formatter ( self , msg ): tooltip_html = f \"\"\" <div class=\"text-red-500\"> <div><span style=\"color: {msg.color} \">&#x25CF;&nbsp;</span> {msg.series_name} </div> <div>Year: {msg.x} </div> <div>Number of employees: {\" {:,} \".format(msg.y)}</div> </div> \"\"\" return await self . tooltip_update ( tooltip_html , msg . websocket ) async def shared_tooltip_formatter ( self , msg ): tooltip_div = jp . Div ( classes = \"text-white bg-blue-400\" ) jp . Span ( text = f 'Year: {msg.x} ' , classes = 'text-lg' , a = tooltip_div ) for point in msg . points : point_div = jp . Div ( a = tooltip_div ) jp . Span ( text = f '&#x25CF; {point.series_name} ' , classes = 'bg-white' , style = f 'color: {point.color} ' , a = point_div ) jp . Span ( text = f 'Number of employees: {\" {:,} \".format(point.y)}' , a = point_div ) return await self . tooltip_update ( tooltip_div . to_html (), msg . websocket ) async def split_tooltip_formatter ( self , msg ): tooltip_array = [ f 'The x value is {msg.x} ' ] for point in msg . points : point_div = jp . Div () jp . Span ( text = '&#x25CF;' , classes = 'bg-white' , style = f 'color: {point.color} ' , a = point_div ) jp . Span ( text = f ' {point.series_name} ' , a = point_div ) jp . Span ( text = f 'Year: {point.x} ' , a = point_div ) jp . Span ( text = f 'Number of employees: {\" {:,} \".format(point.y)}' , a = point_div ) tooltip_array . append ( point_div . to_html ()) return await self . tooltip_update ( tooltip_array , msg . websocket ) jp . justpy ( tool_tip_demo ) The split_tooltip_formatter function is a little more complex as can be seen above. A split tooltip means that each series has its own separate popup box and therefore the HTML for each series needs to be returned. The tooltip_update method therefore takes as its first argument a list of strings instead of a string as in the other cases. The first string in the list represents the HTML for the x axis value.","title":"Custom Tooltips"},{"location":"charts_tutorial/updating_charts/","text":"Updating Charts \u00b6 In some applications, we would like charts to update as the underlying data changes. The following program updates the two series on a chart every second and then updates all the browser tabs the page is open in. The program is similar to the clock example in the general tutorial. import justpy as jp import asyncio from random import randrange chart_dict = { 'title' : { 'text' : 'Updating Chart' }, 'series' : [ { 'name' : 'Random Column' , 'type' : 'column' , 'animation' : False , 'data' : [ randrange ( 100 ) for i in range ( 50 )]}, { 'name' : 'Random Scatter' , 'type' : 'scatter' , 'animation' : False , 'data' : [ randrange ( 100 ) for i in range ( 50 )]} ], } wp = jp . WebPage ( delete_flag = False ) chart = jp . HighCharts ( a = wp , options = chart_dict , classes = 'm-1 p-2 border w-10/12' ) async def chart_updater (): while True : await asyncio . sleep ( 1 ) for i in range ( 0 , 2 ): chart . options . series [ i ] . data . pop ( 0 ) chart . options . series [ i ] . data . append ( randrange ( 100 )) jp . run_task ( wp . update ()) async def chart_init (): jp . run_task ( chart_updater ()) async def chart_test (): return wp jp . justpy ( chart_test , startup = chart_init ) We use chart_dict to define the chart including two series of 50 random integers. One series is of type scatter and the other is of type column. The same global WebPage instance is returned following all requests and therefore we set delete_flag to False . The function chart_updater removes the first value in the two series and adds a random value at their end. Then, the page is updated and the procedure repeats itself after a 1 second non-blocking delay. Notice that in the definition of the series in chart_dict we set the animation to False . Experiment by setting this to True to see the difference.","title":"Updating Charts"},{"location":"charts_tutorial/updating_charts/#updating-charts","text":"In some applications, we would like charts to update as the underlying data changes. The following program updates the two series on a chart every second and then updates all the browser tabs the page is open in. The program is similar to the clock example in the general tutorial. import justpy as jp import asyncio from random import randrange chart_dict = { 'title' : { 'text' : 'Updating Chart' }, 'series' : [ { 'name' : 'Random Column' , 'type' : 'column' , 'animation' : False , 'data' : [ randrange ( 100 ) for i in range ( 50 )]}, { 'name' : 'Random Scatter' , 'type' : 'scatter' , 'animation' : False , 'data' : [ randrange ( 100 ) for i in range ( 50 )]} ], } wp = jp . WebPage ( delete_flag = False ) chart = jp . HighCharts ( a = wp , options = chart_dict , classes = 'm-1 p-2 border w-10/12' ) async def chart_updater (): while True : await asyncio . sleep ( 1 ) for i in range ( 0 , 2 ): chart . options . series [ i ] . data . pop ( 0 ) chart . options . series [ i ] . data . append ( randrange ( 100 )) jp . run_task ( wp . update ()) async def chart_init (): jp . run_task ( chart_updater ()) async def chart_test (): return wp jp . justpy ( chart_test , startup = chart_init ) We use chart_dict to define the chart including two series of 50 random integers. One series is of type scatter and the other is of type column. The same global WebPage instance is returned following all requests and therefore we set delete_flag to False . The function chart_updater removes the first value in the two series and adds a random value at their end. Then, the page is updated and the procedure repeats itself after a 1 second non-blocking delay. Notice that in the definition of the series in chart_dict we set the animation to False . Experiment by setting this to True to see the difference.","title":"Updating Charts"},{"location":"grids_tutorial/adding_html/","text":"Adding HTML to Cells \u00b6 If you want to add an image or specific formatting to a cell in the grid, you can do so by using the html_columns attribute. Assign to this attribute a list of the column numbers that should be formatted using HTML. In the example below, special formatting and an image are added to the price column. import justpy as jp grid_options = { 'rowHeight' : 200 , 'columnDefs' : [ { 'headerName' : \"Make\" , 'field' : \"make\" }, { 'headerName' : \"Model\" , 'field' : \"model\" }, { 'headerName' : \"Price\" , 'field' : \"price\" }, ], 'rowData' : [ { 'make' : \"Toyota\" , 'model' : \"Celica\" , 'price' : 4 }, { 'make' : \"Ford\" , 'model' : \"Mondeo\" , 'price' : '<div class=\"m-2 text-red-500 text-5xl\">3</div>' }, { 'make' : \"Porsche\" , 'model' : \"Boxter\" , 'price' : '<img src=\"https://www.python.org/static/community_logos/python-powered-h-140x182.png\">' } ], } def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options ) grid . html_columns = [ 2 ] return wp jp . justpy ( grid_test )","title":"Adding HTML to Cells"},{"location":"grids_tutorial/adding_html/#adding-html-to-cells","text":"If you want to add an image or specific formatting to a cell in the grid, you can do so by using the html_columns attribute. Assign to this attribute a list of the column numbers that should be formatted using HTML. In the example below, special formatting and an image are added to the price column. import justpy as jp grid_options = { 'rowHeight' : 200 , 'columnDefs' : [ { 'headerName' : \"Make\" , 'field' : \"make\" }, { 'headerName' : \"Model\" , 'field' : \"model\" }, { 'headerName' : \"Price\" , 'field' : \"price\" }, ], 'rowData' : [ { 'make' : \"Toyota\" , 'model' : \"Celica\" , 'price' : 4 }, { 'make' : \"Ford\" , 'model' : \"Mondeo\" , 'price' : '<div class=\"m-2 text-red-500 text-5xl\">3</div>' }, { 'make' : \"Porsche\" , 'model' : \"Boxter\" , 'price' : '<img src=\"https://www.python.org/static/community_logos/python-powered-h-140x182.png\">' } ], } def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options ) grid . html_columns = [ 2 ] return wp jp . justpy ( grid_test )","title":"Adding HTML to Cells"},{"location":"grids_tutorial/checkbox/","text":"Rendering Checkboxes \u00b6 To render a column as a checkbox set the cellRenderer value of the column in `columnDefs' to 'checkboxRenderer'. The value of a checkbox is either True or False . In the example below, the 'Enabled' column is rendered as a checkbox. import justpy as jp grid_options = \"\"\" { defaultColDef: { filter: true, sortable: true, resizable: true, cellStyle: {textAlign: 'center'}, headerClass: 'font-bold' }, columnDefs: [ {headerName: \"Make\", field: \"make\"}, {headerName: \"Model\", field: \"model\"}, {headerName: \"Price\", field: \"price\"}, {headerName: \"Enabled\", field: \"enabled\", cellRenderer: 'checkboxRenderer'} ], rowData: [ {make: \"Toyota\", model: \"Celica\", price: 35000, enabled: false}, {make: \"Ford\", model: \"Mondeo\", price: 32000, enabled: true}, {make: \"Porsche\", model: \"Boxter\", price: 72000, enabled: false} ] } \"\"\" def grid_change ( self , msg ): print ( msg ) def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options ) grid . on ( 'cellValueChanged' , grid_change ) return wp jp . justpy ( grid_test )","title":"Rendering Checkboxes"},{"location":"grids_tutorial/checkbox/#rendering-checkboxes","text":"To render a column as a checkbox set the cellRenderer value of the column in `columnDefs' to 'checkboxRenderer'. The value of a checkbox is either True or False . In the example below, the 'Enabled' column is rendered as a checkbox. import justpy as jp grid_options = \"\"\" { defaultColDef: { filter: true, sortable: true, resizable: true, cellStyle: {textAlign: 'center'}, headerClass: 'font-bold' }, columnDefs: [ {headerName: \"Make\", field: \"make\"}, {headerName: \"Model\", field: \"model\"}, {headerName: \"Price\", field: \"price\"}, {headerName: \"Enabled\", field: \"enabled\", cellRenderer: 'checkboxRenderer'} ], rowData: [ {make: \"Toyota\", model: \"Celica\", price: 35000, enabled: false}, {make: \"Ford\", model: \"Mondeo\", price: 32000, enabled: true}, {make: \"Porsche\", model: \"Boxter\", price: 72000, enabled: false} ] } \"\"\" def grid_change ( self , msg ): print ( msg ) def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options ) grid . on ( 'cellValueChanged' , grid_change ) return wp jp . justpy ( grid_test )","title":"Rendering Checkboxes"},{"location":"grids_tutorial/context_menu/","text":"Adding a Context Menu \u00b6 The example below shows how to add a custom context menu to a grid. Warning This only works with the ag-grid enterprise version import justpy as jp grid_options = { 'columnDefs' : [ { 'headerName' : \"Make\" , 'field' : \"make\" }, { 'headerName' : \"Model\" , 'field' : \"model\" }, { 'headerName' : \"Price\" , 'field' : \"price\" } ], 'rowData' : [ { 'row_id' : 0 , 'make' : \"Toyota\" , 'model' : \"Celica\" , 'price' : 35000 }, { 'row_id' : 1 , 'make' : \"Ford\" , 'model' : \"Mondeo\" , 'price' : 32000 }, { 'row_id' : 2 , 'make' : \"Porsche\" , 'model' : \"Boxter\" , 'price' : 72000 } ], 'getRowNodeId' : '''function (data) { return data.row_id; }''' , 'getContextMenuItems' : '''function getContextMenuItems(params) { if (!websocket_ready && use_websockets) return; var e = {page_id: page_id, websocket_id: websocket_id, event_type: 'result_ready'}; var result = [ { // menu item 1 name: 'New Row', subMenu: [ { name: 'Chevy', action: function () { e.result = {menu_action: \"new\", make: \"Chevy\"}; send_to_server(e, 'page_event', false); } }, { name: 'Honda', action: function () { e.result = {menu_action: \"new\", make: \"Honda\"}; send_to_server(e, 'page_event', false); } }, ] }, { // menu item 2 name: 'Copy Row', action: function () { if (params.node) { e.result = {menu_action: \"copy\", row_data: params.node.data}; send_to_server(e, 'page_event', false); } }, }, { // menu item 3 name: 'Delete Row', action: function () { if (params.node) { e.result = {menu_action: \"delete\", row_data: params.node.data}; send_to_server(e, 'page_event', false); } }, }, ]; return result; }''' } async def result_ready ( self , msg ): wp = msg . page if msg . result [ 'menu_action' ] == 'new' : row_data = { 'row_id' : wp . next_row_id } row_data [ 'make' ] = msg . result [ 'make' ] row_data [ 'model' ] = f 'test {wp.next_row_id} ' row_data [ 'price' ] = wp . next_row_id * 98765 wp . next_row_id += 1 await wp . run_javascript ( f \"\"\"cached_grid_def['g' + {wp.grid.id} ].api.applyTransaction({{ add: [ {row_data} ] }})\"\"\" ) elif msg . result [ 'menu_action' ] == 'copy' : row_data = msg . result [ 'row_data' ] row_data [ 'row_id' ] = wp . next_row_id wp . next_row_id += 1 await wp . run_javascript ( f \"\"\"cached_grid_def['g' + {wp.grid.id} ].api.applyTransaction({{ add: [ {row_data} ] }})\"\"\" ) elif msg . result [ 'menu_action' ] == 'delete' : row_data = msg . result [ 'row_data' ] await wp . run_javascript ( f \"\"\"cached_grid_def['g' + {wp.grid.id} ].api.applyTransaction({{ remove: [ {row_data} ] }})\"\"\" ) def grid_test (): wp = jp . WebPage () wp . on ( 'result_ready' , result_ready ) wp . grid = jp . AgGrid ( a = wp , options = grid_options ) wp . next_row_id = len ( grid_options [ 'rowData' ]) wp . grid . evaluate = [ 'getContextMenuItems' , 'getRowNodeId' ] return wp jp . justpy ( grid_test )","title":"Adding a Context Menu"},{"location":"grids_tutorial/context_menu/#adding-a-context-menu","text":"The example below shows how to add a custom context menu to a grid. Warning This only works with the ag-grid enterprise version import justpy as jp grid_options = { 'columnDefs' : [ { 'headerName' : \"Make\" , 'field' : \"make\" }, { 'headerName' : \"Model\" , 'field' : \"model\" }, { 'headerName' : \"Price\" , 'field' : \"price\" } ], 'rowData' : [ { 'row_id' : 0 , 'make' : \"Toyota\" , 'model' : \"Celica\" , 'price' : 35000 }, { 'row_id' : 1 , 'make' : \"Ford\" , 'model' : \"Mondeo\" , 'price' : 32000 }, { 'row_id' : 2 , 'make' : \"Porsche\" , 'model' : \"Boxter\" , 'price' : 72000 } ], 'getRowNodeId' : '''function (data) { return data.row_id; }''' , 'getContextMenuItems' : '''function getContextMenuItems(params) { if (!websocket_ready && use_websockets) return; var e = {page_id: page_id, websocket_id: websocket_id, event_type: 'result_ready'}; var result = [ { // menu item 1 name: 'New Row', subMenu: [ { name: 'Chevy', action: function () { e.result = {menu_action: \"new\", make: \"Chevy\"}; send_to_server(e, 'page_event', false); } }, { name: 'Honda', action: function () { e.result = {menu_action: \"new\", make: \"Honda\"}; send_to_server(e, 'page_event', false); } }, ] }, { // menu item 2 name: 'Copy Row', action: function () { if (params.node) { e.result = {menu_action: \"copy\", row_data: params.node.data}; send_to_server(e, 'page_event', false); } }, }, { // menu item 3 name: 'Delete Row', action: function () { if (params.node) { e.result = {menu_action: \"delete\", row_data: params.node.data}; send_to_server(e, 'page_event', false); } }, }, ]; return result; }''' } async def result_ready ( self , msg ): wp = msg . page if msg . result [ 'menu_action' ] == 'new' : row_data = { 'row_id' : wp . next_row_id } row_data [ 'make' ] = msg . result [ 'make' ] row_data [ 'model' ] = f 'test {wp.next_row_id} ' row_data [ 'price' ] = wp . next_row_id * 98765 wp . next_row_id += 1 await wp . run_javascript ( f \"\"\"cached_grid_def['g' + {wp.grid.id} ].api.applyTransaction({{ add: [ {row_data} ] }})\"\"\" ) elif msg . result [ 'menu_action' ] == 'copy' : row_data = msg . result [ 'row_data' ] row_data [ 'row_id' ] = wp . next_row_id wp . next_row_id += 1 await wp . run_javascript ( f \"\"\"cached_grid_def['g' + {wp.grid.id} ].api.applyTransaction({{ add: [ {row_data} ] }})\"\"\" ) elif msg . result [ 'menu_action' ] == 'delete' : row_data = msg . result [ 'row_data' ] await wp . run_javascript ( f \"\"\"cached_grid_def['g' + {wp.grid.id} ].api.applyTransaction({{ remove: [ {row_data} ] }})\"\"\" ) def grid_test (): wp = jp . WebPage () wp . on ( 'result_ready' , result_ready ) wp . grid = jp . AgGrid ( a = wp , options = grid_options ) wp . next_row_id = len ( grid_options [ 'rowData' ]) wp . grid . evaluate = [ 'getContextMenuItems' , 'getRowNodeId' ] return wp jp . justpy ( grid_test )","title":"Adding a Context Menu"},{"location":"grids_tutorial/creating_grids/","text":"Creating Grids \u00b6 Here is a simple example of a adding a grid to the page. import justpy as jp grid_options = \"\"\" { defaultColDef: { filter: true, sortable: true, resizable: true, cellStyle: {textAlign: 'center'}, headerClass: 'font-bold' }, columnDefs: [ {headerName: \"Make\", field: \"make\"}, {headerName: \"Model\", field: \"model\"}, {headerName: \"Price\", field: \"price\"} ], rowData: [ {make: \"Toyota\", model: \"Celica\", price: 35000}, {make: \"Ford\", model: \"Mondeo\", price: 32000}, {make: \"Porsche\", model: \"Boxter\", price: 72000} ] } \"\"\" def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options ) return wp jp . justpy ( grid_test ) In this case the grid options are defined using a string that represents a JavaScript object. It could also be a Python dictionary. The options object is described in the ag_Grid documentation . Note We will see later, that when working with pandas, JustPy can automate the process and there is no need to go into the grid specification details. As mentioned above, AgGrid provides a default style to the grid when it is created. Let\u2019s change that style. Replace the function grid_test in the example above with the following: def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options , style = 'height: 200px; width: 300px; margin: 0.25em' ) return wp When you run the program, the rendered grid is smaller. After the grid is created, you can modify its options further. Let's add a data row after the grid is created: def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options , style = 'height: 200px; width: 300px; margin: 0.25em' ) grid . options . rowData . append ({ 'make' : 'Autocars' , 'model' : 'Sussita' , 'price' : 3 }) return wp Let's make all columns editable and add a checkbox in the second column. def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options , style = 'height: 200px; width: 300px; margin: 0.25em' ) for col_def in grid . options . columnDefs : col_def . editable = True grid . options . columnDefs [ 1 ] . checkboxSelection = True return wp You can now edit any cell in the grid. After selecting a cell, just start typing. The appearance of data in a column can be modified by assigning a list of classes to the cellClass attribute of a column definition. In the example below the appearance of the Model column is modified. def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options , style = 'height: 200px; width: 300px; margin: 0.25em' ) for col_def in grid . options . columnDefs : col_def . editable = True grid . options . columnDefs [ 1 ] . cellClass = [ 'text-2xl' , 'text-red-500' , 'hover:bg-blue-500' ] return wp Ag_Grid is very rich in features, very few which are covered here. For a detailed description of the grid features, please look at its documentation .","title":"Creating Grids"},{"location":"grids_tutorial/creating_grids/#creating-grids","text":"Here is a simple example of a adding a grid to the page. import justpy as jp grid_options = \"\"\" { defaultColDef: { filter: true, sortable: true, resizable: true, cellStyle: {textAlign: 'center'}, headerClass: 'font-bold' }, columnDefs: [ {headerName: \"Make\", field: \"make\"}, {headerName: \"Model\", field: \"model\"}, {headerName: \"Price\", field: \"price\"} ], rowData: [ {make: \"Toyota\", model: \"Celica\", price: 35000}, {make: \"Ford\", model: \"Mondeo\", price: 32000}, {make: \"Porsche\", model: \"Boxter\", price: 72000} ] } \"\"\" def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options ) return wp jp . justpy ( grid_test ) In this case the grid options are defined using a string that represents a JavaScript object. It could also be a Python dictionary. The options object is described in the ag_Grid documentation . Note We will see later, that when working with pandas, JustPy can automate the process and there is no need to go into the grid specification details. As mentioned above, AgGrid provides a default style to the grid when it is created. Let\u2019s change that style. Replace the function grid_test in the example above with the following: def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options , style = 'height: 200px; width: 300px; margin: 0.25em' ) return wp When you run the program, the rendered grid is smaller. After the grid is created, you can modify its options further. Let's add a data row after the grid is created: def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options , style = 'height: 200px; width: 300px; margin: 0.25em' ) grid . options . rowData . append ({ 'make' : 'Autocars' , 'model' : 'Sussita' , 'price' : 3 }) return wp Let's make all columns editable and add a checkbox in the second column. def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options , style = 'height: 200px; width: 300px; margin: 0.25em' ) for col_def in grid . options . columnDefs : col_def . editable = True grid . options . columnDefs [ 1 ] . checkboxSelection = True return wp You can now edit any cell in the grid. After selecting a cell, just start typing. The appearance of data in a column can be modified by assigning a list of classes to the cellClass attribute of a column definition. In the example below the appearance of the Model column is modified. def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options , style = 'height: 200px; width: 300px; margin: 0.25em' ) for col_def in grid . options . columnDefs : col_def . editable = True grid . options . columnDefs [ 1 ] . cellClass = [ 'text-2xl' , 'text-red-500' , 'hover:bg-blue-500' ] return wp Ag_Grid is very rich in features, very few which are covered here. For a detailed description of the grid features, please look at its documentation .","title":"Creating Grids"},{"location":"grids_tutorial/database/","text":"Displaying Database Tables and Query Results \u00b6 In the example below we use both pandas and ag-Grid to display database tables from an sqlite database. Warning For the example to work you need to download the chinook sqlite database and put it in the directory from which you are running the program. The file is a copy of the one found on https://www.sqlitetutorial.net/ which is an excellent resource for learning sqlite. The program uses pandas ability to load a frame with the result of a SQL query. This is done using read_sql_query . Once the data is in a pandas frame, we use the JustPy pandas extension to create an AgGrid. The program also has an additional request handler under the route '/city' which runs the following SQL command per request: SELECT DISTINCT city, country, customerid from customers ORDER BY country Again, the result is loaded into a pandas frame and using the pandas extension, an AgGrid is created. After the tables are displayed, the user can then filter and sort the data further using ag-Grid's capabilities. import justpy as jp import sqlite3 import pandas as pd # Download the database file to the local directory # from: https://elimintz.github.io/chinook.db, originally from https://www.sqlitetutorial.net/ db_con = sqlite3 . connect ( 'chinook.db' ) table_names = [ 'albums' , 'artists' , 'customers' , 'sqlite_sequence' , 'employees' , 'genres' , 'invoices' , 'invoice_items' , 'media_types' , 'playlists' , 'playlist_track' , 'tracks' , 'sqlite_stat1' ] tables = {} for table_name in table_names : tables [ table_name ] = pd . read_sql_query ( f \"SELECT * from {table_name} \" , db_con ) def selected_event ( self , msg ): # Runs when a table name is selected # Create a new grid and use its column and row definitions for grid already on page new_grid = tables [ msg . value ] . jp . ag_grid ( temp = True ) msg . page . g . options . columnDefs = new_grid . options . columnDefs msg . page . g . options . rowData = new_grid . options . rowData def db_test ( request ): wp = jp . QuasarPage () table_name = request . query_params . get ( 'table' , 'albums' ) s = jp . QSelect ( options = table_names , a = wp , label = \"Select Table\" , outlined = True , input = selected_event , style = 'width: 350px; margin: 0.25rem; padding: 0.25rem;' , value = table_name ) g = tables [ table_name ] . jp . ag_grid ( a = wp , style = 'height: 90vh; width: 99%; margin: 0.25rem; padding: 0.25rem;' ) g . options . pagination = True g . options . paginationAutoPageSize = True wp . g = g return wp @jp . SetRoute ( '/city' ) def city_test (): wp = jp . WebPage () g = pd . read_sql_query ( \"SELECT DISTINCT city, country, customerid from customers ORDER BY country\" , db_con ) . jp . ag_grid ( a = wp ) g . style = 'height: 99vh; width: 450px; margin: 0.25rem; padding: 0.25rem;' return wp jp . justpy ( db_test )","title":"Displaying Database Tables and Query Results"},{"location":"grids_tutorial/database/#displaying-database-tables-and-query-results","text":"In the example below we use both pandas and ag-Grid to display database tables from an sqlite database. Warning For the example to work you need to download the chinook sqlite database and put it in the directory from which you are running the program. The file is a copy of the one found on https://www.sqlitetutorial.net/ which is an excellent resource for learning sqlite. The program uses pandas ability to load a frame with the result of a SQL query. This is done using read_sql_query . Once the data is in a pandas frame, we use the JustPy pandas extension to create an AgGrid. The program also has an additional request handler under the route '/city' which runs the following SQL command per request: SELECT DISTINCT city, country, customerid from customers ORDER BY country Again, the result is loaded into a pandas frame and using the pandas extension, an AgGrid is created. After the tables are displayed, the user can then filter and sort the data further using ag-Grid's capabilities. import justpy as jp import sqlite3 import pandas as pd # Download the database file to the local directory # from: https://elimintz.github.io/chinook.db, originally from https://www.sqlitetutorial.net/ db_con = sqlite3 . connect ( 'chinook.db' ) table_names = [ 'albums' , 'artists' , 'customers' , 'sqlite_sequence' , 'employees' , 'genres' , 'invoices' , 'invoice_items' , 'media_types' , 'playlists' , 'playlist_track' , 'tracks' , 'sqlite_stat1' ] tables = {} for table_name in table_names : tables [ table_name ] = pd . read_sql_query ( f \"SELECT * from {table_name} \" , db_con ) def selected_event ( self , msg ): # Runs when a table name is selected # Create a new grid and use its column and row definitions for grid already on page new_grid = tables [ msg . value ] . jp . ag_grid ( temp = True ) msg . page . g . options . columnDefs = new_grid . options . columnDefs msg . page . g . options . rowData = new_grid . options . rowData def db_test ( request ): wp = jp . QuasarPage () table_name = request . query_params . get ( 'table' , 'albums' ) s = jp . QSelect ( options = table_names , a = wp , label = \"Select Table\" , outlined = True , input = selected_event , style = 'width: 350px; margin: 0.25rem; padding: 0.25rem;' , value = table_name ) g = tables [ table_name ] . jp . ag_grid ( a = wp , style = 'height: 90vh; width: 99%; margin: 0.25rem; padding: 0.25rem;' ) g . options . pagination = True g . options . paginationAutoPageSize = True wp . g = g return wp @jp . SetRoute ( '/city' ) def city_test (): wp = jp . WebPage () g = pd . read_sql_query ( \"SELECT DISTINCT city, country, customerid from customers ORDER BY country\" , db_con ) . jp . ag_grid ( a = wp ) g . style = 'height: 99vh; width: 450px; margin: 0.25rem; padding: 0.25rem;' return wp jp . justpy ( db_test )","title":"Displaying Database Tables and Query Results"},{"location":"grids_tutorial/field_evaluation/","text":"Evaluating Fields using JavaScript \u00b6 Some advanced options in Ag-grid require providing a JavaScript function. The fields whose string representation should be evaluated as JavaScript need to be specified in the evaluate attribute. In the example below, tree data mode is implemented. It is only available in the enterprise edition of ag-grid. Warning Don't forget to set justpy.env to load the enterprise version of ag-grid import justpy as jp grid_options = { 'getDataPath' : '''function(data) { return data.orgHierarchy; }''' , 'treeData' : True , 'defaultColDef' : { 'filter' : True , 'sortable' : True , 'resizable' : True , }, 'columnDefs' : [ { 'headerName' : \"job title\" , 'field' : \"jobTitle\" }, { 'headerName' : \"employment type\" , 'field' : \"employmentType\" }, ], 'rowData' : [ { 'orgHierarchy' : [ 'Erica' ], 'jobTitle' : \"CEO\" , 'employmentType' : \"Permanent\" }, { 'orgHierarchy' : [ 'Erica' , 'Malcolm' ], 'jobTitle' : \"VP\" , 'employmentType' : \"Permanent\" }, { 'orgHierarchy' : [ 'Erica' , 'Bob' ], 'jobTitle' : \"SVP\" , 'employmentType' : \"Permanent\" }, { 'orgHierarchy' : [ 'Erica' , 'Bob' , 'jo' ], 'jobTitle' : \"eVP\" , 'employmentType' : \"Permanent\" } ] } def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options ) grid . evaluate = [ 'getDataPath' ] return wp jp . justpy ( grid_test )","title":"Evaluating Fields using JavaScript"},{"location":"grids_tutorial/field_evaluation/#evaluating-fields-using-javascript","text":"Some advanced options in Ag-grid require providing a JavaScript function. The fields whose string representation should be evaluated as JavaScript need to be specified in the evaluate attribute. In the example below, tree data mode is implemented. It is only available in the enterprise edition of ag-grid. Warning Don't forget to set justpy.env to load the enterprise version of ag-grid import justpy as jp grid_options = { 'getDataPath' : '''function(data) { return data.orgHierarchy; }''' , 'treeData' : True , 'defaultColDef' : { 'filter' : True , 'sortable' : True , 'resizable' : True , }, 'columnDefs' : [ { 'headerName' : \"job title\" , 'field' : \"jobTitle\" }, { 'headerName' : \"employment type\" , 'field' : \"employmentType\" }, ], 'rowData' : [ { 'orgHierarchy' : [ 'Erica' ], 'jobTitle' : \"CEO\" , 'employmentType' : \"Permanent\" }, { 'orgHierarchy' : [ 'Erica' , 'Malcolm' ], 'jobTitle' : \"VP\" , 'employmentType' : \"Permanent\" }, { 'orgHierarchy' : [ 'Erica' , 'Bob' ], 'jobTitle' : \"SVP\" , 'employmentType' : \"Permanent\" }, { 'orgHierarchy' : [ 'Erica' , 'Bob' , 'jo' ], 'jobTitle' : \"eVP\" , 'employmentType' : \"Permanent\" } ] } def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp , options = grid_options ) grid . evaluate = [ 'getDataPath' ] return wp jp . justpy ( grid_test )","title":"Evaluating Fields using JavaScript"},{"location":"grids_tutorial/grid_api/","text":"Running Grid API Commands \u00b6 To run a grid API command use the grid's run_api() method. The method accepts two arguments. The first is a string representing the command and the second is the page the grid is on. The example below uses the grid API to select and deselect rows. import justpy as jp grid_options = \"\"\" { rowSelection: 'multiple', defaultColDef: { filter: true, sortable: true, resizable: true, cellStyle: {textAlign: 'center'}, headerClass: 'font-bold' }, columnDefs: [ {headerName: \"Make\", field: \"make\"}, {headerName: \"Model\", field: \"model\"}, {headerName: \"Price\", field: \"price\"} ], rowData: [ {make: \"Toyota\", model: \"Celica\", price: 35000}, {make: \"Ford\", model: \"Mondeo\", price: 32000}, {make: \"Porsche\", model: \"Boxter\", price: 72000} ] } \"\"\" def row_selected ( self , msg ): wp = msg . page if msg . selected : wp . selected_rows [ msg . rowIndex ] = msg . data else : wp . selected_rows . pop ( msg . rowIndex ) s = f 'Selected rows {sorted(list(wp.selected_rows.keys()))}' for i in sorted ( wp . selected_rows ): s = f ' {s} \\n Row {i} Data: {wp.selected_rows[i]} ' if wp . selected_rows : wp . rows_div . text = s else : wp . rows_div . text = 'No row selected' async def select_all_rows ( self , msg ): await self . grid . run_api ( 'selectAll()' , msg . page ) async def deselect_rows ( self , msg ): await self . grid . run_api ( 'deselectAll()' , msg . page ) def grid_test (): wp = jp . WebPage () wp . selected_rows = {} # Dictionary holding selected rows grid = jp . AgGrid ( a = wp , options = grid_options , style = 'height: 200px; width: 300px; margin: 0.25em' ) grid . options . columnDefs [ 0 ] . checkboxSelection = True grid . on ( 'rowSelected' , row_selected ) wp . rows_div = jp . Pre ( text = 'Data will go here when you select rows' , classes = 'border text-lg' , a = wp ) btn_deselect = jp . Button ( text = 'Deselect rows' , classes = jp . Styles . button_simple + ' m-2' , a = wp , click = deselect_rows ) btn_deselect . grid = grid btn_select_all = jp . Button ( text = 'Select all rows' , classes = jp . Styles . button_simple + ' m-2' , a = wp , click = select_all_rows ) btn_select_all . grid = grid return wp jp . justpy ( grid_test )","title":"Running Grid API Commands"},{"location":"grids_tutorial/grid_api/#running-grid-api-commands","text":"To run a grid API command use the grid's run_api() method. The method accepts two arguments. The first is a string representing the command and the second is the page the grid is on. The example below uses the grid API to select and deselect rows. import justpy as jp grid_options = \"\"\" { rowSelection: 'multiple', defaultColDef: { filter: true, sortable: true, resizable: true, cellStyle: {textAlign: 'center'}, headerClass: 'font-bold' }, columnDefs: [ {headerName: \"Make\", field: \"make\"}, {headerName: \"Model\", field: \"model\"}, {headerName: \"Price\", field: \"price\"} ], rowData: [ {make: \"Toyota\", model: \"Celica\", price: 35000}, {make: \"Ford\", model: \"Mondeo\", price: 32000}, {make: \"Porsche\", model: \"Boxter\", price: 72000} ] } \"\"\" def row_selected ( self , msg ): wp = msg . page if msg . selected : wp . selected_rows [ msg . rowIndex ] = msg . data else : wp . selected_rows . pop ( msg . rowIndex ) s = f 'Selected rows {sorted(list(wp.selected_rows.keys()))}' for i in sorted ( wp . selected_rows ): s = f ' {s} \\n Row {i} Data: {wp.selected_rows[i]} ' if wp . selected_rows : wp . rows_div . text = s else : wp . rows_div . text = 'No row selected' async def select_all_rows ( self , msg ): await self . grid . run_api ( 'selectAll()' , msg . page ) async def deselect_rows ( self , msg ): await self . grid . run_api ( 'deselectAll()' , msg . page ) def grid_test (): wp = jp . WebPage () wp . selected_rows = {} # Dictionary holding selected rows grid = jp . AgGrid ( a = wp , options = grid_options , style = 'height: 200px; width: 300px; margin: 0.25em' ) grid . options . columnDefs [ 0 ] . checkboxSelection = True grid . on ( 'rowSelected' , row_selected ) wp . rows_div = jp . Pre ( text = 'Data will go here when you select rows' , classes = 'border text-lg' , a = wp ) btn_deselect = jp . Button ( text = 'Deselect rows' , classes = jp . Styles . button_simple + ' m-2' , a = wp , click = deselect_rows ) btn_deselect . grid = grid btn_select_all = jp . Button ( text = 'Select all rows' , classes = jp . Styles . button_simple + ' m-2' , a = wp , click = select_all_rows ) btn_select_all . grid = grid return wp jp . justpy ( grid_test )","title":"Running Grid API Commands"},{"location":"grids_tutorial/grid_events/","text":"Grid Events \u00b6 Example 1 \u00b6 Ag-Grid supports many events . Let's look at some examples. To begin, let's display in a separate Div the data from a grid row when it is selected. import justpy as jp import pandas as pd wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def row_selected ( self , msg ): print ( msg ) if msg . selected : self . row_data_div . text = msg . data self . row_selected = msg . rowIndex elif self . row_selected == msg . rowIndex : self . row_data_div . text = '' def grid_test (): wp = jp . WebPage () row_data_div = jp . Div ( a = wp ) grid = wm_df . jp . ag_grid ( a = wp ) grid . row_data_div = row_data_div grid . on ( 'rowSelected' , row_selected ) grid . options . columnDefs [ 0 ] . checkboxSelection = True return wp jp . justpy ( grid_test ) We add a Div named row_data_div to the page and the row_selected function, the event handler for the grid's rowSelected event, sets the row data as the text of the Div. JustPy provides in msg.data all the data from the row in a form of a dictionary whose keys are the column names. msg.selected is set to True if the row was selected and to False if the row was de-selected. Both selection and de-selection fire the same rowSelected event and msg.selected can be used to distinguish between them. The index of the row for which the selection or de-selection occurred is found in msg.rowIndex . If the same row that was previously selected is deselected, row_data_div content is set to the empty string. Example 2 \u00b6 This previous example is not very interesting. Let's change it to display a chart of the selected row instead. import justpy as jp import pandas as pd wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def row_selected ( self , msg ): print ( msg ) if msg . selected : categories , values = list ( msg . data . keys ()), list ( msg . data . values ()) o = self . row_chart . options o . title . text = f ' {values[0]} - Percent Women in Major' o . xAxis . categories = categories [ 1 :] s = jp . Dict ({ 'name' : values [ 0 ], 'data' : values [ 1 :]}) s . dataLabels . enabled = True if len ( o . series ) > 0 : o . series [ 0 ] = s else : o . series . append ( s ) self . row_selected = msg . rowIndex self . row_chart . show = True elif self . row_selected == msg . rowIndex : self . row_chart . show = False def grid_test (): wp = jp . WebPage () row_chart = jp . HighCharts ( a = wp ) row_chart . options . chart . type = 'column' row_chart . options . yAxis . title . text = '%' row_chart . show = False grid = wm_df . jp . ag_grid ( a = wp ) grid . row_chart = row_chart grid . on ( 'rowSelected' , row_selected ) grid . options . columnDefs [ 0 ] . checkboxSelection = True return wp jp . justpy ( grid_test ) The chart is created once when the page is requested, but the first and only series in it is changed to reflect the new values once a row is selected. Example 3 - Multiple Row Selection \u00b6 import justpy as jp grid_options = \"\"\" { rowSelection: 'multiple', defaultColDef: { filter: true, sortable: true, resizable: true, cellStyle: {textAlign: 'center'}, headerClass: 'font-bold' }, columnDefs: [ {headerName: \"Make\", field: \"make\"}, {headerName: \"Model\", field: \"model\"}, {headerName: \"Price\", field: \"price\"} ], rowData: [ {make: \"Toyota\", model: \"Celica\", price: 35000}, {make: \"Ford\", model: \"Mondeo\", price: 32000}, {make: \"Porsche\", model: \"Boxter\", price: 72000} ] } \"\"\" def row_selected ( self , msg ): print ( msg . selected , msg ) wp = msg . page if msg . selected : wp . selected_rows [ msg . rowIndex ] = msg . data else : wp . selected_rows . pop ( msg . rowIndex ) s = f 'Selected rows {sorted(list(wp.selected_rows.keys()))}' for i in sorted ( wp . selected_rows ): s = f ' {s} \\n Row {i} Data: {wp.selected_rows[i]} ' if wp . selected_rows : wp . rows_div . text = s else : wp . rows_div . text = 'No row selected' def grid_test (): wp = jp . WebPage () wp . selected_rows = {} # Dictionary holding selected rows grid = jp . AgGrid ( a = wp , options = grid_options , style = 'height: 200px; width: 300px; margin: 0.25em' ) grid . options . columnDefs [ 0 ] . checkboxSelection = True grid . on ( 'rowSelected' , row_selected ) wp . rows_div = jp . Pre ( text = 'Data will go here when you select rows' , classes = 'border text-lg' , a = wp ) return wp jp . justpy ( grid_test ) Event Properties \u00b6 Ag-Grid supports many events . All the events supported by the community version can be captured and acted upon using JustPy. Each event contains different properties most of which JustPy makes available to the event handler through its second argument ( msg in the tutorial). A simple way to see which properties are available is to print msg . Another way is to go here . In the case of an event being one of ['sortChanged', 'filterChanged', 'columnMoved', 'rowDragEnd'] all the data in the gird after sorting and filtering is put into msg.data in CSV format. Warning When working with websockets, the size of each message is limited to 1 MByte when using uvicorn, so if your tables are larger, use Ajax by setting the websockets key word argument of the justpy command to False . Linking a chart and a grid using grid events \u00b6 Using grid events, it requires a few lines of code to link a grid to a chart. Filtering and sorting changes in the grid, will be reflected in the chart. import justpy as jp import pandas as pd df = pd . read_csv ( 'https://raw.githubusercontent.com/fivethirtyeight/data/master/alcohol-consumption/drinks.csv' , encoding = \"ISO-8859-1\" ) def grid_change ( self , msg ): msg . page . df = jp . read_csv_from_string ( msg . data ) c = msg . page . df . jp . plot ( 0 , [ 1 , 2 , 3 , 4 ], kind = 'column' , classes = 'm-2 p-2 w-2/3 border' , title = 'Alcohol Consumption per Country' ) msg . page . c . options = c . options def grid_test (): wp = jp . WebPage () wp . df = df wp . c = df . jp . plot ( 0 , [ 1 , 2 , 3 , 4 ], kind = 'column' , a = wp , classes = 'm-2 p-2 border' , title = 'Alcohol Consumption per Country' ) grid = df . jp . ag_grid ( a = wp ) for event_name in [ 'sortChanged' , 'filterChanged' , 'columnMoved' , 'rowDragEnd' ]: grid . on ( event_name , grid_change ) return wp jp . justpy ( grid_test ) Create a Component to Link Chart and Grid \u00b6 The example above can be simplified even further by creating a component in which a chart and a grid are linked. With the new component in hand, charts and grids can be linked with one line of code. import justpy as jp import pandas as pd class LinkedChartGrid ( jp . Div ): def __init__ ( self , df , x , y , ** kwargs ): super () . __init__ ( ** kwargs ) self . df = df self . x = x self . y = y self . kind = kwargs . get ( 'kind' , 'column' ) self . stacking = kwargs . get ( 'stacking' , '' ) self . title = kwargs . get ( 'title' , '' ) self . subtitle = kwargs . get ( 'subtitle' , '' ) self . set_classes ( 'flex flex-col' ) self . chart = df . jp . plot ( x , y , a = self , classes = 'm-2 p-2 border' , kind = self . kind , stacking = self . stacking , title = self . title , subtitle = self . subtitle ) self . grid = df . jp . ag_grid ( a = self ) self . grid . parent = self for event_name in [ 'sortChanged' , 'filterChanged' , 'columnMoved' , 'rowDragEnd' ]: self . grid . on ( event_name , self . grid_change ) @staticmethod def grid_change ( self , msg ): self . parent . df = jp . read_csv_from_string ( msg . data ) c = self . parent . df . jp . plot ( self . parent . x , self . parent . y , kind = self . parent . kind , title = self . parent . title , subtitle = self . parent . subtitle , stacking = self . parent . stacking ) self . parent . chart . options = c . options alcohol_df = pd . read_csv ( 'https://raw.githubusercontent.com/fivethirtyeight/data/master/alcohol-consumption/drinks.csv' , encoding = \"ISO-8859-1\" ) bad_drivers_df = pd . read_csv ( 'https://raw.githubusercontent.com/fivethirtyeight/data/master/bad-drivers/bad-drivers.csv' , encoding = \"ISO-8859-1\" ) def grid_test (): wp = jp . WebPage () c = LinkedChartGrid ( alcohol_df , 0 , [ 1 , 2 , 3 , 4 ], kind = 'column' , a = wp , classes = 'm-4 p-2 border' , stacking = 'normal' , title = 'Alcohol Consumption per Country' , subtitle = '538 data' ) LinkedChartGrid ( bad_drivers_df , 0 , [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ], kind = 'column' , a = wp , classes = 'm-4 p-2 border-4' , title = 'Bad Drivers per US State' , subtitle = '538 data' ) return wp jp . justpy ( grid_test )","title":"Grid Events"},{"location":"grids_tutorial/grid_events/#grid-events","text":"","title":"Grid Events"},{"location":"grids_tutorial/grid_events/#example-1","text":"Ag-Grid supports many events . Let's look at some examples. To begin, let's display in a separate Div the data from a grid row when it is selected. import justpy as jp import pandas as pd wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def row_selected ( self , msg ): print ( msg ) if msg . selected : self . row_data_div . text = msg . data self . row_selected = msg . rowIndex elif self . row_selected == msg . rowIndex : self . row_data_div . text = '' def grid_test (): wp = jp . WebPage () row_data_div = jp . Div ( a = wp ) grid = wm_df . jp . ag_grid ( a = wp ) grid . row_data_div = row_data_div grid . on ( 'rowSelected' , row_selected ) grid . options . columnDefs [ 0 ] . checkboxSelection = True return wp jp . justpy ( grid_test ) We add a Div named row_data_div to the page and the row_selected function, the event handler for the grid's rowSelected event, sets the row data as the text of the Div. JustPy provides in msg.data all the data from the row in a form of a dictionary whose keys are the column names. msg.selected is set to True if the row was selected and to False if the row was de-selected. Both selection and de-selection fire the same rowSelected event and msg.selected can be used to distinguish between them. The index of the row for which the selection or de-selection occurred is found in msg.rowIndex . If the same row that was previously selected is deselected, row_data_div content is set to the empty string.","title":"Example 1"},{"location":"grids_tutorial/grid_events/#example-2","text":"This previous example is not very interesting. Let's change it to display a chart of the selected row instead. import justpy as jp import pandas as pd wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def row_selected ( self , msg ): print ( msg ) if msg . selected : categories , values = list ( msg . data . keys ()), list ( msg . data . values ()) o = self . row_chart . options o . title . text = f ' {values[0]} - Percent Women in Major' o . xAxis . categories = categories [ 1 :] s = jp . Dict ({ 'name' : values [ 0 ], 'data' : values [ 1 :]}) s . dataLabels . enabled = True if len ( o . series ) > 0 : o . series [ 0 ] = s else : o . series . append ( s ) self . row_selected = msg . rowIndex self . row_chart . show = True elif self . row_selected == msg . rowIndex : self . row_chart . show = False def grid_test (): wp = jp . WebPage () row_chart = jp . HighCharts ( a = wp ) row_chart . options . chart . type = 'column' row_chart . options . yAxis . title . text = '%' row_chart . show = False grid = wm_df . jp . ag_grid ( a = wp ) grid . row_chart = row_chart grid . on ( 'rowSelected' , row_selected ) grid . options . columnDefs [ 0 ] . checkboxSelection = True return wp jp . justpy ( grid_test ) The chart is created once when the page is requested, but the first and only series in it is changed to reflect the new values once a row is selected.","title":"Example 2"},{"location":"grids_tutorial/grid_events/#example-3-multiple-row-selection","text":"import justpy as jp grid_options = \"\"\" { rowSelection: 'multiple', defaultColDef: { filter: true, sortable: true, resizable: true, cellStyle: {textAlign: 'center'}, headerClass: 'font-bold' }, columnDefs: [ {headerName: \"Make\", field: \"make\"}, {headerName: \"Model\", field: \"model\"}, {headerName: \"Price\", field: \"price\"} ], rowData: [ {make: \"Toyota\", model: \"Celica\", price: 35000}, {make: \"Ford\", model: \"Mondeo\", price: 32000}, {make: \"Porsche\", model: \"Boxter\", price: 72000} ] } \"\"\" def row_selected ( self , msg ): print ( msg . selected , msg ) wp = msg . page if msg . selected : wp . selected_rows [ msg . rowIndex ] = msg . data else : wp . selected_rows . pop ( msg . rowIndex ) s = f 'Selected rows {sorted(list(wp.selected_rows.keys()))}' for i in sorted ( wp . selected_rows ): s = f ' {s} \\n Row {i} Data: {wp.selected_rows[i]} ' if wp . selected_rows : wp . rows_div . text = s else : wp . rows_div . text = 'No row selected' def grid_test (): wp = jp . WebPage () wp . selected_rows = {} # Dictionary holding selected rows grid = jp . AgGrid ( a = wp , options = grid_options , style = 'height: 200px; width: 300px; margin: 0.25em' ) grid . options . columnDefs [ 0 ] . checkboxSelection = True grid . on ( 'rowSelected' , row_selected ) wp . rows_div = jp . Pre ( text = 'Data will go here when you select rows' , classes = 'border text-lg' , a = wp ) return wp jp . justpy ( grid_test )","title":"Example 3 - Multiple Row Selection"},{"location":"grids_tutorial/grid_events/#event-properties","text":"Ag-Grid supports many events . All the events supported by the community version can be captured and acted upon using JustPy. Each event contains different properties most of which JustPy makes available to the event handler through its second argument ( msg in the tutorial). A simple way to see which properties are available is to print msg . Another way is to go here . In the case of an event being one of ['sortChanged', 'filterChanged', 'columnMoved', 'rowDragEnd'] all the data in the gird after sorting and filtering is put into msg.data in CSV format. Warning When working with websockets, the size of each message is limited to 1 MByte when using uvicorn, so if your tables are larger, use Ajax by setting the websockets key word argument of the justpy command to False .","title":"Event Properties"},{"location":"grids_tutorial/grid_events/#linking-a-chart-and-a-grid-using-grid-events","text":"Using grid events, it requires a few lines of code to link a grid to a chart. Filtering and sorting changes in the grid, will be reflected in the chart. import justpy as jp import pandas as pd df = pd . read_csv ( 'https://raw.githubusercontent.com/fivethirtyeight/data/master/alcohol-consumption/drinks.csv' , encoding = \"ISO-8859-1\" ) def grid_change ( self , msg ): msg . page . df = jp . read_csv_from_string ( msg . data ) c = msg . page . df . jp . plot ( 0 , [ 1 , 2 , 3 , 4 ], kind = 'column' , classes = 'm-2 p-2 w-2/3 border' , title = 'Alcohol Consumption per Country' ) msg . page . c . options = c . options def grid_test (): wp = jp . WebPage () wp . df = df wp . c = df . jp . plot ( 0 , [ 1 , 2 , 3 , 4 ], kind = 'column' , a = wp , classes = 'm-2 p-2 border' , title = 'Alcohol Consumption per Country' ) grid = df . jp . ag_grid ( a = wp ) for event_name in [ 'sortChanged' , 'filterChanged' , 'columnMoved' , 'rowDragEnd' ]: grid . on ( event_name , grid_change ) return wp jp . justpy ( grid_test )","title":"Linking a chart and a grid using grid events"},{"location":"grids_tutorial/grid_events/#create-a-component-to-link-chart-and-grid","text":"The example above can be simplified even further by creating a component in which a chart and a grid are linked. With the new component in hand, charts and grids can be linked with one line of code. import justpy as jp import pandas as pd class LinkedChartGrid ( jp . Div ): def __init__ ( self , df , x , y , ** kwargs ): super () . __init__ ( ** kwargs ) self . df = df self . x = x self . y = y self . kind = kwargs . get ( 'kind' , 'column' ) self . stacking = kwargs . get ( 'stacking' , '' ) self . title = kwargs . get ( 'title' , '' ) self . subtitle = kwargs . get ( 'subtitle' , '' ) self . set_classes ( 'flex flex-col' ) self . chart = df . jp . plot ( x , y , a = self , classes = 'm-2 p-2 border' , kind = self . kind , stacking = self . stacking , title = self . title , subtitle = self . subtitle ) self . grid = df . jp . ag_grid ( a = self ) self . grid . parent = self for event_name in [ 'sortChanged' , 'filterChanged' , 'columnMoved' , 'rowDragEnd' ]: self . grid . on ( event_name , self . grid_change ) @staticmethod def grid_change ( self , msg ): self . parent . df = jp . read_csv_from_string ( msg . data ) c = self . parent . df . jp . plot ( self . parent . x , self . parent . y , kind = self . parent . kind , title = self . parent . title , subtitle = self . parent . subtitle , stacking = self . parent . stacking ) self . parent . chart . options = c . options alcohol_df = pd . read_csv ( 'https://raw.githubusercontent.com/fivethirtyeight/data/master/alcohol-consumption/drinks.csv' , encoding = \"ISO-8859-1\" ) bad_drivers_df = pd . read_csv ( 'https://raw.githubusercontent.com/fivethirtyeight/data/master/bad-drivers/bad-drivers.csv' , encoding = \"ISO-8859-1\" ) def grid_test (): wp = jp . WebPage () c = LinkedChartGrid ( alcohol_df , 0 , [ 1 , 2 , 3 , 4 ], kind = 'column' , a = wp , classes = 'm-4 p-2 border' , stacking = 'normal' , title = 'Alcohol Consumption per Country' , subtitle = '538 data' ) LinkedChartGrid ( bad_drivers_df , 0 , [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ], kind = 'column' , a = wp , classes = 'm-4 p-2 border-4' , title = 'Bad Drivers per US State' , subtitle = '538 data' ) return wp jp . justpy ( grid_test )","title":"Create a Component to Link Chart and Grid"},{"location":"grids_tutorial/introduction/","text":"ag-Grid Introduction \u00b6 JustPy comes with a grid component based on ag-Grid Community which is a free to use product distributed under the MIT License. The features provided in the Community version of ag-Grid are comprehensive and its API and documentation are clear and easy to work with. Note It took about 100 lines of Python and about 100 lines of JavasScript to add ag-Grid as a component to JustPy. If you are interested in integrating other grid or JavaScript components with JustPy, please take a look at the code and contact me. An ag-Grid grid is represented in JustPy as an instance of the class AgGrid. The grid is defined by the options attribute which is a Python dictionary that corresponds to the JavaScript object that defines the grid in JavaScript. The correspondence is one to one. As in the case with chart options, the grid options can be loaded from a string representing a JavaScript object (with the usual caveats). The AgGrid component comes with some default settings that can be changed. One of these setting is the style attribute which gives some width and height to the grid. Warning If you change the style, make sure to specify height and width. Without these, the grid will not be displayed. The simplest way to load data to the grid is from a pandas frame. We will cover some examples of this below.","title":"Introduction"},{"location":"grids_tutorial/introduction/#ag-grid-introduction","text":"JustPy comes with a grid component based on ag-Grid Community which is a free to use product distributed under the MIT License. The features provided in the Community version of ag-Grid are comprehensive and its API and documentation are clear and easy to work with. Note It took about 100 lines of Python and about 100 lines of JavasScript to add ag-Grid as a component to JustPy. If you are interested in integrating other grid or JavaScript components with JustPy, please take a look at the code and contact me. An ag-Grid grid is represented in JustPy as an instance of the class AgGrid. The grid is defined by the options attribute which is a Python dictionary that corresponds to the JavaScript object that defines the grid in JavaScript. The correspondence is one to one. As in the case with chart options, the grid options can be loaded from a string representing a JavaScript object (with the usual caveats). The AgGrid component comes with some default settings that can be changed. One of these setting is the style attribute which gives some width and height to the grid. Warning If you change the style, make sure to specify height and width. Without these, the grid will not be displayed. The simplest way to load data to the grid is from a pandas frame. We will cover some examples of this below.","title":"ag-Grid Introduction"},{"location":"grids_tutorial/pandas/","text":"Using Pandas to Create Grids \u00b6 Loading a Frame into a Grid \u00b6 The AgGrid method load_pandas_frame(df) makes it simple to load data from a pandas frame into a grid. The example below reads a CSV file into a pandas frame and then uses the grid to display the data. The data shows the percentage of women in each college major per year. Warning To run the example below you will need to have pandas installed. import justpy as jp import pandas as pd wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp ) grid . load_pandas_frame ( wm_df ) return wp jp . justpy ( grid_test ) Mouseover one of the column headers and click on the \"three horizontal lines\" icon that appears to the right of the column name. You can now filter the data in the column. By clicking the arrows in the column heading you can sort the grid according to the values in the column. Pandas Extension \u00b6 JustPy comes with a pandas extension that makes loading panadas frames into a grid compatible with the Pandas syntax. The program below is equivalent to the one above: import justpy as jp import pandas as pd wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def grid_test (): wp = jp . WebPage () wm_df . jp . ag_grid ( a = wp ) return wp jp . justpy ( grid_test ) The JustPy functionality is added to pandas under the namespace \"jp\". The ag_grid method creates a grid based on the frame's data and returns an instance of AgGrid. The grid can be further modified after it is created: import justpy as jp import pandas as pd wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def grid_test (): wp = jp . WebPage () grid = wm_df . jp . ag_grid ( a = wp ) grid . options . pagination = True grid . options . paginationAutoPageSize = True grid . options . columnDefs [ 0 ] . cellClass = [ 'text-white' , 'bg-blue-500' , 'hover:bg-blue-200' ] for col_def in grid . options . columnDefs [ 1 :]: col_def . cellClassRules = { 'font-bold' : 'x < 20' , 'bg-red-300' : 'x < 20' , 'bg-yellow-300' : 'x >= 20 && x < 50' , 'bg-green-300' : 'x >= 50' } return wp jp . justpy ( grid_test ) The example above sets the grid to be paginated instead of scrolled. The data is formatted so that any number under 20 is in a bold font and the background of the cell is red. Cells with values between 20 and 50 receive a background of yellow and those above 50 are green. The ag-Grid documentation is extensive and should be consulted for the features that the grid support.","title":"Using Pandas to Create Grids"},{"location":"grids_tutorial/pandas/#using-pandas-to-create-grids","text":"","title":"Using Pandas to Create Grids"},{"location":"grids_tutorial/pandas/#loading-a-frame-into-a-grid","text":"The AgGrid method load_pandas_frame(df) makes it simple to load data from a pandas frame into a grid. The example below reads a CSV file into a pandas frame and then uses the grid to display the data. The data shows the percentage of women in each college major per year. Warning To run the example below you will need to have pandas installed. import justpy as jp import pandas as pd wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def grid_test (): wp = jp . WebPage () grid = jp . AgGrid ( a = wp ) grid . load_pandas_frame ( wm_df ) return wp jp . justpy ( grid_test ) Mouseover one of the column headers and click on the \"three horizontal lines\" icon that appears to the right of the column name. You can now filter the data in the column. By clicking the arrows in the column heading you can sort the grid according to the values in the column.","title":"Loading a Frame into a Grid"},{"location":"grids_tutorial/pandas/#pandas-extension","text":"JustPy comes with a pandas extension that makes loading panadas frames into a grid compatible with the Pandas syntax. The program below is equivalent to the one above: import justpy as jp import pandas as pd wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def grid_test (): wp = jp . WebPage () wm_df . jp . ag_grid ( a = wp ) return wp jp . justpy ( grid_test ) The JustPy functionality is added to pandas under the namespace \"jp\". The ag_grid method creates a grid based on the frame's data and returns an instance of AgGrid. The grid can be further modified after it is created: import justpy as jp import pandas as pd wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) def grid_test (): wp = jp . WebPage () grid = wm_df . jp . ag_grid ( a = wp ) grid . options . pagination = True grid . options . paginationAutoPageSize = True grid . options . columnDefs [ 0 ] . cellClass = [ 'text-white' , 'bg-blue-500' , 'hover:bg-blue-200' ] for col_def in grid . options . columnDefs [ 1 :]: col_def . cellClassRules = { 'font-bold' : 'x < 20' , 'bg-red-300' : 'x < 20' , 'bg-yellow-300' : 'x >= 20 && x < 50' , 'bg-green-300' : 'x >= 50' } return wp jp . justpy ( grid_test ) The example above sets the grid to be paginated instead of scrolled. The data is formatted so that any number under 20 is in a bold font and the background of the cell is red. Cells with values between 20 and 50 receive a background of yellow and those above 50 are green. The ag-Grid documentation is extensive and should be consulted for the features that the grid support.","title":"Pandas Extension"},{"location":"how_to/add_row_to_grid/","text":"How to Add a Row to a Grid \u00b6 import justpy as jp grid_options = { 'defaultColDef' : { 'filter' : True , 'sortable' : True , 'resizable' : True , 'cellStyle' : { 'textAlign' : 'center' }, 'headerClass' : 'font-bold' }, 'columnDefs' : [{ 'headerName' : 'Make' , 'field' : 'make' , 'editable' : True }, { 'headerName' : 'Model' , 'field' : 'model' , 'editable' : True }, { 'headerName' : 'Price' , 'field' : 'price' , 'editable' : True } ], 'rowData' : [{ 'make' : 'Toyota' , 'model' : 'Celica' , 'price' : 35000 }, { 'make' : 'Ford' , 'model' : 'Mondeo' , 'price' : 32000 }, { 'make' : 'Porsche' , 'model' : 'Boxter' , 'price' : 72000 }]} def add_row ( self , msg ): self . grid . options . rowData . append ({ 'make' : 'Tesla' , 'model' : 'Roadster' , 'price' : 95000 }) def grid_test (): wp = jp . WebPage () add_row_btn = jp . Button ( text = 'Add Row' , classes = 'm-2 ' + jp . Styles . button_simple , a = wp , click = add_row ) grid = jp . AgGrid ( a = wp , options = grid_options , auto_size = False ) add_row_btn . grid = grid return wp jp . justpy ( grid_test )","title":"How to Add a Row to a Grid"},{"location":"how_to/add_row_to_grid/#how-to-add-a-row-to-a-grid","text":"import justpy as jp grid_options = { 'defaultColDef' : { 'filter' : True , 'sortable' : True , 'resizable' : True , 'cellStyle' : { 'textAlign' : 'center' }, 'headerClass' : 'font-bold' }, 'columnDefs' : [{ 'headerName' : 'Make' , 'field' : 'make' , 'editable' : True }, { 'headerName' : 'Model' , 'field' : 'model' , 'editable' : True }, { 'headerName' : 'Price' , 'field' : 'price' , 'editable' : True } ], 'rowData' : [{ 'make' : 'Toyota' , 'model' : 'Celica' , 'price' : 35000 }, { 'make' : 'Ford' , 'model' : 'Mondeo' , 'price' : 32000 }, { 'make' : 'Porsche' , 'model' : 'Boxter' , 'price' : 72000 }]} def add_row ( self , msg ): self . grid . options . rowData . append ({ 'make' : 'Tesla' , 'model' : 'Roadster' , 'price' : 95000 }) def grid_test (): wp = jp . WebPage () add_row_btn = jp . Button ( text = 'Add Row' , classes = 'm-2 ' + jp . Styles . button_simple , a = wp , click = add_row ) grid = jp . AgGrid ( a = wp , options = grid_options , auto_size = False ) add_row_btn . grid = grid return wp jp . justpy ( grid_test )","title":"How to Add a Row to a Grid"},{"location":"how_to/change_font/","text":"Using Specific Fonts \u00b6 The Tailwind team likes to use the Inter font. The way to do so is the following: import justpy as jp def font_change (): wp = jp . WebPage ( template_file = 'tailwindui.html' ) wp . head_html = '<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/inter-ui@3.13.1/inter.min.css\">' wp . css = 'body { font-family: Inter; }' # The text in this Div will be Inter jp . Div ( text = 'The quick brown fox jumped over something' , classes = 'm-4 text-3xl' , a = wp ) # Other fonts will be used for these Divs jp . Div ( text = 'The quick brown fox jumped over something' , classes = 'm-4 font-sans text-3xl' , a = wp ) jp . Div ( text = 'The quick brown fox jumped over something' , classes = 'm-4 font-serif text-3xl' , a = wp ) jp . Div ( text = 'The quick brown fox jumped over something' , classes = 'm-4 font-mono text-3xl' , a = wp ) return wp jp . justpy ( font_change ) The default font will now be Inter. If you specify a font class, the default tailwind fonts will be used.","title":"Use Different Fonts"},{"location":"how_to/change_font/#using-specific-fonts","text":"The Tailwind team likes to use the Inter font. The way to do so is the following: import justpy as jp def font_change (): wp = jp . WebPage ( template_file = 'tailwindui.html' ) wp . head_html = '<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/inter-ui@3.13.1/inter.min.css\">' wp . css = 'body { font-family: Inter; }' # The text in this Div will be Inter jp . Div ( text = 'The quick brown fox jumped over something' , classes = 'm-4 text-3xl' , a = wp ) # Other fonts will be used for these Divs jp . Div ( text = 'The quick brown fox jumped over something' , classes = 'm-4 font-sans text-3xl' , a = wp ) jp . Div ( text = 'The quick brown fox jumped over something' , classes = 'm-4 font-serif text-3xl' , a = wp ) jp . Div ( text = 'The quick brown fox jumped over something' , classes = 'm-4 font-mono text-3xl' , a = wp ) return wp jp . justpy ( font_change ) The default font will now be Inter. If you specify a font class, the default tailwind fonts will be used.","title":"Using Specific Fonts"},{"location":"how_to/context_menu/","text":"Addiing a Context Menu (right-click in browser) \u00b6 import justpy as jp def my_click ( self , msg ): print ( msg ) self . text = f 'Mouse button clicked: {msg.which} ' # Show context menu div and place it near the click if msg . which == 3 : msg . page . context_menu . remove_class ( 'hidden' ) msg . page . context_menu . style = f 'top {msg.pageY} px; left: {msg.pageX} px;' def click_out ( self , msg ): self . set_class ( 'hidden' ) def event_demo (): wp = jp . WebPage () wp . head_html = \"\"\" <script> window.oncontextmenu = function () { return false; // cancel default menu } </script> \"\"\" d = jp . Div ( text = 'Not clicked yet' , a = wp , classes = 'w-64 text-xl m-2 p-1 bg-blue-500 text-white' ) d . add_event ( 'mousedown' ) d . on ( 'mousedown' , my_click ) d . additional_properties = [ 'screenX' , 'pageY' , 'pageX' , 'altKey' , 'which' , 'movementX' , ' button' , 'buttons' ] # In your case you would build a more elaborate div wp . context_menu = jp . Div ( text = 'My context menu' , classes = 'hidden absolute border text-white bg-blue-500' , a = wp ) wp . context_menu . on ( 'click__out' , click_out ) return wp jp . justpy ( event_demo ) The JavaScript added to the page disables the default behavior of the context menu. Then, you use the mousedown event to detect which button was pressed. In order to do this we modify the element to add additional fields to msg from the JavaScript event. click__out is also used to hide the simple context menu when there is a click outside of it.","title":"Addiing a Context Menu (right-click in browser)"},{"location":"how_to/context_menu/#addiing-a-context-menu-right-click-in-browser","text":"import justpy as jp def my_click ( self , msg ): print ( msg ) self . text = f 'Mouse button clicked: {msg.which} ' # Show context menu div and place it near the click if msg . which == 3 : msg . page . context_menu . remove_class ( 'hidden' ) msg . page . context_menu . style = f 'top {msg.pageY} px; left: {msg.pageX} px;' def click_out ( self , msg ): self . set_class ( 'hidden' ) def event_demo (): wp = jp . WebPage () wp . head_html = \"\"\" <script> window.oncontextmenu = function () { return false; // cancel default menu } </script> \"\"\" d = jp . Div ( text = 'Not clicked yet' , a = wp , classes = 'w-64 text-xl m-2 p-1 bg-blue-500 text-white' ) d . add_event ( 'mousedown' ) d . on ( 'mousedown' , my_click ) d . additional_properties = [ 'screenX' , 'pageY' , 'pageX' , 'altKey' , 'which' , 'movementX' , ' button' , 'buttons' ] # In your case you would build a more elaborate div wp . context_menu = jp . Div ( text = 'My context menu' , classes = 'hidden absolute border text-white bg-blue-500' , a = wp ) wp . context_menu . on ( 'click__out' , click_out ) return wp jp . justpy ( event_demo ) The JavaScript added to the page disables the default behavior of the context menu. Then, you use the mousedown event to detect which button was pressed. In order to do this we modify the element to add additional fields to msg from the JavaScript event. click__out is also used to hide the simple context menu when there is a click outside of it.","title":"Addiing a Context Menu (right-click in browser)"},{"location":"how_to/create_select/","text":"How to use the Select HTML Tag \u00b6 The select tag needs to be used together with the option tag. In JustPy these correspond to Select and Option elements. The program below creates a select element that whose value changes the background color of a Div. import justpy as jp def change_color ( self , msg ): self . color_div . set_class ( f 'bg- {self.value} -600' ) def comp_test (): wp = jp . WebPage () colors = [ 'red' , 'green' , 'blue' , 'pink' , 'yellow' , 'teal' , 'purple' ] select = jp . Select ( classes = 'w-32 text-xl m-4 p-2 bg-white border rounded' , a = wp , value = 'red' , change = change_color ) for color in colors : select . add ( jp . Option ( value = color , text = color , classes = f 'bg- {color} -600' )) select . color_div = jp . Div ( classes = 'bg-red-600 w-32 h-16 m-4' , a = wp ) return wp jp . justpy ( comp_test )","title":"Creating Select Elements"},{"location":"how_to/create_select/#how-to-use-the-select-html-tag","text":"The select tag needs to be used together with the option tag. In JustPy these correspond to Select and Option elements. The program below creates a select element that whose value changes the background color of a Div. import justpy as jp def change_color ( self , msg ): self . color_div . set_class ( f 'bg- {self.value} -600' ) def comp_test (): wp = jp . WebPage () colors = [ 'red' , 'green' , 'blue' , 'pink' , 'yellow' , 'teal' , 'purple' ] select = jp . Select ( classes = 'w-32 text-xl m-4 p-2 bg-white border rounded' , a = wp , value = 'red' , change = change_color ) for color in colors : select . add ( jp . Option ( value = color , text = color , classes = f 'bg- {color} -600' )) select . color_div = jp . Div ( classes = 'bg-red-600 w-32 h-16 m-4' , a = wp ) return wp jp . justpy ( comp_test )","title":"How to use the Select HTML Tag"},{"location":"how_to/login_decorator/","text":"Use Decorators for Request Handlers \u00b6 In this example, the decorator valid_id is defined that modifies a request handler to redirect to the home page if the user is not logged in. This is done using the JustPy function redirect that accepts as an argument the URL to redirect to. The function returns a WebPage instance with the redirect attribute set based on the parameter. import justpy as jp from functools import wraps logged_in = {} def test_id ( id ): return id in logged_in def valid_id ( f ): @wraps ( f ) def wrapper ( request ): bool_outcome = test_id ( request . session_id ) if bool_outcome : return f ( request ) else : return jp . redirect ( '/' ) return wrapper def login_user ( self , msg ): logged_in [ msg . session_id ] = True @jp . SetRoute ( '/login' ) def login_page ( request ): wp = jp . WebPage () btn = jp . Button ( text = 'Login' , classes = 'm-4 ' + jp . Styles . button_simple , click = login_user , a = wp ) return wp @jp . SetRoute ( '/info' ) @valid_id def info_page ( request ): wp = jp . WebPage () jp . Div ( text = 'Some info' , classes = 'm-2 text-xl' , a = wp ) return wp def home_page (): wp = jp . WebPage () jp . A ( text = 'Click to go to login page ' , href = '/login' , a = wp , classes = 'm-4 text-xl' ) return wp jp . justpy ( home_page )","title":"Use Decorators with Request Handlers"},{"location":"how_to/login_decorator/#use-decorators-for-request-handlers","text":"In this example, the decorator valid_id is defined that modifies a request handler to redirect to the home page if the user is not logged in. This is done using the JustPy function redirect that accepts as an argument the URL to redirect to. The function returns a WebPage instance with the redirect attribute set based on the parameter. import justpy as jp from functools import wraps logged_in = {} def test_id ( id ): return id in logged_in def valid_id ( f ): @wraps ( f ) def wrapper ( request ): bool_outcome = test_id ( request . session_id ) if bool_outcome : return f ( request ) else : return jp . redirect ( '/' ) return wrapper def login_user ( self , msg ): logged_in [ msg . session_id ] = True @jp . SetRoute ( '/login' ) def login_page ( request ): wp = jp . WebPage () btn = jp . Button ( text = 'Login' , classes = 'm-4 ' + jp . Styles . button_simple , click = login_user , a = wp ) return wp @jp . SetRoute ( '/info' ) @valid_id def info_page ( request ): wp = jp . WebPage () jp . Div ( text = 'Some info' , classes = 'm-2 text-xl' , a = wp ) return wp def home_page (): wp = jp . WebPage () jp . A ( text = 'Click to go to login page ' , href = '/login' , a = wp , classes = 'm-4 text-xl' ) return wp jp . justpy ( home_page )","title":"Use Decorators for Request Handlers"},{"location":"how_to/monitor_idle/","text":"Monitor Inactivity \u00b6 import justpy as jp import time import asyncio def mouse_moved ( self , msg ): print ( 'mouse moved' ) msg . page . start_time = time . perf_counter () return True async def idle_test (): wp = jp . WebPage () wp . start_time = time . perf_counter () d = jp . Div ( style = 'height: 100vh' , a = wp ) d . add_event ( 'mousemove' ) d . on ( 'mousemove' , mouse_moved ) wp . idle_div = jp . Div ( text = 'Idle time' , classes = 'm-4 text-lg' , a = d ) # Has to be in request handler so can be specific per page async def monitor_timer (): keep_monitoring = True idle_threshold = 5 while keep_monitoring : try : await asyncio . sleep ( 5 ) idle_time = time . perf_counter () - wp . start_time if idle_time > idle_threshold : wp . idle_div . text = f 'Idle for {idle_time} seconds' jp . run_task ( wp . update ()) except : # When page is closed, it will be erased, the exception will occur and the task will terminate keep_monitoring = False jp . run_task ( monitor_timer ()) return wp jp . justpy ( idle_test )","title":"Monitor User Activity"},{"location":"how_to/monitor_idle/#monitor-inactivity","text":"import justpy as jp import time import asyncio def mouse_moved ( self , msg ): print ( 'mouse moved' ) msg . page . start_time = time . perf_counter () return True async def idle_test (): wp = jp . WebPage () wp . start_time = time . perf_counter () d = jp . Div ( style = 'height: 100vh' , a = wp ) d . add_event ( 'mousemove' ) d . on ( 'mousemove' , mouse_moved ) wp . idle_div = jp . Div ( text = 'Idle time' , classes = 'm-4 text-lg' , a = d ) # Has to be in request handler so can be specific per page async def monitor_timer (): keep_monitoring = True idle_threshold = 5 while keep_monitoring : try : await asyncio . sleep ( 5 ) idle_time = time . perf_counter () - wp . start_time if idle_time > idle_threshold : wp . idle_div . text = f 'Idle for {idle_time} seconds' jp . run_task ( wp . update ()) except : # When page is closed, it will be erased, the exception will occur and the task will terminate keep_monitoring = False jp . run_task ( monitor_timer ()) return wp jp . justpy ( idle_test )","title":"Monitor Inactivity"},{"location":"how_to/play_audio/","text":"How to Play Audio \u00b6 import justpy as jp audio_file_url = 'https://file-examples-com.github.io/uploads/2017/11/file_example_MP3_700KB.mp3' async def play_audio ( self , msg ): await msg . page . run_javascript ( f \"\"\" new Audio(' {audio_file_url} ').play(); \"\"\" ) def audio_test (): wp = jp . WebPage () jp . Button ( text = 'Play Audio' , classes = 'm-2 ' + jp . Styles . button_simple , click = play_audio , a = wp ) return wp jp . justpy ( audio_test )","title":"How to Play Audio"},{"location":"how_to/play_audio/#how-to-play-audio","text":"import justpy as jp audio_file_url = 'https://file-examples-com.github.io/uploads/2017/11/file_example_MP3_700KB.mp3' async def play_audio ( self , msg ): await msg . page . run_javascript ( f \"\"\" new Audio(' {audio_file_url} ').play(); \"\"\" ) def audio_test (): wp = jp . WebPage () jp . Button ( text = 'Play Audio' , classes = 'm-2 ' + jp . Styles . button_simple , click = play_audio , a = wp ) return wp jp . justpy ( audio_test )","title":"How to Play Audio"},{"location":"how_to/quasar_full_screen/","text":"How ot Toggle Full Screen Mode in Quasar \u00b6 import justpy as jp async def toggle_screen ( self , msg ): await msg . page . run_javascript ( 'Quasar.AppFullscreen.toggle()' ) def full_screen_test (): wp = jp . QuasarPage () d = jp . Div ( classes = 'q-pa-md q-gutter-sm' , a = wp ) jp . QBtn ( color = 'primary' , label = 'Toggle Screen' , a = d , click = toggle_screen ) return wp jp . justpy ( full_screen_test )","title":"Quasar Full Screen Mode"},{"location":"how_to/quasar_full_screen/#how-ot-toggle-full-screen-mode-in-quasar","text":"import justpy as jp async def toggle_screen ( self , msg ): await msg . page . run_javascript ( 'Quasar.AppFullscreen.toggle()' ) def full_screen_test (): wp = jp . QuasarPage () d = jp . Div ( classes = 'q-pa-md q-gutter-sm' , a = wp ) jp . QBtn ( color = 'primary' , label = 'Toggle Screen' , a = d , click = toggle_screen ) return wp jp . justpy ( full_screen_test )","title":"How ot Toggle Full Screen Mode in Quasar"},{"location":"how_to/reload_pages/","text":"Forcing a Hard Reload \u00b6 import justpy as jp from datetime import datetime @jp . SetRoute ( '/hard_reload' ) async def hard_reload (): wp = jp . WebPage () wp . page_type = 'admin' d = jp . Div ( text = 'Pages reloaded' , classes = 'm-2 p-2 text-2xl' , a = wp ) for page in jp . WebPage . instances . values (): if page . page_type == 'main' : await page . reload () return wp def main_page (): wp = jp . WebPage () wp . page_type = 'main' now = datetime . now () . strftime ( '%Y-%m- %d %H:%M:%S' ) d = jp . Div ( text = now , classes = 'm-2 p-2 text-2xl' , a = wp ) return wp jp . justpy ( main_page )","title":"Reload Page"},{"location":"how_to/reload_pages/#forcing-a-hard-reload","text":"import justpy as jp from datetime import datetime @jp . SetRoute ( '/hard_reload' ) async def hard_reload (): wp = jp . WebPage () wp . page_type = 'admin' d = jp . Div ( text = 'Pages reloaded' , classes = 'm-2 p-2 text-2xl' , a = wp ) for page in jp . WebPage . instances . values (): if page . page_type == 'main' : await page . reload () return wp def main_page (): wp = jp . WebPage () wp . page_type = 'main' now = datetime . now () . strftime ( '%Y-%m- %d %H:%M:%S' ) d = jp . Div ( text = now , classes = 'm-2 p-2 text-2xl' , a = wp ) return wp jp . justpy ( main_page )","title":"Forcing a Hard Reload"},{"location":"meadows/general/","text":"General Thoughts \u00b6 await this.dispatch(event, event_data) different than alpine dispatch as there is no bubbling. There is dict of events on the page that has the appropriate component instance and results in run_event. dispatch must always be awaited. Currently dict only supports one element per event Example in card_search.py where the input also captures keydown to make sure it does not propagate to window and also does return True to avoid flicker. Modifiers: * window put event in window * once evaluate expression only once at beginning (good for initialization using python globals) * stop stop propagation * noupdate add return True at end of init when creating event handler. Does not update page x-model works just on top direct attributes that are simple types, see task in todo.py. task works but not task[i]. Otherwise, just write it explicitly","title":"General Thoughts"},{"location":"meadows/general/#general-thoughts","text":"await this.dispatch(event, event_data) different than alpine dispatch as there is no bubbling. There is dict of events on the page that has the appropriate component instance and results in run_event. dispatch must always be awaited. Currently dict only supports one element per event Example in card_search.py where the input also captures keydown to make sure it does not propagate to window and also does return True to avoid flicker. Modifiers: * window put event in window * once evaluate expression only once at beginning (good for initialization using python globals) * stop stop propagation * noupdate add return True at end of init when creating event handler. Does not update page x-model works just on top direct attributes that are simple types, see task in todo.py. task works but not task[i]. Otherwise, just write it explicitly","title":"General Thoughts"},{"location":"quasar_tutorial/QAjaxBar/","text":"QAjaxBar \u00b6 import justpy as jp async def start_bar ( self , msg ): wp = msg . page await wp . ajax_bar . run_method ( 'start()' , msg . websocket ) async def stop_bar ( self , msg ): wp = msg . page await wp . ajax_bar . run_method ( 'stop()' , msg . websocket ) def bar_example (): wp = jp . QuasarPage () d = jp . Div ( classes = 'q-pa-md' , a = wp ) # temp=False is important because this generates an id for the element that is required for run_method to work wp . ajax_bar = jp . QAjaxBar ( position = 'bottom' , color = 'accent' , size = '10px' , skip_hijack = True , a = d , temp = False ) btn_start = jp . QBtn ( color = 'primary' , label = 'Start Bar' , a = d , click = start_bar , style = 'margin-right: 20px' ) btn_stop = jp . QBtn ( color = 'primary' , label = 'Stop Bar' , a = d , click = stop_bar ) return wp jp . justpy ( bar_example )","title":"QAjaxBar"},{"location":"quasar_tutorial/QAjaxBar/#qajaxbar","text":"import justpy as jp async def start_bar ( self , msg ): wp = msg . page await wp . ajax_bar . run_method ( 'start()' , msg . websocket ) async def stop_bar ( self , msg ): wp = msg . page await wp . ajax_bar . run_method ( 'stop()' , msg . websocket ) def bar_example (): wp = jp . QuasarPage () d = jp . Div ( classes = 'q-pa-md' , a = wp ) # temp=False is important because this generates an id for the element that is required for run_method to work wp . ajax_bar = jp . QAjaxBar ( position = 'bottom' , color = 'accent' , size = '10px' , skip_hijack = True , a = d , temp = False ) btn_start = jp . QBtn ( color = 'primary' , label = 'Start Bar' , a = d , click = start_bar , style = 'margin-right: 20px' ) btn_stop = jp . QBtn ( color = 'primary' , label = 'Stop Bar' , a = d , click = stop_bar ) return wp jp . justpy ( bar_example )","title":"QAjaxBar"},{"location":"quasar_tutorial/QBtnToggle/","text":"QBtnToggle \u00b6 QBtnToggle component is similar to a radio group but with buttons. import justpy as jp # Example from https://www.highcharts.com/docs/getting-started/your-first-chart my_chart_def = \"\"\" { chart: { type: 'bar' }, title: { text: 'Chart of Type Bar' }, xAxis: { categories: ['Apples', 'Bananas', 'Oranges'] }, yAxis: { title: { text: 'Fruit eaten' } }, series: [{ name: 'Jane', data: [1, 0, 4] }, { name: 'John', data: [5, 7, 3] }] } \"\"\" def button_change ( self , msg ): print ( msg ) self . chart . options . chart . type = self . value self . chart . options . title . text = f 'Chart of Type {self.value} ' def button_toggle_test (): wp = jp . QuasarPage () chart_type = jp . QBtnToggle ( toggle_color = 'red' , push = True , glossy = True , a = wp , input = button_change , value = 'bar' , classes = 'q-ma-md' ) for type in [ 'bar' , 'column' , 'line' , 'spline' ]: chart_type . options . append ({ 'label' : type . capitalize (), 'value' : type }) chart_type . chart = jp . HighCharts ( a = wp , classes = 'q-ma-lg' , options = my_chart_def ) return wp jp . justpy ( button_toggle_test )","title":"QBtnToggle"},{"location":"quasar_tutorial/QBtnToggle/#qbtntoggle","text":"QBtnToggle component is similar to a radio group but with buttons. import justpy as jp # Example from https://www.highcharts.com/docs/getting-started/your-first-chart my_chart_def = \"\"\" { chart: { type: 'bar' }, title: { text: 'Chart of Type Bar' }, xAxis: { categories: ['Apples', 'Bananas', 'Oranges'] }, yAxis: { title: { text: 'Fruit eaten' } }, series: [{ name: 'Jane', data: [1, 0, 4] }, { name: 'John', data: [5, 7, 3] }] } \"\"\" def button_change ( self , msg ): print ( msg ) self . chart . options . chart . type = self . value self . chart . options . title . text = f 'Chart of Type {self.value} ' def button_toggle_test (): wp = jp . QuasarPage () chart_type = jp . QBtnToggle ( toggle_color = 'red' , push = True , glossy = True , a = wp , input = button_change , value = 'bar' , classes = 'q-ma-md' ) for type in [ 'bar' , 'column' , 'line' , 'spline' ]: chart_type . options . append ({ 'label' : type . capitalize (), 'value' : type }) chart_type . chart = jp . HighCharts ( a = wp , classes = 'q-ma-lg' , options = my_chart_def ) return wp jp . justpy ( button_toggle_test )","title":"QBtnToggle"},{"location":"quasar_tutorial/QColor/","text":"QColor \u00b6 The Color Picker can be used to select colors. import justpy as jp def color_change ( self , msg ): self . div . style = f 'color: {self.value} ' def input_test (): wp = jp . QuasarPage ( data = { 'color' : '' }) in1 = jp . QInput ( filled = True , style = 'width: 400px' , a = wp , model = [ wp , 'color' ], classes = \"q-pa-md\" , input = color_change ) j = jp . parse_html ( \"\"\" <q-icon name=\"colorize\" class=\"cursor-pointer\"> <q-popup-proxy transition-show=\"scale\" transition-hide=\"scale\"> <q-color name=\"color_input\"/> </q-popup-proxy> </q-icon> \"\"\" ) in1 . add_scoped_slot ( 'append' , j ) color_input = j . name_dict [ 'color_input' ] color_input . model = [ wp , 'color' ] color_input . on ( 'change' , color_change ) in1 . div = jp . Div ( text = 'Change this text color using QInput above' , classes = \"q-pa-md text-h4\" , a = wp ) color_input . div = in1 . div return wp jp . justpy ( input_test )","title":"QColor"},{"location":"quasar_tutorial/QColor/#qcolor","text":"The Color Picker can be used to select colors. import justpy as jp def color_change ( self , msg ): self . div . style = f 'color: {self.value} ' def input_test (): wp = jp . QuasarPage ( data = { 'color' : '' }) in1 = jp . QInput ( filled = True , style = 'width: 400px' , a = wp , model = [ wp , 'color' ], classes = \"q-pa-md\" , input = color_change ) j = jp . parse_html ( \"\"\" <q-icon name=\"colorize\" class=\"cursor-pointer\"> <q-popup-proxy transition-show=\"scale\" transition-hide=\"scale\"> <q-color name=\"color_input\"/> </q-popup-proxy> </q-icon> \"\"\" ) in1 . add_scoped_slot ( 'append' , j ) color_input = j . name_dict [ 'color_input' ] color_input . model = [ wp , 'color' ] color_input . on ( 'change' , color_change ) in1 . div = jp . Div ( text = 'Change this text color using QInput above' , classes = \"q-pa-md text-h4\" , a = wp ) color_input . div = in1 . div return wp jp . justpy ( input_test )","title":"QColor"},{"location":"quasar_tutorial/QDate/","text":"QDate and QTime \u00b6 The Date Picker and Time Picker components can be used to input date and time. import justpy as jp html_string = \"\"\" <div class=\"q-pa-md\"> <div class=\"q-gutter-sm\"> <q-badge color=\"teal\" name=\"badge\" classes=\"text-h3\"/> <q-badge color=\"purple\" text-color=\"white\" class=\"q-ma-md\"> Mask: YYYY-MM-DD HH:mm </q-badge> </div> <div class=\"q-gutter-md row items-start\"> <q-date mask=\"YYYY-MM-DD HH:mm\" color=\"purple\" name=\"date\"/> <q-time mask=\"YYYY-MM-DD HH:mm\" color=\"purple\" name=\"time\"/> </div> </div> \"\"\" def date_time_test (): wp = jp . QuasarPage ( data = { 'date' : '2020-01-01 07:00' }) d = jp . parse_html ( html_string , a = wp ) for c in [ 'badge' , 'date' , 'time' ]: d . name_dict [ c ] . model = [ wp , 'date' ] return wp jp . justpy ( date_time_test ) Using Function Style Property \u00b6 In order to use a function-style property with QDate, the following is necessary: qd = jp . QDate () qd . events_date = \"(date) => {return date[9] %3 === 0}\" qd . evaluate_prop . append ( 'events' ) Note that the mapping of property names is a little bit tricky. In Quasar, the property is named QDate.events. Due to the fact that 'events' is a reserved property in JustPy, the property is called events_date in the Python domain. However the evaluate_prop list is only analyzed in the JS domain, where the property name is 'events'. Date and Time as QInput slots \u00b6 import justpy as jp # https://quasar.dev/vue-components/date#With-QInput def input_test (): wp = jp . QuasarPage ( data = { 'date' : '2019-02-01 12:44' }) in1 = jp . QInput ( filled = True , style = 'width: 400px' , a = wp , model = [ wp , 'date' ], classes = \"q-pa-md\" ) date_slot = jp . parse_html ( \"\"\" <q-icon name=\"event\" class=\"cursor-pointer\"> <q-popup-proxy transition-show=\"rotate\" transition-hide=\"rotate\"> <q-date mask=\"YYYY-MM-DD HH:mm\" name=\"date\"/> </q-popup-proxy> </q-icon> \"\"\" ) time_slot = jp . parse_html ( \"\"\" <q-icon name=\"access_time\" class=\"cursor-pointer\"> <q-popup-proxy transition-show=\"scale\" transition-hide=\"scale\"> <q-time mask=\"YYYY-MM-DD HH:mm\" format24h name=\"time\"/> </q-popup-proxy> </q-icon> \"\"\" ) date_slot . name_dict [ 'date' ] . model = [ wp , 'date' ] time_slot . name_dict [ 'time' ] . model = [ wp , 'date' ] in1 . prepend_slot = date_slot in1 . append_slot = time_slot return wp Or you can arrive at the same result by creating a reusable component: import justpy as jp # https://quasar.dev/vue-components/date#With-QInput class QInputDateTime ( jp . QInput ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . mask = '####-##-## ##:##' date_slot = jp . QIcon ( name = 'event' , classes = 'cursor-pointer' ) c2 = jp . QPopupProxy ( transition_show = 'scale' , transition_hide = 'scale' , a = date_slot ) self . date = jp . QDate ( mask = 'YYYY-MM-DD HH:mm' , name = 'date' , a = c2 ) time_slot = jp . QIcon ( name = 'access_time' , classes = 'cursor-pointer' ) c2 = jp . QPopupProxy ( transition_show = 'scale' , transition_hide = 'scale' , a = time_slot ) self . time = jp . QTime ( mask = 'YYYY-MM-DD HH:mm' , format24h = True , name = 'time' , a = c2 ) self . date . parent = self self . time . parent = self self . date . value = self . value self . time . value = self . value self . prepend_slot = date_slot self . append_slot = time_slot self . date . on ( 'input' , self . date_time_change ) self . time . on ( 'input' , self . date_time_change ) self . on ( 'input' , self . input_change ) @staticmethod def date_time_change ( self , msg ): print ( self . value ) self . parent . value = self . value self . parent . date . value = self . value self . parent . time . value = self . value @staticmethod def input_change ( self , msg ): self . date . value = self . value self . time . value = self . value def input_test (): wp = jp . QuasarPage () QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '' ) QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '2020-03-01 12:44' ) QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '2021-04-01 14:44' ) QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '2022-05-01 18:44' ) return wp jp . justpy ( input_test )","title":"QDate and QTime"},{"location":"quasar_tutorial/QDate/#qdate-and-qtime","text":"The Date Picker and Time Picker components can be used to input date and time. import justpy as jp html_string = \"\"\" <div class=\"q-pa-md\"> <div class=\"q-gutter-sm\"> <q-badge color=\"teal\" name=\"badge\" classes=\"text-h3\"/> <q-badge color=\"purple\" text-color=\"white\" class=\"q-ma-md\"> Mask: YYYY-MM-DD HH:mm </q-badge> </div> <div class=\"q-gutter-md row items-start\"> <q-date mask=\"YYYY-MM-DD HH:mm\" color=\"purple\" name=\"date\"/> <q-time mask=\"YYYY-MM-DD HH:mm\" color=\"purple\" name=\"time\"/> </div> </div> \"\"\" def date_time_test (): wp = jp . QuasarPage ( data = { 'date' : '2020-01-01 07:00' }) d = jp . parse_html ( html_string , a = wp ) for c in [ 'badge' , 'date' , 'time' ]: d . name_dict [ c ] . model = [ wp , 'date' ] return wp jp . justpy ( date_time_test )","title":"QDate and QTime"},{"location":"quasar_tutorial/QDate/#using-function-style-property","text":"In order to use a function-style property with QDate, the following is necessary: qd = jp . QDate () qd . events_date = \"(date) => {return date[9] %3 === 0}\" qd . evaluate_prop . append ( 'events' ) Note that the mapping of property names is a little bit tricky. In Quasar, the property is named QDate.events. Due to the fact that 'events' is a reserved property in JustPy, the property is called events_date in the Python domain. However the evaluate_prop list is only analyzed in the JS domain, where the property name is 'events'.","title":"Using Function Style Property"},{"location":"quasar_tutorial/QDate/#date-and-time-as-qinput-slots","text":"import justpy as jp # https://quasar.dev/vue-components/date#With-QInput def input_test (): wp = jp . QuasarPage ( data = { 'date' : '2019-02-01 12:44' }) in1 = jp . QInput ( filled = True , style = 'width: 400px' , a = wp , model = [ wp , 'date' ], classes = \"q-pa-md\" ) date_slot = jp . parse_html ( \"\"\" <q-icon name=\"event\" class=\"cursor-pointer\"> <q-popup-proxy transition-show=\"rotate\" transition-hide=\"rotate\"> <q-date mask=\"YYYY-MM-DD HH:mm\" name=\"date\"/> </q-popup-proxy> </q-icon> \"\"\" ) time_slot = jp . parse_html ( \"\"\" <q-icon name=\"access_time\" class=\"cursor-pointer\"> <q-popup-proxy transition-show=\"scale\" transition-hide=\"scale\"> <q-time mask=\"YYYY-MM-DD HH:mm\" format24h name=\"time\"/> </q-popup-proxy> </q-icon> \"\"\" ) date_slot . name_dict [ 'date' ] . model = [ wp , 'date' ] time_slot . name_dict [ 'time' ] . model = [ wp , 'date' ] in1 . prepend_slot = date_slot in1 . append_slot = time_slot return wp Or you can arrive at the same result by creating a reusable component: import justpy as jp # https://quasar.dev/vue-components/date#With-QInput class QInputDateTime ( jp . QInput ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . mask = '####-##-## ##:##' date_slot = jp . QIcon ( name = 'event' , classes = 'cursor-pointer' ) c2 = jp . QPopupProxy ( transition_show = 'scale' , transition_hide = 'scale' , a = date_slot ) self . date = jp . QDate ( mask = 'YYYY-MM-DD HH:mm' , name = 'date' , a = c2 ) time_slot = jp . QIcon ( name = 'access_time' , classes = 'cursor-pointer' ) c2 = jp . QPopupProxy ( transition_show = 'scale' , transition_hide = 'scale' , a = time_slot ) self . time = jp . QTime ( mask = 'YYYY-MM-DD HH:mm' , format24h = True , name = 'time' , a = c2 ) self . date . parent = self self . time . parent = self self . date . value = self . value self . time . value = self . value self . prepend_slot = date_slot self . append_slot = time_slot self . date . on ( 'input' , self . date_time_change ) self . time . on ( 'input' , self . date_time_change ) self . on ( 'input' , self . input_change ) @staticmethod def date_time_change ( self , msg ): print ( self . value ) self . parent . value = self . value self . parent . date . value = self . value self . parent . time . value = self . value @staticmethod def input_change ( self , msg ): self . date . value = self . value self . time . value = self . value def input_test (): wp = jp . QuasarPage () QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '' ) QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '2020-03-01 12:44' ) QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '2021-04-01 14:44' ) QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '2022-05-01 18:44' ) return wp jp . justpy ( input_test )","title":"Date and Time as QInput slots"},{"location":"quasar_tutorial/QDialog/","text":"QDialog \u00b6 Quasar provides a versatile QDialog component . Checkout the many options in the Quasar documentation. In the program below, two examples are implemented. When a Dialog is closed by the user, it generates an input event. The v-close-popup directive closes the dialog automatically when the associated button is clicked. Use v_close_popup in JustPy commands. import justpy as jp alert_dialog_html = \"\"\" <div class=\"q-pa-md q-gutter-sm\"> <q-btn label=\"Alert\" color=\"primary\" name=\"alert_button\" /> <q-dialog name=\"alert_dialog\" persistent> <q-card> <q-card-section> <div class=\"text-h6\">Alert</div> </q-card-section> <q-card-section> Lorem ipsum dolor sit amet consectetur adipisicing elit. Rerum repellendus sit voluptate voluptas eveniet porro. Rerum blanditiis perferendis totam, ea at omnis vel numquam exercitationem aut, natus minima, porro labore. </q-card-section> <q-card-actions align=\"right\"> <q-btn flat label=\"OK\" color=\"primary\" v-close-popup /> </q-card-actions> </q-card> </q-dialog> </div> \"\"\" seamless_dialog_html = \"\"\" <div class=\"q-pa-md q-gutter-sm\"> <q-btn label=\"Open seamless Dialog\" color=\"primary\" name=\"seamless_button\" /> <q-dialog seamless position=\"bottom\" name=\"seamless_dialog\"> <q-card style=\"width: 350px\"> <q-linear-progress :value=\"0.6\" color=\"pink\" /> <q-card-section class=\"row items-center no-wrap\"> <div> <div class=\"text-weight-bold\">The Walker</div> <div class=\"text-grey\">Fitz & The Tantrums</div> </div> <q-space /> <q-btn flat round icon=\"play_arrow\" /> <q-btn flat round icon=\"pause\" /> <q-btn flat round icon=\"close\" v-close-popup /> </q-card-section> </q-card> </q-dialog> </div> \"\"\" def open_dialog ( self , msg ): self . dialog . value = True def dialog_test (): wp = jp . QuasarPage () c = jp . parse_html ( alert_dialog_html , a = wp ) c . name_dict [ \"alert_button\" ] . dialog = c . name_dict [ \"alert_dialog\" ] c . name_dict [ \"alert_button\" ] . on ( 'click' , open_dialog ) c = jp . parse_html ( seamless_dialog_html , a = wp ) c . name_dict [ \"seamless_button\" ] . dialog = c . name_dict [ \"seamless_dialog\" ] c . name_dict [ \"seamless_button\" ] . on ( 'click' , open_dialog ) return wp jp . justpy ( dialog_test )","title":"QDialog"},{"location":"quasar_tutorial/QDialog/#qdialog","text":"Quasar provides a versatile QDialog component . Checkout the many options in the Quasar documentation. In the program below, two examples are implemented. When a Dialog is closed by the user, it generates an input event. The v-close-popup directive closes the dialog automatically when the associated button is clicked. Use v_close_popup in JustPy commands. import justpy as jp alert_dialog_html = \"\"\" <div class=\"q-pa-md q-gutter-sm\"> <q-btn label=\"Alert\" color=\"primary\" name=\"alert_button\" /> <q-dialog name=\"alert_dialog\" persistent> <q-card> <q-card-section> <div class=\"text-h6\">Alert</div> </q-card-section> <q-card-section> Lorem ipsum dolor sit amet consectetur adipisicing elit. Rerum repellendus sit voluptate voluptas eveniet porro. Rerum blanditiis perferendis totam, ea at omnis vel numquam exercitationem aut, natus minima, porro labore. </q-card-section> <q-card-actions align=\"right\"> <q-btn flat label=\"OK\" color=\"primary\" v-close-popup /> </q-card-actions> </q-card> </q-dialog> </div> \"\"\" seamless_dialog_html = \"\"\" <div class=\"q-pa-md q-gutter-sm\"> <q-btn label=\"Open seamless Dialog\" color=\"primary\" name=\"seamless_button\" /> <q-dialog seamless position=\"bottom\" name=\"seamless_dialog\"> <q-card style=\"width: 350px\"> <q-linear-progress :value=\"0.6\" color=\"pink\" /> <q-card-section class=\"row items-center no-wrap\"> <div> <div class=\"text-weight-bold\">The Walker</div> <div class=\"text-grey\">Fitz & The Tantrums</div> </div> <q-space /> <q-btn flat round icon=\"play_arrow\" /> <q-btn flat round icon=\"pause\" /> <q-btn flat round icon=\"close\" v-close-popup /> </q-card-section> </q-card> </q-dialog> </div> \"\"\" def open_dialog ( self , msg ): self . dialog . value = True def dialog_test (): wp = jp . QuasarPage () c = jp . parse_html ( alert_dialog_html , a = wp ) c . name_dict [ \"alert_button\" ] . dialog = c . name_dict [ \"alert_dialog\" ] c . name_dict [ \"alert_button\" ] . on ( 'click' , open_dialog ) c = jp . parse_html ( seamless_dialog_html , a = wp ) c . name_dict [ \"seamless_button\" ] . dialog = c . name_dict [ \"seamless_dialog\" ] c . name_dict [ \"seamless_button\" ] . on ( 'click' , open_dialog ) return wp jp . justpy ( dialog_test )","title":"QDialog"},{"location":"quasar_tutorial/QExpansionItem/","text":"QExpansionItem Examples \u00b6 Example 1 \u00b6 Three expansion items are defined in a loop. All three are added to a QList instance. Each expansion item includes a QCard with a QCardSection with text. import justpy as jp sample_text = \"\"\" Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quidem, eius reprehenderit eos corrupti commodi magni quaerat ex numquam, dolorum officiis modi facere maiores architecto suscipit iste eveniet doloribus ullam aliquid. \"\"\" def quasar_example (): wp = jp . QuasarPage () d = jp . Div ( classes = \"q-pa-md\" , style = \"max-width: 350px\" , a = wp ) item_list = jp . QList ( classes = \"rounded-borders\" , padding = True , bordered = True , a = d ) for info in [( \"perm_identity\" , \"Account settings\" ), ( \"signal_wifi_off\" , \"Wifi settings\" ), ( \"drafts\" , \"Drafts\" )]: expansion_item = jp . QExpansionItem ( icon = info [ 0 ], label = info [ 1 ], a = item_list , header_class = 'text-purple' , dense = True , dense_toggle = True , expand_separator = True ) card = jp . QCard ( a = expansion_item ) jp . QCardSection ( text = sample_text , a = card ) return wp jp . justpy ( quasar_example ) Example 2 \u00b6 In this example we define a custom component base on QExpansionItem. This component adds an image from the site Lorem Picsum to the expansion item and in addition formats the expansion item. import justpy as jp class My_expansion ( jp . QExpansionItem ): image_num = 10 # Start from image 10, previous are boring to my taste def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) outer_div = jp . Div ( classes = \"q-pa-md\" , a = self ) jp . QImg ( src = f 'https://picsum.photos/400/300/?image= {My_expansion.image_num} ' , a = outer_div ) self . icon = \"photo\" self . label = f 'Image {My_expansion.image_num} ' self . value = True self . expand_separator = True self . header_class = \"bg-teal text-white text-overline\" My_expansion . image_num += 1 def expansion_test ( request ): wp = jp . QuasarPage ( dark = False ) d = jp . Div ( classes = \"q-pa-md \" , style = \"max-width: 500px\" , a = wp ) jp . Link ( href = 'https://quasar.dev/vue-components/expansion-item' , text = 'Quasar Expansion Item Example' , target = '_blank' , classes = \"text-h5 q-mb-md\" , a = d , style = 'display: block;' ) add_btn = jp . QBtn ( label = 'Add Image' , classes = \"q-mb-md\" , color = 'primary' , a = d ) close_btn = jp . QBtn ( label = 'Close All' , classes = \"q-ml-md q-mb-md\" , color = 'negative' , a = d ) open_btn = jp . QBtn ( label = 'Open All' , classes = \"q-ml-md q-mb-md\" , color = 'positive' , a = d ) l = jp . QList ( bordered = True , a = d ) wp . list = l l . add_component ( My_expansion (), 0 ) def add_pic ( self , msg ): msg . page . list . add_component ( My_expansion (), 0 ) add_btn . on ( 'click' , add_pic ) def close_pics ( self , msg ): for c in msg . page . list . components : c . value = False close_btn . on ( 'click' , close_pics ) def open_pics ( self , msg ): for c in msg . page . list . components : c . value = True open_btn . on ( 'click' , open_pics ) return wp jp . justpy ( expansion_test )","title":"QExpansionItem"},{"location":"quasar_tutorial/QExpansionItem/#qexpansionitem-examples","text":"","title":"QExpansionItem Examples"},{"location":"quasar_tutorial/QExpansionItem/#example-1","text":"Three expansion items are defined in a loop. All three are added to a QList instance. Each expansion item includes a QCard with a QCardSection with text. import justpy as jp sample_text = \"\"\" Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quidem, eius reprehenderit eos corrupti commodi magni quaerat ex numquam, dolorum officiis modi facere maiores architecto suscipit iste eveniet doloribus ullam aliquid. \"\"\" def quasar_example (): wp = jp . QuasarPage () d = jp . Div ( classes = \"q-pa-md\" , style = \"max-width: 350px\" , a = wp ) item_list = jp . QList ( classes = \"rounded-borders\" , padding = True , bordered = True , a = d ) for info in [( \"perm_identity\" , \"Account settings\" ), ( \"signal_wifi_off\" , \"Wifi settings\" ), ( \"drafts\" , \"Drafts\" )]: expansion_item = jp . QExpansionItem ( icon = info [ 0 ], label = info [ 1 ], a = item_list , header_class = 'text-purple' , dense = True , dense_toggle = True , expand_separator = True ) card = jp . QCard ( a = expansion_item ) jp . QCardSection ( text = sample_text , a = card ) return wp jp . justpy ( quasar_example )","title":"Example 1"},{"location":"quasar_tutorial/QExpansionItem/#example-2","text":"In this example we define a custom component base on QExpansionItem. This component adds an image from the site Lorem Picsum to the expansion item and in addition formats the expansion item. import justpy as jp class My_expansion ( jp . QExpansionItem ): image_num = 10 # Start from image 10, previous are boring to my taste def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) outer_div = jp . Div ( classes = \"q-pa-md\" , a = self ) jp . QImg ( src = f 'https://picsum.photos/400/300/?image= {My_expansion.image_num} ' , a = outer_div ) self . icon = \"photo\" self . label = f 'Image {My_expansion.image_num} ' self . value = True self . expand_separator = True self . header_class = \"bg-teal text-white text-overline\" My_expansion . image_num += 1 def expansion_test ( request ): wp = jp . QuasarPage ( dark = False ) d = jp . Div ( classes = \"q-pa-md \" , style = \"max-width: 500px\" , a = wp ) jp . Link ( href = 'https://quasar.dev/vue-components/expansion-item' , text = 'Quasar Expansion Item Example' , target = '_blank' , classes = \"text-h5 q-mb-md\" , a = d , style = 'display: block;' ) add_btn = jp . QBtn ( label = 'Add Image' , classes = \"q-mb-md\" , color = 'primary' , a = d ) close_btn = jp . QBtn ( label = 'Close All' , classes = \"q-ml-md q-mb-md\" , color = 'negative' , a = d ) open_btn = jp . QBtn ( label = 'Open All' , classes = \"q-ml-md q-mb-md\" , color = 'positive' , a = d ) l = jp . QList ( bordered = True , a = d ) wp . list = l l . add_component ( My_expansion (), 0 ) def add_pic ( self , msg ): msg . page . list . add_component ( My_expansion (), 0 ) add_btn . on ( 'click' , add_pic ) def close_pics ( self , msg ): for c in msg . page . list . components : c . value = False close_btn . on ( 'click' , close_pics ) def open_pics ( self , msg ): for c in msg . page . list . components : c . value = True open_btn . on ( 'click' , open_pics ) return wp jp . justpy ( expansion_test )","title":"Example 2"},{"location":"quasar_tutorial/QInput/","text":"QInput \u00b6 Introduction \u00b6 The Quasar QInput component is very versatile and comes with many features and options. Almost all are supported by JustPy. QInput like Input creates an input event when its value changes. The program below puts on the page several QInput elements with different features. All are connected using the the same model attribute. import justpy as jp def input_test ( request ): wp = jp . QuasarPage ( data = { 'text' : '' }) c1 = jp . Div ( classes = 'q-pa-md' , a = wp ) c2 = jp . Div ( classes = 'q-gutter-md' , style = 'max-width: 300px' , a = c1 ) c3 = jp . QInput ( label = 'Standard' , a = c2 , model = [ wp , 'text' ]) c4 = jp . QInput ( filled = True , label = 'Filled' , a = c2 , model = [ wp , 'text' ]) c5 = jp . QInput ( outlined = True , label = 'Outlined' , a = c2 , model = [ wp , 'text' ]) c6 = jp . QInput ( standout = True , label = 'Standout' , a = c2 , model = [ wp , 'text' ]) c7 = jp . QInput ( standout = 'bg-teal text-white' , label = 'Custom standout' , a = c2 , model = [ wp , 'text' ]) c8 = jp . QInput ( borderless = True , label = 'Borderless' , a = c2 , model = [ wp , 'text' ]) c9 = jp . QInput ( rounded = True , filled = True , label = 'Rounded filled' , a = c2 , model = [ wp , 'text' ]) c10 = jp . QInput ( rounded = True , outlined = True , label = 'Rounded outlined' , a = c2 , model = [ wp , 'text' ]) c11 = jp . QInput ( rounded = True , standout = True , label = 'Rounded standout' , a = c2 , model = [ wp , 'text' ]) c12 = jp . QInput ( square = True , filled = True , label = 'Square filled' , hint = 'This is a hint' , a = c2 , model = [ wp , 'text' ]) c13 = jp . QInput ( square = True , outlined = True , label = 'Square outlined' , a = c2 , model = [ wp , 'text' ]) c14 = jp . QInput ( square = True , standout = True , label = 'Square standout' , a = c2 , model = [ wp , 'text' ]) return wp jp . justpy ( input_test ) Using Slots \u00b6 import justpy as jp def input_test ( request ): wp = jp . QuasarPage () c1 = jp . Div ( classes = 'q-pa-md' , a = wp ) c2 = jp . Div ( classes = 'q-gutter-md' , style = 'max-width: 300px' , a = c1 ) icon1 = jp . QIcon ( name = 'event' , color = 'blue' ) icon2 = jp . QIcon ( name = 'place' , color = 'red' ) for slot in [ 'append' , 'prepend' , 'before' ]: in1 = jp . QInput ( label = slot , filled = True , hint = f 'Icon is in slot \" {slot} \" and \"after\"' , a = c2 , after_slot = icon2 ) #in1.after_slot = icon2 # Alternative to keyword method used in line above setattr ( in1 , slot + '_slot' , icon1 ) return wp jp . justpy ( input_test ) Password Visibility Toggle Example \u00b6 import justpy as jp def input_test ( request ): wp = jp . QuasarPage () c1 = jp . Div ( classes = 'q-pa-md' , a = wp ) c2 = jp . Div ( classes = 'q-gutter-md' , style = 'max-width: 300px' , a = c1 ) password_input = jp . QInput ( filled = True , type = 'password' , a = c2 , hint = \"Password with toggle\" ) visibility_icon = jp . QIcon ( name = 'visibility_off' , classes = 'cursor-pointer' ) visibility_icon . password_input = password_input password_input . append_slot = visibility_icon def toggle_password ( self , msg ): if self . name == 'visibility_off' : self . name = 'visibility' self . password_input . type = 'text' else : self . name = 'visibility_off' self . password_input . type = 'password' visibility_icon . on ( 'click' , toggle_password ) return wp jp . justpy ( input_test ) Or better yet, as a reusable component import justpy as jp class PasswordWithToggle ( jp . QInput ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . type = 'password' visibility_icon = jp . QIcon ( name = 'visibility_off' , classes = 'cursor-pointer' ) visibility_icon . password_input = self self . append_slot = visibility_icon visibility_icon . on ( 'click' , self . toggle_password ) @staticmethod def toggle_password ( self , msg ): if self . name == 'visibility_off' : self . name = 'visibility' self . password_input . type = 'text' else : self . name = 'visibility_off' self . password_input . type = 'password' def input_test ( request ): wp = jp . QuasarPage ( data = { 'text' : '' }) c1 = jp . Div ( classes = 'q-pa-md' , a = wp ) c2 = jp . Div ( classes = 'q-gutter-md' , style = 'max-width: 300px' , a = c1 ) for i in range ( 1 , 6 ): PasswordWithToggle ( filled = True , type = 'password' , a = c2 , hint = f 'Password with toggle # {i} ' ) return wp jp . justpy ( input_test ) Input Masks \u00b6 import justpy as jp def input_test ( request ): wp = jp . QuasarPage ( data = { 'text' : '' }) c1 = jp . Div ( classes = 'q-pa-md' , a = wp ) c2 = jp . Div ( classes = 'q-gutter-md' , style = 'max-width: 300px' , a = c1 ) jp . QInput ( filled = True , label = 'Phone' , mask = '(###) ### - ####' , hint = \"Mask: (###) ### - ####\" , a = c2 ) return wp jp . justpy ( input_test ) Input Validation \u00b6 In the example below, a regular expression is used to validate a field as the user is typing (you of course may use instead any one of the available data validation packages). It uses QInput's error and error_message props. import justpy as jp import re email_regex = re . compile ( r \"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$)\" ) def input_change ( self , msg ): print ( self . value ) if re . match ( email_regex , self . value ): self . error = False else : self . error = True self . error_message = 'Enter valid email address' self . bottom_slots = True def input_test (): wp = jp . QuasarPage () in1 = jp . QInput ( label = 'Enter email' , style = 'width: 150px; margin: 20px' , a = wp , input = input_change ) return wp jp . justpy ( input_test ) You can also use QInput's internal validation prop rules . The prop needs to be a list that contains a string that represents JavaScript functions. See the examples in the Quasar documentation import justpy as jp def input_test (): wp = jp . QuasarPage () in1 = jp . QInput ( label = 'Enter email' , style = 'width: 150px; margin: 20px' , a = wp , lazy_rules = False ) in1 . rules = [ \"val => val.length <= 3 || 'Please use maximum 3 characters'\" ] return wp jp . justpy ( input_test ) QInputChange and QInputBlur - Disabling the Input Event \u00b6 In some cases the debounce feature may not be sufficient to provide a good user experience. This may happen when users type in bursts. Setting debounce to 1000 almost always solves these problems but there is another option if the large debounce is causing other issues. You can disable the input event altogether and capture the value of the QInput when it loses focus. You can control this yourself by setting the disable_input_event attribute to True or use the predefined QInputChange and QInputBlur components. QInputBlur will only update the value of the field when the component loses focus. QInputChange will update the value when the change event is fired. Both are very similar except that change will also fire when the Enter key is pressed and focus remains on the component. The regular QInput component generates an event each time a character is typed into the field. In some case this is not necessary and may put unwanted burden on the server. If you are not implementing a look ahead or validating the field on the server as the user is typing, it is preferable to use QInputChange and QInputBlur instead of QInput. import justpy as jp def my_blur(self, msg): self.div.text = self.value def input_demo(request): wp = jp.QuasarPage() c1 = jp.Div(classes='q-pa-md', a=wp) c2 = jp.Div(classes='q-gutter-md', style='max-width: 300px', a=c1) in1 = jp.QInputBlur(a=c2,placeholder='Please type here', label='QInputBlur') in1.div = jp.Div(text='What you type will show up here only when Input element loses focus', classes='text-h6', a=c2) in1.on('blur', my_blur) return wp jp.justpy(input_demo) Yahoo Stock Charts Example \u00b6 Warning You need to install the pandas-datareader package to run this example In the example below we define a component which simplifies entering dates. Click on the calendar icon of the QInput elements to have the a QDate element pop-up. Using a ticker and the dates provided by the user, data is retrieved from Yahoo and a chart is displayed. This is also an example of how you would change a Quasar button to the loading state while data is being retrieved. import justpy as jp from pandas_datareader import data as pdr import datetime import functools epoch = datetime . datetime ( 1970 , 1 , 1 ) grouping_units = [[ 'week' , [ 1 ]], [ 'month' , [ 1 , 2 , 3 , 4 , 6 ]]] chart_dict = { 'rangeSelector' : { 'selected' : 1 }, 'yAxis' : [ { 'labels' : { 'align' : 'right' , 'x' : - 3 }, 'title' : { 'text' : 'OHLC' }, 'height' : '60%' , 'lineWidth' : 2 , 'resize' : { 'enabled' : True }}, { 'labels' : { 'align' : 'right' , 'x' : - 3 }, 'title' : { 'text' : 'Volume' }, 'top' : '65%' , 'height' : '35%' , 'offset' : 0 , 'lineWidth' : 2 } ], 'tooltip' : { 'split' : True }, 'series' : [ { 'type' : 'candlestick' , 'tooltip' : { 'valueDecimals' : 2 }, 'dataGrouping' : { 'units' : grouping_units }}, { 'type' : 'column' , 'name' : 'Volume' , 'yAxis' : 1 , 'dataGrouping' : { 'units' : grouping_units }} ] } class QInputDate ( jp . QInput ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) date_slot = jp . QIcon ( name = 'event' , classes = 'cursor-pointer' ) c2 = jp . QPopupProxy ( transition_show = 'scale' , transition_hide = 'scale' , a = date_slot ) self . date = jp . QDate ( mask = 'YYYY-MM-DD' , name = 'date' , a = c2 ) self . date . parent = self self . date . value = self . value self . append_slot = date_slot self . date . on ( 'input' , self . date_time_change ) self . on ( 'input' , self . input_change ) self . proxy = c2 @staticmethod async def date_time_change ( self , msg ): self . parent . value = self . value self . parent . date . value = self . value await self . parent . proxy . run_method ( 'hide()' , msg . websocket ) @staticmethod def input_change ( self , msg ): self . date . value = self . value def convert_date ( date_string ): date = datetime . datetime . strptime ( str ( date_string ), '%Y-%m- %d ' ) return ( date - epoch ) . total_seconds () * 1000 async def get_chart ( self , msg ): self . loading = True await msg . page . update () data = await jp . JustPy . loop . run_in_executor ( None , functools . partial ( pdr . DataReader , data_source = 'yahoo' , start = self . start_date . value , end = self . end_date . value ), self . ticker . value ) data [ 'Date' ] = data . index . astype ( str ) chart = jp . HighStock ( a = msg . page , classes = 'q-ma-md' , options = chart_dict , style = 'height: 600px' ) o = chart . options ticker = self . ticker . value o . title . text = f ' {ticker} Historical Prices' x = list ( data [ 'Date' ] . map ( convert_date )) o . series [ 0 ] . data = list ( zip ( x , data [ 'Open' ], data [ 'High' ], data [ 'Low' ], data [ 'Close' ])) o . series [ 0 ] . name = ticker o . series [ 1 ] . data = list ( zip ( x , data [ 'Volume' ])) self . loading = False async def stock_test ( request ): wp = jp . QuasarPage ( highcharts_theme = 'grid' ) d = jp . Div ( classes = \"q-ma-md q-gutter-md row\" , a = wp ) ticker = jp . QInput ( label = 'Ticker' , a = d , value = 'MSFT' ) start_date = QInputDate ( a = d , label = 'Start Date' , standout = True , value = '2007-01-01' ) end_date = QInputDate ( a = d , label = 'End Date' , standout = True , value = '2019-12-31' ) b = jp . QBtn ( label = 'Get Chart' , a = d , start_date = start_date , end_date = end_date , ticker = ticker , click = get_chart , loading = False ) return wp jp . justpy ( stock_test )","title":"QInput"},{"location":"quasar_tutorial/QInput/#qinput","text":"","title":"QInput"},{"location":"quasar_tutorial/QInput/#introduction","text":"The Quasar QInput component is very versatile and comes with many features and options. Almost all are supported by JustPy. QInput like Input creates an input event when its value changes. The program below puts on the page several QInput elements with different features. All are connected using the the same model attribute. import justpy as jp def input_test ( request ): wp = jp . QuasarPage ( data = { 'text' : '' }) c1 = jp . Div ( classes = 'q-pa-md' , a = wp ) c2 = jp . Div ( classes = 'q-gutter-md' , style = 'max-width: 300px' , a = c1 ) c3 = jp . QInput ( label = 'Standard' , a = c2 , model = [ wp , 'text' ]) c4 = jp . QInput ( filled = True , label = 'Filled' , a = c2 , model = [ wp , 'text' ]) c5 = jp . QInput ( outlined = True , label = 'Outlined' , a = c2 , model = [ wp , 'text' ]) c6 = jp . QInput ( standout = True , label = 'Standout' , a = c2 , model = [ wp , 'text' ]) c7 = jp . QInput ( standout = 'bg-teal text-white' , label = 'Custom standout' , a = c2 , model = [ wp , 'text' ]) c8 = jp . QInput ( borderless = True , label = 'Borderless' , a = c2 , model = [ wp , 'text' ]) c9 = jp . QInput ( rounded = True , filled = True , label = 'Rounded filled' , a = c2 , model = [ wp , 'text' ]) c10 = jp . QInput ( rounded = True , outlined = True , label = 'Rounded outlined' , a = c2 , model = [ wp , 'text' ]) c11 = jp . QInput ( rounded = True , standout = True , label = 'Rounded standout' , a = c2 , model = [ wp , 'text' ]) c12 = jp . QInput ( square = True , filled = True , label = 'Square filled' , hint = 'This is a hint' , a = c2 , model = [ wp , 'text' ]) c13 = jp . QInput ( square = True , outlined = True , label = 'Square outlined' , a = c2 , model = [ wp , 'text' ]) c14 = jp . QInput ( square = True , standout = True , label = 'Square standout' , a = c2 , model = [ wp , 'text' ]) return wp jp . justpy ( input_test )","title":"Introduction"},{"location":"quasar_tutorial/QInput/#using-slots","text":"import justpy as jp def input_test ( request ): wp = jp . QuasarPage () c1 = jp . Div ( classes = 'q-pa-md' , a = wp ) c2 = jp . Div ( classes = 'q-gutter-md' , style = 'max-width: 300px' , a = c1 ) icon1 = jp . QIcon ( name = 'event' , color = 'blue' ) icon2 = jp . QIcon ( name = 'place' , color = 'red' ) for slot in [ 'append' , 'prepend' , 'before' ]: in1 = jp . QInput ( label = slot , filled = True , hint = f 'Icon is in slot \" {slot} \" and \"after\"' , a = c2 , after_slot = icon2 ) #in1.after_slot = icon2 # Alternative to keyword method used in line above setattr ( in1 , slot + '_slot' , icon1 ) return wp jp . justpy ( input_test )","title":"Using Slots"},{"location":"quasar_tutorial/QInput/#password-visibility-toggle-example","text":"import justpy as jp def input_test ( request ): wp = jp . QuasarPage () c1 = jp . Div ( classes = 'q-pa-md' , a = wp ) c2 = jp . Div ( classes = 'q-gutter-md' , style = 'max-width: 300px' , a = c1 ) password_input = jp . QInput ( filled = True , type = 'password' , a = c2 , hint = \"Password with toggle\" ) visibility_icon = jp . QIcon ( name = 'visibility_off' , classes = 'cursor-pointer' ) visibility_icon . password_input = password_input password_input . append_slot = visibility_icon def toggle_password ( self , msg ): if self . name == 'visibility_off' : self . name = 'visibility' self . password_input . type = 'text' else : self . name = 'visibility_off' self . password_input . type = 'password' visibility_icon . on ( 'click' , toggle_password ) return wp jp . justpy ( input_test ) Or better yet, as a reusable component import justpy as jp class PasswordWithToggle ( jp . QInput ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . type = 'password' visibility_icon = jp . QIcon ( name = 'visibility_off' , classes = 'cursor-pointer' ) visibility_icon . password_input = self self . append_slot = visibility_icon visibility_icon . on ( 'click' , self . toggle_password ) @staticmethod def toggle_password ( self , msg ): if self . name == 'visibility_off' : self . name = 'visibility' self . password_input . type = 'text' else : self . name = 'visibility_off' self . password_input . type = 'password' def input_test ( request ): wp = jp . QuasarPage ( data = { 'text' : '' }) c1 = jp . Div ( classes = 'q-pa-md' , a = wp ) c2 = jp . Div ( classes = 'q-gutter-md' , style = 'max-width: 300px' , a = c1 ) for i in range ( 1 , 6 ): PasswordWithToggle ( filled = True , type = 'password' , a = c2 , hint = f 'Password with toggle # {i} ' ) return wp jp . justpy ( input_test )","title":"Password Visibility Toggle Example"},{"location":"quasar_tutorial/QInput/#input-masks","text":"import justpy as jp def input_test ( request ): wp = jp . QuasarPage ( data = { 'text' : '' }) c1 = jp . Div ( classes = 'q-pa-md' , a = wp ) c2 = jp . Div ( classes = 'q-gutter-md' , style = 'max-width: 300px' , a = c1 ) jp . QInput ( filled = True , label = 'Phone' , mask = '(###) ### - ####' , hint = \"Mask: (###) ### - ####\" , a = c2 ) return wp jp . justpy ( input_test )","title":"Input Masks"},{"location":"quasar_tutorial/QInput/#input-validation","text":"In the example below, a regular expression is used to validate a field as the user is typing (you of course may use instead any one of the available data validation packages). It uses QInput's error and error_message props. import justpy as jp import re email_regex = re . compile ( r \"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$)\" ) def input_change ( self , msg ): print ( self . value ) if re . match ( email_regex , self . value ): self . error = False else : self . error = True self . error_message = 'Enter valid email address' self . bottom_slots = True def input_test (): wp = jp . QuasarPage () in1 = jp . QInput ( label = 'Enter email' , style = 'width: 150px; margin: 20px' , a = wp , input = input_change ) return wp jp . justpy ( input_test ) You can also use QInput's internal validation prop rules . The prop needs to be a list that contains a string that represents JavaScript functions. See the examples in the Quasar documentation import justpy as jp def input_test (): wp = jp . QuasarPage () in1 = jp . QInput ( label = 'Enter email' , style = 'width: 150px; margin: 20px' , a = wp , lazy_rules = False ) in1 . rules = [ \"val => val.length <= 3 || 'Please use maximum 3 characters'\" ] return wp jp . justpy ( input_test )","title":"Input Validation"},{"location":"quasar_tutorial/QInput/#qinputchange-and-qinputblur-disabling-the-input-event","text":"In some cases the debounce feature may not be sufficient to provide a good user experience. This may happen when users type in bursts. Setting debounce to 1000 almost always solves these problems but there is another option if the large debounce is causing other issues. You can disable the input event altogether and capture the value of the QInput when it loses focus. You can control this yourself by setting the disable_input_event attribute to True or use the predefined QInputChange and QInputBlur components. QInputBlur will only update the value of the field when the component loses focus. QInputChange will update the value when the change event is fired. Both are very similar except that change will also fire when the Enter key is pressed and focus remains on the component. The regular QInput component generates an event each time a character is typed into the field. In some case this is not necessary and may put unwanted burden on the server. If you are not implementing a look ahead or validating the field on the server as the user is typing, it is preferable to use QInputChange and QInputBlur instead of QInput. import justpy as jp def my_blur(self, msg): self.div.text = self.value def input_demo(request): wp = jp.QuasarPage() c1 = jp.Div(classes='q-pa-md', a=wp) c2 = jp.Div(classes='q-gutter-md', style='max-width: 300px', a=c1) in1 = jp.QInputBlur(a=c2,placeholder='Please type here', label='QInputBlur') in1.div = jp.Div(text='What you type will show up here only when Input element loses focus', classes='text-h6', a=c2) in1.on('blur', my_blur) return wp jp.justpy(input_demo)","title":"QInputChange and QInputBlur - Disabling the Input Event"},{"location":"quasar_tutorial/QInput/#yahoo-stock-charts-example","text":"Warning You need to install the pandas-datareader package to run this example In the example below we define a component which simplifies entering dates. Click on the calendar icon of the QInput elements to have the a QDate element pop-up. Using a ticker and the dates provided by the user, data is retrieved from Yahoo and a chart is displayed. This is also an example of how you would change a Quasar button to the loading state while data is being retrieved. import justpy as jp from pandas_datareader import data as pdr import datetime import functools epoch = datetime . datetime ( 1970 , 1 , 1 ) grouping_units = [[ 'week' , [ 1 ]], [ 'month' , [ 1 , 2 , 3 , 4 , 6 ]]] chart_dict = { 'rangeSelector' : { 'selected' : 1 }, 'yAxis' : [ { 'labels' : { 'align' : 'right' , 'x' : - 3 }, 'title' : { 'text' : 'OHLC' }, 'height' : '60%' , 'lineWidth' : 2 , 'resize' : { 'enabled' : True }}, { 'labels' : { 'align' : 'right' , 'x' : - 3 }, 'title' : { 'text' : 'Volume' }, 'top' : '65%' , 'height' : '35%' , 'offset' : 0 , 'lineWidth' : 2 } ], 'tooltip' : { 'split' : True }, 'series' : [ { 'type' : 'candlestick' , 'tooltip' : { 'valueDecimals' : 2 }, 'dataGrouping' : { 'units' : grouping_units }}, { 'type' : 'column' , 'name' : 'Volume' , 'yAxis' : 1 , 'dataGrouping' : { 'units' : grouping_units }} ] } class QInputDate ( jp . QInput ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) date_slot = jp . QIcon ( name = 'event' , classes = 'cursor-pointer' ) c2 = jp . QPopupProxy ( transition_show = 'scale' , transition_hide = 'scale' , a = date_slot ) self . date = jp . QDate ( mask = 'YYYY-MM-DD' , name = 'date' , a = c2 ) self . date . parent = self self . date . value = self . value self . append_slot = date_slot self . date . on ( 'input' , self . date_time_change ) self . on ( 'input' , self . input_change ) self . proxy = c2 @staticmethod async def date_time_change ( self , msg ): self . parent . value = self . value self . parent . date . value = self . value await self . parent . proxy . run_method ( 'hide()' , msg . websocket ) @staticmethod def input_change ( self , msg ): self . date . value = self . value def convert_date ( date_string ): date = datetime . datetime . strptime ( str ( date_string ), '%Y-%m- %d ' ) return ( date - epoch ) . total_seconds () * 1000 async def get_chart ( self , msg ): self . loading = True await msg . page . update () data = await jp . JustPy . loop . run_in_executor ( None , functools . partial ( pdr . DataReader , data_source = 'yahoo' , start = self . start_date . value , end = self . end_date . value ), self . ticker . value ) data [ 'Date' ] = data . index . astype ( str ) chart = jp . HighStock ( a = msg . page , classes = 'q-ma-md' , options = chart_dict , style = 'height: 600px' ) o = chart . options ticker = self . ticker . value o . title . text = f ' {ticker} Historical Prices' x = list ( data [ 'Date' ] . map ( convert_date )) o . series [ 0 ] . data = list ( zip ( x , data [ 'Open' ], data [ 'High' ], data [ 'Low' ], data [ 'Close' ])) o . series [ 0 ] . name = ticker o . series [ 1 ] . data = list ( zip ( x , data [ 'Volume' ])) self . loading = False async def stock_test ( request ): wp = jp . QuasarPage ( highcharts_theme = 'grid' ) d = jp . Div ( classes = \"q-ma-md q-gutter-md row\" , a = wp ) ticker = jp . QInput ( label = 'Ticker' , a = d , value = 'MSFT' ) start_date = QInputDate ( a = d , label = 'Start Date' , standout = True , value = '2007-01-01' ) end_date = QInputDate ( a = d , label = 'End Date' , standout = True , value = '2019-12-31' ) b = jp . QBtn ( label = 'Get Chart' , a = d , start_date = start_date , end_date = end_date , ticker = ticker , click = get_chart , loading = False ) return wp jp . justpy ( stock_test )","title":"Yahoo Stock Charts Example"},{"location":"quasar_tutorial/QList/","text":"QList and QItem \u00b6 Use the QList component to group items in a list. import justpy as jp def check_box_clicked ( self , msg ): wp = msg . page def my_filter ( var ): for letter in self . value : if var . startswith ( letter ): return True return False filtered_list = list ( filter ( my_filter , wp . list_item_text )) for c in wp . q_list . components : if c . components [ 0 ] . text not in filtered_list : c . show = False else : c . show = True def reactive_list_test (): wp = jp . QuasarPage () d = jp . Div ( classes = \"q-pa-md\" , style = \"max-width: 400px\" , a = wp ) wp . list_item_text = [ 'apple' , 'ad' , 'aardvark' , 'again' , 'bean' , 'bath' , 'beauty' , 'can' , 'corner' , 'capital' ] wp . q_list = jp . QList ( dense = True , bordered = True , padding = True , classes = \"rounded-borders\" , a = d ) for word in wp . list_item_text : q_item = jp . QItem ( clickable = True , v_ripple = True , a = wp . q_list ) jp . QItemSection ( text = word , a = q_item ) option_group = jp . QOptionGroup ( type = 'checkbox' , color = 'green' , a = d , input = check_box_clicked , value = [ 'a' , 'b' , 'c' ], inline = True , classes = 'q-ma-lg' , options = [{ 'label' : 'A words' , 'value' : 'a' }, { 'label' : 'B words' , 'value' : 'b' }, { 'label' : 'C words' , 'value' : 'c' }]) return wp jp . justpy ( reactive_list_test )","title":"QList"},{"location":"quasar_tutorial/QList/#qlist-and-qitem","text":"Use the QList component to group items in a list. import justpy as jp def check_box_clicked ( self , msg ): wp = msg . page def my_filter ( var ): for letter in self . value : if var . startswith ( letter ): return True return False filtered_list = list ( filter ( my_filter , wp . list_item_text )) for c in wp . q_list . components : if c . components [ 0 ] . text not in filtered_list : c . show = False else : c . show = True def reactive_list_test (): wp = jp . QuasarPage () d = jp . Div ( classes = \"q-pa-md\" , style = \"max-width: 400px\" , a = wp ) wp . list_item_text = [ 'apple' , 'ad' , 'aardvark' , 'again' , 'bean' , 'bath' , 'beauty' , 'can' , 'corner' , 'capital' ] wp . q_list = jp . QList ( dense = True , bordered = True , padding = True , classes = \"rounded-borders\" , a = d ) for word in wp . list_item_text : q_item = jp . QItem ( clickable = True , v_ripple = True , a = wp . q_list ) jp . QItemSection ( text = word , a = q_item ) option_group = jp . QOptionGroup ( type = 'checkbox' , color = 'green' , a = d , input = check_box_clicked , value = [ 'a' , 'b' , 'c' ], inline = True , classes = 'q-ma-lg' , options = [{ 'label' : 'A words' , 'value' : 'a' }, { 'label' : 'B words' , 'value' : 'b' }, { 'label' : 'C words' , 'value' : 'c' }]) return wp jp . justpy ( reactive_list_test )","title":"QList and QItem"},{"location":"quasar_tutorial/QOptionGroup/","text":"QOptionGroup \u00b6 Use the QOptionGroup component to group radio buttons, checkboxes or toggles. Use instead of QRadio always. In the example below, the type of the chart is based on the radio button selection. import justpy as jp # Example from https://www.highcharts.com/docs/getting-started/your-first-chart my_chart_def = \"\"\" { chart: { type: 'bar' }, title: { text: 'Chart of Type Bar' }, xAxis: { categories: ['Apples', 'Bananas', 'Oranges'] }, yAxis: { title: { text: 'Fruit eaten' } }, series: [{ name: 'Jane', data: [1, 0, 4] }, { name: 'John', data: [5, 7, 3] }] } \"\"\" def radio_change ( self , msg ): print ( msg ) self . chart . options . chart . type = self . value def option_group_test (): wp = jp . QuasarPage () chart_type = jp . QOptionGroup ( color = 'red' , a = wp , inline = True , input = radio_change , value = 'bar' ) for type in [ 'bar' , 'column' , 'line' , 'spline' ]: chart_type . options . append ({ 'label' : type . capitalize (), 'value' : type }) chart_type . chart = jp . HighCharts ( a = wp , classes = 'q-ma-lg' , options = my_chart_def ) return wp jp . justpy ( option_group_test )","title":"QOptionGroup"},{"location":"quasar_tutorial/QOptionGroup/#qoptiongroup","text":"Use the QOptionGroup component to group radio buttons, checkboxes or toggles. Use instead of QRadio always. In the example below, the type of the chart is based on the radio button selection. import justpy as jp # Example from https://www.highcharts.com/docs/getting-started/your-first-chart my_chart_def = \"\"\" { chart: { type: 'bar' }, title: { text: 'Chart of Type Bar' }, xAxis: { categories: ['Apples', 'Bananas', 'Oranges'] }, yAxis: { title: { text: 'Fruit eaten' } }, series: [{ name: 'Jane', data: [1, 0, 4] }, { name: 'John', data: [5, 7, 3] }] } \"\"\" def radio_change ( self , msg ): print ( msg ) self . chart . options . chart . type = self . value def option_group_test (): wp = jp . QuasarPage () chart_type = jp . QOptionGroup ( color = 'red' , a = wp , inline = True , input = radio_change , value = 'bar' ) for type in [ 'bar' , 'column' , 'line' , 'spline' ]: chart_type . options . append ({ 'label' : type . capitalize (), 'value' : type }) chart_type . chart = jp . HighCharts ( a = wp , classes = 'q-ma-lg' , options = my_chart_def ) return wp jp . justpy ( option_group_test )","title":"QOptionGroup"},{"location":"quasar_tutorial/QRating/","text":"QRating \u00b6 Quasar Rating is a Component which allows users to rate items. It generates an input event each time it is clicked with the value of the input being the rating. import justpy as jp def rating_test (): wp = jp . QuasarPage ( data = { 'rating' : 2 }) d = jp . Div ( classes = 'q-pa-md' , a = wp ) rating_div = jp . Div ( classes = 'q-gutter-y-md column' , a = d ) jp . QRating ( size = '1.5em' , icon = 'thumb_up' , a = rating_div , model = [ wp , 'rating' ]) jp . QRating ( size = '2em' , icon = 'favorite_border' , color = 'red-7' , a = rating_div , model = [ wp , 'rating' ]) jp . QRating ( size = '2.5em' , icon = 'create' , color = 'purple-4' , a = rating_div , model = [ wp , 'rating' ]) jp . QRating ( size = '3em' , icon = 'pets' , color = 'brown-5' , a = rating_div , model = [ wp , 'rating' ]) jp . QRating ( size = '4.5em' , icon = 'star_border' , color = 'green-5' , a = rating_div , model = [ wp , 'rating' ]) jp . QRating ( size = '5em' , icon = 'star_border' , icon_selected = 'star' , color = 'grey' , a = rating_div , model = [ wp , 'rating' ], color_selected = [ 'light-green-3' , 'light-green-6' , 'green' , 'green-9' , 'green-10' ]) jp . QRating ( size = '5em' , icon = 'star_border' , icon_selected = 'star' , color = 'green-5' , a = rating_div , model = [ wp , 'rating' ]) jp . QRating ( size = '3.5em' , max = 4 , color = 'red-5' , a = rating_div , model = [ wp , 'rating' ], icon = [ 'sentiment_very_dissatisfied' , 'sentiment_dissatisfied' , 'sentiment_satisfied' , 'sentiment_very_satisfied' ]) return wp jp . justpy ( rating_test ) With tooltips import justpy as jp def rating_test (): wp = jp . QuasarPage () wp . tailwind = True num_stars = 3 r = jp . QRating ( size = '2em' , max = num_stars , color = 'primary' , classes = 'm-2 p-2' , a = wp , value = 2 , debounce = 0 ) for i in range ( 1 , num_stars + 1 , 1 ): t = jp . QTooltip ( text = f ' {i} rating' ) r . add_scoped_slot ( f 'tip- {i} ' , t ) return wp jp . justpy ( rating_test )","title":"QRating"},{"location":"quasar_tutorial/QRating/#qrating","text":"Quasar Rating is a Component which allows users to rate items. It generates an input event each time it is clicked with the value of the input being the rating. import justpy as jp def rating_test (): wp = jp . QuasarPage ( data = { 'rating' : 2 }) d = jp . Div ( classes = 'q-pa-md' , a = wp ) rating_div = jp . Div ( classes = 'q-gutter-y-md column' , a = d ) jp . QRating ( size = '1.5em' , icon = 'thumb_up' , a = rating_div , model = [ wp , 'rating' ]) jp . QRating ( size = '2em' , icon = 'favorite_border' , color = 'red-7' , a = rating_div , model = [ wp , 'rating' ]) jp . QRating ( size = '2.5em' , icon = 'create' , color = 'purple-4' , a = rating_div , model = [ wp , 'rating' ]) jp . QRating ( size = '3em' , icon = 'pets' , color = 'brown-5' , a = rating_div , model = [ wp , 'rating' ]) jp . QRating ( size = '4.5em' , icon = 'star_border' , color = 'green-5' , a = rating_div , model = [ wp , 'rating' ]) jp . QRating ( size = '5em' , icon = 'star_border' , icon_selected = 'star' , color = 'grey' , a = rating_div , model = [ wp , 'rating' ], color_selected = [ 'light-green-3' , 'light-green-6' , 'green' , 'green-9' , 'green-10' ]) jp . QRating ( size = '5em' , icon = 'star_border' , icon_selected = 'star' , color = 'green-5' , a = rating_div , model = [ wp , 'rating' ]) jp . QRating ( size = '3.5em' , max = 4 , color = 'red-5' , a = rating_div , model = [ wp , 'rating' ], icon = [ 'sentiment_very_dissatisfied' , 'sentiment_dissatisfied' , 'sentiment_satisfied' , 'sentiment_very_satisfied' ]) return wp jp . justpy ( rating_test ) With tooltips import justpy as jp def rating_test (): wp = jp . QuasarPage () wp . tailwind = True num_stars = 3 r = jp . QRating ( size = '2em' , max = num_stars , color = 'primary' , classes = 'm-2 p-2' , a = wp , value = 2 , debounce = 0 ) for i in range ( 1 , num_stars + 1 , 1 ): t = jp . QTooltip ( text = f ' {i} rating' ) r . add_scoped_slot ( f 'tip- {i} ' , t ) return wp jp . justpy ( rating_test )","title":"QRating"},{"location":"quasar_tutorial/QSplitter/","text":"QSplitter \u00b6 The QSplitter component allows containers to be split vertically and/or horizontally through a draggable separator bar. This component has three scoped slots or slots for short: ['before_slot', 'after_slot', 'separator_slot'] QSplitter generates an input event when the the user changes the panes. In the example below change the the panes and see the value of the splitter refelected in the chip at the bottom of the page and in the avatar that was put in the separator_slot . import justpy as jp lorem = 'Lorem ipsum dolor sit, amet consectetur adipisicing elit. Quis praesentium cumque magnam odio iure quidem, quod illum numquam possimus obcaecati commodi minima assumenda consectetur culpa fuga nulla ullam. In, libero.' def splitter_test (): wp = jp . QuasarPage () before = jp . Div ( classes = 'q-pa-md' ) jp . Div ( text = 'Before' , classes = 'text-h4 q-mb-md' , a = before ) for i in range ( 20 ): jp . Div ( text = f ' {i} . {lorem} ' , a = before , classes = 'q-my-md' ) after = jp . Div ( classes = 'q-pa-md' ) jp . Div ( text = 'After' , classes = 'text-h4 q-mb-md' , a = after ) for i in range ( 20 ): jp . Div ( text = f ' {i} . {lorem} ' , a = after , classes = 'q-my-md' ) s = jp . QSplitter ( style = 'height: 400px' , a = wp , classes = 'q-ma-lg' ) s . separator_class = 'bg-orange' s . separator_style = 'width: 3px' s . before_slot = before s . after_slot = after chip = jp . QChip ( a = wp , classes = 'q-ma-lg' ) value_avatar = jp . QAvatar ( text = '50' , color = 'red' , text_color = 'white' , a = chip ) jp . Span ( text = 'Splitter value' , a = chip ) s . value_avatar = value_avatar def splitter_input ( self , msg ): self . value_avatar . text = int ( self . value ) s . on ( 'input' , splitter_input ) s . separator_slot = value_avatar return wp jp . justpy ( splitter_test )","title":"QSplitter"},{"location":"quasar_tutorial/QSplitter/#qsplitter","text":"The QSplitter component allows containers to be split vertically and/or horizontally through a draggable separator bar. This component has three scoped slots or slots for short: ['before_slot', 'after_slot', 'separator_slot'] QSplitter generates an input event when the the user changes the panes. In the example below change the the panes and see the value of the splitter refelected in the chip at the bottom of the page and in the avatar that was put in the separator_slot . import justpy as jp lorem = 'Lorem ipsum dolor sit, amet consectetur adipisicing elit. Quis praesentium cumque magnam odio iure quidem, quod illum numquam possimus obcaecati commodi minima assumenda consectetur culpa fuga nulla ullam. In, libero.' def splitter_test (): wp = jp . QuasarPage () before = jp . Div ( classes = 'q-pa-md' ) jp . Div ( text = 'Before' , classes = 'text-h4 q-mb-md' , a = before ) for i in range ( 20 ): jp . Div ( text = f ' {i} . {lorem} ' , a = before , classes = 'q-my-md' ) after = jp . Div ( classes = 'q-pa-md' ) jp . Div ( text = 'After' , classes = 'text-h4 q-mb-md' , a = after ) for i in range ( 20 ): jp . Div ( text = f ' {i} . {lorem} ' , a = after , classes = 'q-my-md' ) s = jp . QSplitter ( style = 'height: 400px' , a = wp , classes = 'q-ma-lg' ) s . separator_class = 'bg-orange' s . separator_style = 'width: 3px' s . before_slot = before s . after_slot = after chip = jp . QChip ( a = wp , classes = 'q-ma-lg' ) value_avatar = jp . QAvatar ( text = '50' , color = 'red' , text_color = 'white' , a = chip ) jp . Span ( text = 'Splitter value' , a = chip ) s . value_avatar = value_avatar def splitter_input ( self , msg ): self . value_avatar . text = int ( self . value ) s . on ( 'input' , splitter_input ) s . separator_slot = value_avatar return wp jp . justpy ( splitter_test )","title":"QSplitter"},{"location":"quasar_tutorial/QTree/","text":"QTree \u00b6 Quasars Qtree component allows displaying hierarchical data in a tree structure. import justpy as jp async def expand_tree ( self , msg ): return await self . tree . run_method ( 'expandAll()' , msg . websocket ) async def collapse_tree ( self , msg ): return await self . tree . run_method ( 'collapseAll()' , msg . websocket ) def tree_test (): wp = jp . QuasarPage () d = jp . Div ( classes = \"q-pa-md q-gutter-sm\" , a = wp ) node_string = \"\"\" [ { label: 'Satisfied customers (with avatar)', avatar: 'https://cdn.quasar.dev/img/boy-avatar.png', children: [ { label: 'Good food (with icon)', icon: 'restaurant_menu', children: [ { label: 'Quality ingredients', icon: 'favorite' }, { label: 'Good recipe' } ] }, { label: 'Good service (disabled node with icon)', icon: 'room_service', disabled: true, children: [ { label: 'Prompt attention' }, { label: 'Professional waiter' } ] }, { label: 'Pleasant surroundings (with icon)', icon: 'photo', children: [ { label: 'Happy atmosphere (with image)', img: 'https://cdn.quasar.dev/img/logo_calendar_128px.png' }, { label: 'Good table presentation' }, { label: 'Pleasing decor' } ] } ] } ] \"\"\" b1 = jp . QBtn ( label = 'Expand' , a = d , click = expand_tree ) b2 = jp . QBtn ( label = 'Collapse' , a = d , click = collapse_tree ) tree = jp . QTree ( a = d , node_key = 'label' , nodes = node_string , tick_strategy = \"leaf\" , no_connectors = False , default_expand_all = True ) d1 = jp . Div ( text = '' , a = d ) def my_updated ( self , msg ): print ( 'in my updated' ) d1 . text = str ( msg . value ) tree . on ( 'update:ticked' , my_updated ) b1 . tree = tree b2 . tree = tree return wp jp . justpy ( tree_test )","title":"QTree"},{"location":"quasar_tutorial/QTree/#qtree","text":"Quasars Qtree component allows displaying hierarchical data in a tree structure. import justpy as jp async def expand_tree ( self , msg ): return await self . tree . run_method ( 'expandAll()' , msg . websocket ) async def collapse_tree ( self , msg ): return await self . tree . run_method ( 'collapseAll()' , msg . websocket ) def tree_test (): wp = jp . QuasarPage () d = jp . Div ( classes = \"q-pa-md q-gutter-sm\" , a = wp ) node_string = \"\"\" [ { label: 'Satisfied customers (with avatar)', avatar: 'https://cdn.quasar.dev/img/boy-avatar.png', children: [ { label: 'Good food (with icon)', icon: 'restaurant_menu', children: [ { label: 'Quality ingredients', icon: 'favorite' }, { label: 'Good recipe' } ] }, { label: 'Good service (disabled node with icon)', icon: 'room_service', disabled: true, children: [ { label: 'Prompt attention' }, { label: 'Professional waiter' } ] }, { label: 'Pleasant surroundings (with icon)', icon: 'photo', children: [ { label: 'Happy atmosphere (with image)', img: 'https://cdn.quasar.dev/img/logo_calendar_128px.png' }, { label: 'Good table presentation' }, { label: 'Pleasing decor' } ] } ] } ] \"\"\" b1 = jp . QBtn ( label = 'Expand' , a = d , click = expand_tree ) b2 = jp . QBtn ( label = 'Collapse' , a = d , click = collapse_tree ) tree = jp . QTree ( a = d , node_key = 'label' , nodes = node_string , tick_strategy = \"leaf\" , no_connectors = False , default_expand_all = True ) d1 = jp . Div ( text = '' , a = d ) def my_updated ( self , msg ): print ( 'in my updated' ) d1 . text = str ( msg . value ) tree . on ( 'update:ticked' , my_updated ) b1 . tree = tree b2 . tree = tree return wp jp . justpy ( tree_test )","title":"QTree"},{"location":"quasar_tutorial/introduction/","text":"Quasar Introduction \u00b6 General \u00b6 Quasar is an MIT licensed open-source JavaScript framework that provides a comprehensive set of Vue.js components that follow the Material Guidelines . You can learn more about it here . JustPy supports most of the Quasar components and their features. In JustPy, Quasar components, just like HTML components, are Python classes. The Quasar documentation is excellent and includes many examples. You will need to consult it for the specifics of each component. As there are many Quasar components, I suggest browsing the documentation to see what is available. The name of the Quasar component and the JustPy component is the same. If the Quasar component is called QMenu for example, the corresponding JustPy class is called QMenu also. This guide/tutorial is far from complete and I will be adding examples to it over time. Warning Quasar uses its own classes to style elements on the page, so do not use Tailwind classes on Quasar pages unless you set the tailwind attribute to True .. Example \u00b6 The following example puts some Quasar buttons on the page and toggles their color and label when they are clicked. Also, clicking any button toggles the dark mode of the page. import justpy as jp import random async def my_click ( self , msg ): self . color = random . choice ([ 'primary' , 'secondary' , 'accent' , 'dark' , 'positive' , 'negative' , 'info' , 'warning' ]) self . label = self . color msg . page . dark = not msg . page . dark await msg . page . set_dark_mode ( msg . page . dark ) def quasar_example (): wp = jp . QuasarPage ( dark = True ) # Load page in dark mode d = jp . Div ( classes = 'q-pa-md q-gutter-sm' , a = wp ) jp . QBtn ( color = 'primary' , icon = 'mail' , label = 'On Left' , a = d , click = my_click ) jp . QBtn ( color = 'secondary' , icon_right = 'mail' , label = 'On Right' , a = d , click = my_click ) jp . QBtn ( color = 'red' , icon = 'mail' , icon_right = 'send' , label = 'On Left and Right' , a = d , click = my_click ) jp . Br ( a = d ) jp . QBtn ( icon = 'phone' , label = 'Stacked' , stack = True , glossy = True , color = 'purple' , a = d , click = my_click ) return wp jp . justpy ( quasar_example ) The program uses the JustPy QBtn component which is based on the Quasar QBtn component . Click the buttons and notice the ripple effect which is part of the Material specification. props of Quasar components \u00b6 The JustPy component usually supports all the Quasar component options (in the Quasar docs these are called props ). In JustPy these are designated by setting the attributes of the element. This can be done at creation using keywords or later using standard attribute assignment. Quasar props are in kebab case: icon-right In JustPy the attribute names are in snake case: icon_right If a quasar prop is set just by specifying it, in JustPy you set the corresponding attribute to True . For example, if a Quasar button is defined like this: < q-btn round color = \"primary\" icon = \"shopping_cart\" /> In JustPy it would look like this: import justpy as jp jp . QBtn ( round = True , color = 'primary' , icon = 'shopping_cart' ) # round is set to True Slots \u00b6 Quasar components have also slots in addition to props. JustPy supports most of the slots. Slots differ from attributes at they contain content in the form of an element as their value. In the example below we add an icon to several QInput slots. import justpy as jp def input_test ( request ): wp = jp . QuasarPage () c1 = jp . Div ( classes = 'q-pa-md' , a = wp ) c2 = jp . Div ( classes = 'q-gutter-md' , style = 'max-width: 300px' , a = c1 ) icon1 = jp . QIcon ( name = 'event' , color = 'blue' ) icon2 = jp . QIcon ( name = 'place' , color = 'red' ) for slot in [ 'append' , 'prepend' , 'before' ]: in1 = jp . QInput ( label = slot , filled = True , hint = f 'Icon is in slot \" {slot} \" and \"after\"' , a = c2 , after_slot = icon2 ) setattr ( in1 , slot + '_slot' , icon1 ) return wp jp . justpy ( input_test ) To insert content into a slot use the regular attribute assignment syntax. To insert element e in slot append of element in1 you could write: in1 . append_slot = e Just add '_slot' to the slot name and treat it as an instance attribute. Parsing Quasar Tags \u00b6 The JustPy parse_html function recognizes Quasar tags. This is convenient as it allows using examples in the Quasar documentation. The example below was taken from the QList documentation . The parsing function also generates the commands attribute which is a list of JutPy commands required to generate the HTML. In the example below we print these commands. import justpy as jp html_string = \"\"\" <div class=\"q-pa-md\" style=\"max-width: 350px\"> <q-list bordered> <q-item clickable v-ripple> <q-item-section avatar> <q-icon color=\"primary\" name=\"bluetooth\" /> </q-item-section> <q-item-section>Icon as avatar</q-item-section> </q-item> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar color=\"teal\" text-color=\"white\" icon=\"bluetooth\" /> </q-item-section> <q-item-section>Avatar-type icon</q-item-section> </q-item> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar rounded color=\"purple\" text-color=\"white\" icon=\"bluetooth\" /> </q-item-section> <q-item-section>Rounded avatar-type icon</q-item-section> </q-item> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar color=\"primary\" text-color=\"white\"> R </q-avatar> </q-item-section> <q-item-section>Letter avatar-type</q-item-section> </q-item> <q-separator /> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar> <img src=\"https://cdn.quasar.dev/img/boy-avatar.png\"> </q-avatar> </q-item-section> <q-item-section>Image avatar</q-item-section> </q-item> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar square> <img src=\"https://cdn.quasar.dev/img/boy-avatar.png\"> </q-avatar> </q-item-section> <q-item-section>Image square avatar</q-item-section> </q-item> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar rounded> <img src=\"https://cdn.quasar.dev/img/boy-avatar.png\"> </q-avatar> </q-item-section> <q-item-section>Image rounded avatar</q-item-section> </q-item> <q-separator /> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar rounded> <img src=\"https://cdn.quasar.dev/img/mountains.jpg\"> </q-avatar> </q-item-section> <q-item-section>List item</q-item-section> </q-item> <q-item clickable v-ripple> <q-item-section thumbnail> <img src=\"https://cdn.quasar.dev/img/mountains.jpg\"> </q-item-section> <q-item-section>List item</q-item-section> </q-item> </q-list> </div> \"\"\" def quasar_example (): wp = jp . QuasarPage () c = jp . parse_html ( html_string , a = wp ) for i in c . commands : print ( i ) return wp jp . justpy ( quasar_example ) Quasar Directives \u00b6 JustPy supports the following Quasar Vue directives: 'v-close-popup', 'v-close-menu', 'v-ripple', 'v-model', 'v-close-dialog' In JustPy the directives are specified in snake case: v_close_popup instead of v-close-popup Use QDiv instead of Div if you want to apply directives on an element. import justpy as jp def quasar_example (): wp = jp . QuasarPage () d = jp . Div ( classes = 'q-pa-md row justify-center' , a = wp ) jp . QDiv ( v_ripple = True , classes = 'relative-position flex flex-center text-white bg-primary' , style = 'border-radius: 3px; cursor: pointer; height: 150px; width: 80%;' , a = d , text = 'Click/tap me' ) return wp jp . justpy ( quasar_example ) The value of the directive can be a dictionary for configuring more options: import justpy as jp # https://quasar.dev/vue-directives/material-ripple#Ripple-API def ripple_test (): wp = jp . QuasarPage () d = jp . QDiv ( classes = \"q-pa-md q-gutter-md row justify-center\" , a = wp ) d1 = jp . QDiv ( v_ripple = { 'center' : True , 'color' : 'orange-5' }, classes = \"relative-position container bg-grey-3 text-black inline flex flex-center\" , text = 'center' , style = 'border-radius: 50%; cursor: pointer; width: 150px; height: 150px' , a = d ) return wp jp . justpy ( ripple_test ) Running Quasar Component Methods \u00b6 In order to run Quasar methods use the run_method method of the JustPy Quasar component. The following example runs the start() and stop() methods of QAjaxBar Warning You must set temp=False when the component is created because this generates an id for the element without which run_method will not work import justpy as jp async def start_bar ( self , msg ): wp = msg . page await wp . ajax_bar . run_method ( 'start()' , msg . websocket ) async def stop_bar ( self , msg ): wp = msg . page await wp . ajax_bar . run_method ( 'stop()' , msg . websocket ) def bar_example (): wp = jp . QuasarPage () d = jp . Div ( classes = 'q-pa-md' , a = wp ) # temp=False is important because this generates an id for the element that is required for run_method to work wp . ajax_bar = jp . QAjaxBar ( position = 'bottom' , color = 'accent' , size = '10px' , skip_hijack = True , a = d , temp = False ) btn_start = jp . QBtn ( color = 'primary' , label = 'Start Bar' , a = d , click = start_bar , style = 'margin-right: 20px' ) btn_stop = jp . QBtn ( color = 'primary' , label = 'Stop Bar' , a = d , click = stop_bar ) return wp jp . justpy ( bar_example )","title":"Introduction"},{"location":"quasar_tutorial/introduction/#quasar-introduction","text":"","title":"Quasar Introduction"},{"location":"quasar_tutorial/introduction/#general","text":"Quasar is an MIT licensed open-source JavaScript framework that provides a comprehensive set of Vue.js components that follow the Material Guidelines . You can learn more about it here . JustPy supports most of the Quasar components and their features. In JustPy, Quasar components, just like HTML components, are Python classes. The Quasar documentation is excellent and includes many examples. You will need to consult it for the specifics of each component. As there are many Quasar components, I suggest browsing the documentation to see what is available. The name of the Quasar component and the JustPy component is the same. If the Quasar component is called QMenu for example, the corresponding JustPy class is called QMenu also. This guide/tutorial is far from complete and I will be adding examples to it over time. Warning Quasar uses its own classes to style elements on the page, so do not use Tailwind classes on Quasar pages unless you set the tailwind attribute to True ..","title":"General"},{"location":"quasar_tutorial/introduction/#example","text":"The following example puts some Quasar buttons on the page and toggles their color and label when they are clicked. Also, clicking any button toggles the dark mode of the page. import justpy as jp import random async def my_click ( self , msg ): self . color = random . choice ([ 'primary' , 'secondary' , 'accent' , 'dark' , 'positive' , 'negative' , 'info' , 'warning' ]) self . label = self . color msg . page . dark = not msg . page . dark await msg . page . set_dark_mode ( msg . page . dark ) def quasar_example (): wp = jp . QuasarPage ( dark = True ) # Load page in dark mode d = jp . Div ( classes = 'q-pa-md q-gutter-sm' , a = wp ) jp . QBtn ( color = 'primary' , icon = 'mail' , label = 'On Left' , a = d , click = my_click ) jp . QBtn ( color = 'secondary' , icon_right = 'mail' , label = 'On Right' , a = d , click = my_click ) jp . QBtn ( color = 'red' , icon = 'mail' , icon_right = 'send' , label = 'On Left and Right' , a = d , click = my_click ) jp . Br ( a = d ) jp . QBtn ( icon = 'phone' , label = 'Stacked' , stack = True , glossy = True , color = 'purple' , a = d , click = my_click ) return wp jp . justpy ( quasar_example ) The program uses the JustPy QBtn component which is based on the Quasar QBtn component . Click the buttons and notice the ripple effect which is part of the Material specification.","title":"Example"},{"location":"quasar_tutorial/introduction/#props-of-quasar-components","text":"The JustPy component usually supports all the Quasar component options (in the Quasar docs these are called props ). In JustPy these are designated by setting the attributes of the element. This can be done at creation using keywords or later using standard attribute assignment. Quasar props are in kebab case: icon-right In JustPy the attribute names are in snake case: icon_right If a quasar prop is set just by specifying it, in JustPy you set the corresponding attribute to True . For example, if a Quasar button is defined like this: < q-btn round color = \"primary\" icon = \"shopping_cart\" /> In JustPy it would look like this: import justpy as jp jp . QBtn ( round = True , color = 'primary' , icon = 'shopping_cart' ) # round is set to True","title":"props of Quasar components"},{"location":"quasar_tutorial/introduction/#slots","text":"Quasar components have also slots in addition to props. JustPy supports most of the slots. Slots differ from attributes at they contain content in the form of an element as their value. In the example below we add an icon to several QInput slots. import justpy as jp def input_test ( request ): wp = jp . QuasarPage () c1 = jp . Div ( classes = 'q-pa-md' , a = wp ) c2 = jp . Div ( classes = 'q-gutter-md' , style = 'max-width: 300px' , a = c1 ) icon1 = jp . QIcon ( name = 'event' , color = 'blue' ) icon2 = jp . QIcon ( name = 'place' , color = 'red' ) for slot in [ 'append' , 'prepend' , 'before' ]: in1 = jp . QInput ( label = slot , filled = True , hint = f 'Icon is in slot \" {slot} \" and \"after\"' , a = c2 , after_slot = icon2 ) setattr ( in1 , slot + '_slot' , icon1 ) return wp jp . justpy ( input_test ) To insert content into a slot use the regular attribute assignment syntax. To insert element e in slot append of element in1 you could write: in1 . append_slot = e Just add '_slot' to the slot name and treat it as an instance attribute.","title":"Slots"},{"location":"quasar_tutorial/introduction/#parsing-quasar-tags","text":"The JustPy parse_html function recognizes Quasar tags. This is convenient as it allows using examples in the Quasar documentation. The example below was taken from the QList documentation . The parsing function also generates the commands attribute which is a list of JutPy commands required to generate the HTML. In the example below we print these commands. import justpy as jp html_string = \"\"\" <div class=\"q-pa-md\" style=\"max-width: 350px\"> <q-list bordered> <q-item clickable v-ripple> <q-item-section avatar> <q-icon color=\"primary\" name=\"bluetooth\" /> </q-item-section> <q-item-section>Icon as avatar</q-item-section> </q-item> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar color=\"teal\" text-color=\"white\" icon=\"bluetooth\" /> </q-item-section> <q-item-section>Avatar-type icon</q-item-section> </q-item> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar rounded color=\"purple\" text-color=\"white\" icon=\"bluetooth\" /> </q-item-section> <q-item-section>Rounded avatar-type icon</q-item-section> </q-item> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar color=\"primary\" text-color=\"white\"> R </q-avatar> </q-item-section> <q-item-section>Letter avatar-type</q-item-section> </q-item> <q-separator /> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar> <img src=\"https://cdn.quasar.dev/img/boy-avatar.png\"> </q-avatar> </q-item-section> <q-item-section>Image avatar</q-item-section> </q-item> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar square> <img src=\"https://cdn.quasar.dev/img/boy-avatar.png\"> </q-avatar> </q-item-section> <q-item-section>Image square avatar</q-item-section> </q-item> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar rounded> <img src=\"https://cdn.quasar.dev/img/boy-avatar.png\"> </q-avatar> </q-item-section> <q-item-section>Image rounded avatar</q-item-section> </q-item> <q-separator /> <q-item clickable v-ripple> <q-item-section avatar> <q-avatar rounded> <img src=\"https://cdn.quasar.dev/img/mountains.jpg\"> </q-avatar> </q-item-section> <q-item-section>List item</q-item-section> </q-item> <q-item clickable v-ripple> <q-item-section thumbnail> <img src=\"https://cdn.quasar.dev/img/mountains.jpg\"> </q-item-section> <q-item-section>List item</q-item-section> </q-item> </q-list> </div> \"\"\" def quasar_example (): wp = jp . QuasarPage () c = jp . parse_html ( html_string , a = wp ) for i in c . commands : print ( i ) return wp jp . justpy ( quasar_example )","title":"Parsing Quasar Tags"},{"location":"quasar_tutorial/introduction/#quasar-directives","text":"JustPy supports the following Quasar Vue directives: 'v-close-popup', 'v-close-menu', 'v-ripple', 'v-model', 'v-close-dialog' In JustPy the directives are specified in snake case: v_close_popup instead of v-close-popup Use QDiv instead of Div if you want to apply directives on an element. import justpy as jp def quasar_example (): wp = jp . QuasarPage () d = jp . Div ( classes = 'q-pa-md row justify-center' , a = wp ) jp . QDiv ( v_ripple = True , classes = 'relative-position flex flex-center text-white bg-primary' , style = 'border-radius: 3px; cursor: pointer; height: 150px; width: 80%;' , a = d , text = 'Click/tap me' ) return wp jp . justpy ( quasar_example ) The value of the directive can be a dictionary for configuring more options: import justpy as jp # https://quasar.dev/vue-directives/material-ripple#Ripple-API def ripple_test (): wp = jp . QuasarPage () d = jp . QDiv ( classes = \"q-pa-md q-gutter-md row justify-center\" , a = wp ) d1 = jp . QDiv ( v_ripple = { 'center' : True , 'color' : 'orange-5' }, classes = \"relative-position container bg-grey-3 text-black inline flex flex-center\" , text = 'center' , style = 'border-radius: 50%; cursor: pointer; width: 150px; height: 150px' , a = d ) return wp jp . justpy ( ripple_test )","title":"Quasar Directives"},{"location":"quasar_tutorial/introduction/#running-quasar-component-methods","text":"In order to run Quasar methods use the run_method method of the JustPy Quasar component. The following example runs the start() and stop() methods of QAjaxBar Warning You must set temp=False when the component is created because this generates an id for the element without which run_method will not work import justpy as jp async def start_bar ( self , msg ): wp = msg . page await wp . ajax_bar . run_method ( 'start()' , msg . websocket ) async def stop_bar ( self , msg ): wp = msg . page await wp . ajax_bar . run_method ( 'stop()' , msg . websocket ) def bar_example (): wp = jp . QuasarPage () d = jp . Div ( classes = 'q-pa-md' , a = wp ) # temp=False is important because this generates an id for the element that is required for run_method to work wp . ajax_bar = jp . QAjaxBar ( position = 'bottom' , color = 'accent' , size = '10px' , skip_hijack = True , a = d , temp = False ) btn_start = jp . QBtn ( color = 'primary' , label = 'Start Bar' , a = d , click = start_bar , style = 'margin-right: 20px' ) btn_stop = jp . QBtn ( color = 'primary' , label = 'Stop Bar' , a = d , click = stop_bar ) return wp jp . justpy ( bar_example )","title":"Running Quasar Component Methods"},{"location":"quasar_tutorial/not_working/","text":"Components not Working \u00b6 QPopupEdit \u00b6 It can be used but the 'save' and 'cancel' events are not propagating Components which use multiple panels \u00b6 QStepper, QTabPanels, QCarousel QRadio \u00b6 Use QOptionGroup instead","title":"Components not Working"},{"location":"quasar_tutorial/not_working/#components-not-working","text":"","title":"Components not Working"},{"location":"quasar_tutorial/not_working/#qpopupedit","text":"It can be used but the 'save' and 'cancel' events are not propagating","title":"QPopupEdit"},{"location":"quasar_tutorial/not_working/#components-which-use-multiple-panels","text":"QStepper, QTabPanels, QCarousel","title":"Components which use multiple panels"},{"location":"quasar_tutorial/not_working/#qradio","text":"Use QOptionGroup instead","title":"QRadio"},{"location":"quasar_tutorial/notify/","text":"Notifications \u00b6 Notification are created by a special component that does not wrap a quasar component but activates the quasar notify utility. Warning Add an 'after' event to any button that activates the notification that sets the notify attribute back to false. Otherwise, the notification will appear every update. Alternatively, await page update in event and then set notify to False . The following is based on this example in the Quasar documentation. import justpy as jp import datetime page_html = \"\"\" <div style=\"display: flex; align-items: center; justify-content: center; height: 100vh\"> <div class=\"q-pa-md q-gutter-y-sm column items-center\" > <div> <div class=\"row q-gutter-sm\"> <q-btn round size=\"sm\" color=\"secondary\" name=\"top-left\"> <q-icon name=\"arrow_back\" class=\"rotate-45\" /> </q-btn> <q-btn round size=\"sm\" color=\"accent\" name=\"top\"> <q-icon name=\"arrow_upward\" /> </q-btn> <q-btn round size=\"sm\" color=\"secondary\" name=\"top-right\"> <q-icon name=\"arrow_upward\" class=\"rotate-45\" /> </q-btn> </div> </div> <div> <div class=\"row q-gutter-sm\"> <div> <q-btn round size=\"sm\" color=\"accent\" name=\"left\"> <q-icon name=\"arrow_back\" /> </q-btn> </div> <div> <q-btn round size=\"sm\" color=\"accent\" name=\"center\"> <q-icon name=\"fullscreen_exit\" /> </q-btn> </div> <div> <q-btn round size=\"sm\" color=\"accent\" name=\"right\"> <q-icon name=\"arrow_forward\" /> </q-btn> </div> </div> </div> <div> <div class=\"row q-gutter-sm\"> <div> <q-btn round size=\"sm\" color=\"secondary\" name=\"bottom-left\"> <q-icon name=\"arrow_forward\" class=\"rotate-135\" /> </q-btn> </div> <div> <q-btn round size=\"sm\" color=\"accent\" name=\"bottom\"> <q-icon name=\"arrow_downward\" /> </q-btn> </div> <div> <q-btn round size=\"sm\" color=\"secondary\" name=\"bottom-right\"> <q-icon name=\"arrow_forward\" class=\"rotate-45\" /> </q-btn> </div> </div> </div> </div> </div> \"\"\" directions = [ 'top-left' , 'top' , 'top-right' , 'left' , 'center' , 'right' , 'bottom-left' , 'bottom' , 'bottom-right' ] def btn_click ( self , msg ): self . notification . notify = True self . notification . caption = f 'Time: {datetime.datetime.now().strftime(\"%H:%M:%S, %Y-%m- %d \")}' def btn_after ( self , msg ): self . notification . notify = False def notify_test (): wp = jp . QuasarPage () c = jp . parse_html ( page_html , a = wp ) for direction in directions : btn = c . name_dict [ direction ] btn . on ( 'click' , btn_click ) btn . on ( 'after' , btn_after ) btn . notification = jp . QNotify ( message = f 'Notification in/on {direction} ' , a = wp , position = direction , closeBtn = 'Close' ) return wp jp . justpy ( notify_test )","title":"Notifications"},{"location":"quasar_tutorial/notify/#notifications","text":"Notification are created by a special component that does not wrap a quasar component but activates the quasar notify utility. Warning Add an 'after' event to any button that activates the notification that sets the notify attribute back to false. Otherwise, the notification will appear every update. Alternatively, await page update in event and then set notify to False . The following is based on this example in the Quasar documentation. import justpy as jp import datetime page_html = \"\"\" <div style=\"display: flex; align-items: center; justify-content: center; height: 100vh\"> <div class=\"q-pa-md q-gutter-y-sm column items-center\" > <div> <div class=\"row q-gutter-sm\"> <q-btn round size=\"sm\" color=\"secondary\" name=\"top-left\"> <q-icon name=\"arrow_back\" class=\"rotate-45\" /> </q-btn> <q-btn round size=\"sm\" color=\"accent\" name=\"top\"> <q-icon name=\"arrow_upward\" /> </q-btn> <q-btn round size=\"sm\" color=\"secondary\" name=\"top-right\"> <q-icon name=\"arrow_upward\" class=\"rotate-45\" /> </q-btn> </div> </div> <div> <div class=\"row q-gutter-sm\"> <div> <q-btn round size=\"sm\" color=\"accent\" name=\"left\"> <q-icon name=\"arrow_back\" /> </q-btn> </div> <div> <q-btn round size=\"sm\" color=\"accent\" name=\"center\"> <q-icon name=\"fullscreen_exit\" /> </q-btn> </div> <div> <q-btn round size=\"sm\" color=\"accent\" name=\"right\"> <q-icon name=\"arrow_forward\" /> </q-btn> </div> </div> </div> <div> <div class=\"row q-gutter-sm\"> <div> <q-btn round size=\"sm\" color=\"secondary\" name=\"bottom-left\"> <q-icon name=\"arrow_forward\" class=\"rotate-135\" /> </q-btn> </div> <div> <q-btn round size=\"sm\" color=\"accent\" name=\"bottom\"> <q-icon name=\"arrow_downward\" /> </q-btn> </div> <div> <q-btn round size=\"sm\" color=\"secondary\" name=\"bottom-right\"> <q-icon name=\"arrow_forward\" class=\"rotate-45\" /> </q-btn> </div> </div> </div> </div> </div> \"\"\" directions = [ 'top-left' , 'top' , 'top-right' , 'left' , 'center' , 'right' , 'bottom-left' , 'bottom' , 'bottom-right' ] def btn_click ( self , msg ): self . notification . notify = True self . notification . caption = f 'Time: {datetime.datetime.now().strftime(\"%H:%M:%S, %Y-%m- %d \")}' def btn_after ( self , msg ): self . notification . notify = False def notify_test (): wp = jp . QuasarPage () c = jp . parse_html ( page_html , a = wp ) for direction in directions : btn = c . name_dict [ direction ] btn . on ( 'click' , btn_click ) btn . on ( 'after' , btn_after ) btn . notification = jp . QNotify ( message = f 'Notification in/on {direction} ' , a = wp , position = direction , closeBtn = 'Close' ) return wp jp . justpy ( notify_test )","title":"Notifications"},{"location":"reference/configuration/","text":"Configuration Variables \u00b6 Please read configuration in tutorial first for an overview of configuration. The variables below can be set in the justpy.env. The file needs to be located in the directory from which the program is run. See also configuration in tutorial config = Config ( 'justpy.env' ) # Determines if error is shown in browser when it occurs DEBUG = config ( 'DEBUG' , cast = bool , default = True ) # If set to True, the program terminates if there is an error in an event handler CRASH = config ( 'CRASH' , cast = bool , default = False ) # When True the console displays the memory taken by the program each time a browser tab closes so you check if memory is being reclaimed # It requires psutil to be installed MEMORY_DEBUG = config ( 'MEMORY_DEBUG' , cast = bool , default = False ) if MEMORY_DEBUG : import psutil # If not 0, the framework simulates a latency between the front end and backend when the program is run # This is useful in order to asses how latency will affect user experience. The value is the latency in milliseconds. LATENCY = config ( 'LATENCY' , cast = int , default = 0 ) if LATENCY : print ( f 'Simulating latency of {LATENCY} ms' ) # If True sessions are created SESSIONS = config ( 'SESSIONS' , cast = bool , default = True ) # The cookie name to use. Cookie only contains signed session id SESSION_COOKIE_NAME = config ( 'SESSION_COOKIE_NAME' , cast = str , default = 'jp_token' ) # The secret key is used to sign the session cookies SECRET_KEY = config ( 'SECRET_KEY' , default = '$$$my_secret_string$$$' ) # Make sure to change when deployed # The time the cookie is valid for COOKIE_MAX_AGE = config ( 'COOKIE_MAX_AGE' , cast = int , default = 60 * 60 * 24 * 7 ) # One week in seconds LOGGING_LEVEL = config ( 'LOGGING_LEVEL' , default = logging . WARNING ) HOST = config ( 'HOST' , cast = str , default = '127.0.0.1' ) PORT = config ( 'PORT' , cast = int , default = 8000 ) SSL_VERSION = config ( 'SSL_VERSION' , default = PROTOCOL_SSLv23 ) SSL_KEYFILE = config ( 'SSL_KEYFILE' , default = '' ) SSL_CERTFILE = config ( 'SSL_CERTFILE' , default = '' ) # current_dir is the directory of the module TEMPLATES_DIRECTORY = config ( 'TEMPLATES_DIRECTORY' , cast = str , default = current_dir + '/templates' ) STATIC_DIRECTORY = config ( 'STATIC_DIRECTORY' , cast = str , default = os . getcwd ()) STATIC_ROUTE = config ( 'STATIC_MOUNT' , cast = str , default = '/static' ) STATIC_NAME = config ( 'STATIC_NAME' , cast = str , default = 'static' ) FAVICON = config ( 'FAVICON' , cast = str , default = '' ) # If False gets value from https://elimintz.github.io/favicon.png TAILWIND = config ( 'TAILWIND' , cast = bool , default = True ) QUASAR = config ( 'QUASAR' , cast = bool , default = False ) # If none, latest version is loaded unless NO_INTERNET is Tru in which case the version that comes with the package is loaded QUASAR_VERSION = config ( 'QUASAR_VERSION' , cast = str , default = None ) HIGHCHARTS = config ( 'HIGHCHARTS' , cast = bool , default = True ) AGGRID = config ( 'AGGRID' , cast = bool , default = True ) AGGRID_ENTERPRISE = config ( 'AGGRID_ENTERPRISE' , cast = bool , default = False ) # Set to True for use with no access to the internet. All resources are loaded locally. # Set to False to load resources from CDN and work from latest version. NO_INTERNET = config ( 'NO_INTERNET' , cast = bool , default = True )","title":"Configuration Variables"},{"location":"reference/configuration/#configuration-variables","text":"Please read configuration in tutorial first for an overview of configuration. The variables below can be set in the justpy.env. The file needs to be located in the directory from which the program is run. See also configuration in tutorial config = Config ( 'justpy.env' ) # Determines if error is shown in browser when it occurs DEBUG = config ( 'DEBUG' , cast = bool , default = True ) # If set to True, the program terminates if there is an error in an event handler CRASH = config ( 'CRASH' , cast = bool , default = False ) # When True the console displays the memory taken by the program each time a browser tab closes so you check if memory is being reclaimed # It requires psutil to be installed MEMORY_DEBUG = config ( 'MEMORY_DEBUG' , cast = bool , default = False ) if MEMORY_DEBUG : import psutil # If not 0, the framework simulates a latency between the front end and backend when the program is run # This is useful in order to asses how latency will affect user experience. The value is the latency in milliseconds. LATENCY = config ( 'LATENCY' , cast = int , default = 0 ) if LATENCY : print ( f 'Simulating latency of {LATENCY} ms' ) # If True sessions are created SESSIONS = config ( 'SESSIONS' , cast = bool , default = True ) # The cookie name to use. Cookie only contains signed session id SESSION_COOKIE_NAME = config ( 'SESSION_COOKIE_NAME' , cast = str , default = 'jp_token' ) # The secret key is used to sign the session cookies SECRET_KEY = config ( 'SECRET_KEY' , default = '$$$my_secret_string$$$' ) # Make sure to change when deployed # The time the cookie is valid for COOKIE_MAX_AGE = config ( 'COOKIE_MAX_AGE' , cast = int , default = 60 * 60 * 24 * 7 ) # One week in seconds LOGGING_LEVEL = config ( 'LOGGING_LEVEL' , default = logging . WARNING ) HOST = config ( 'HOST' , cast = str , default = '127.0.0.1' ) PORT = config ( 'PORT' , cast = int , default = 8000 ) SSL_VERSION = config ( 'SSL_VERSION' , default = PROTOCOL_SSLv23 ) SSL_KEYFILE = config ( 'SSL_KEYFILE' , default = '' ) SSL_CERTFILE = config ( 'SSL_CERTFILE' , default = '' ) # current_dir is the directory of the module TEMPLATES_DIRECTORY = config ( 'TEMPLATES_DIRECTORY' , cast = str , default = current_dir + '/templates' ) STATIC_DIRECTORY = config ( 'STATIC_DIRECTORY' , cast = str , default = os . getcwd ()) STATIC_ROUTE = config ( 'STATIC_MOUNT' , cast = str , default = '/static' ) STATIC_NAME = config ( 'STATIC_NAME' , cast = str , default = 'static' ) FAVICON = config ( 'FAVICON' , cast = str , default = '' ) # If False gets value from https://elimintz.github.io/favicon.png TAILWIND = config ( 'TAILWIND' , cast = bool , default = True ) QUASAR = config ( 'QUASAR' , cast = bool , default = False ) # If none, latest version is loaded unless NO_INTERNET is Tru in which case the version that comes with the package is loaded QUASAR_VERSION = config ( 'QUASAR_VERSION' , cast = str , default = None ) HIGHCHARTS = config ( 'HIGHCHARTS' , cast = bool , default = True ) AGGRID = config ( 'AGGRID' , cast = bool , default = True ) AGGRID_ENTERPRISE = config ( 'AGGRID_ENTERPRISE' , cast = bool , default = False ) # Set to True for use with no access to the internet. All resources are loaded locally. # Set to False to load resources from CDN and work from latest version. NO_INTERNET = config ( 'NO_INTERNET' , cast = bool , default = True )","title":"Configuration Variables"},{"location":"reference/htmlcomponent/","text":"HTML Components \u00b6 Introduction \u00b6 In JustPy components are Python classes. All HTML components inherit from either the Div or Input component. The Input component itself inherits from the Div component. The reference will describe primarily the Div component and the Input component. It would be helpful to read the HTML Components chapter in the tutorial first. Div Component \u00b6 Introduction \u00b6 The Div component is the basic container component of JustPy. It is a component that can contain other components. It can of course, contain components that themselves are container components. Attributes \u00b6 General \u00b6 Attributes can be set as keywords when an element is created. import justpy as jp jp . Div ( text = 'hello' , classes = 'text-red-500' ) They can also be set anytime after the element is created (except for delete_flag which needs to be set at creation). import justpy as jp d = jp . Div () d . text = 'hello' d . classes = 'text-red-500' text \u00b6 Type: string Default: \"\" (the empty string) The text attribute will always be rendered as the first child of the component. If you want a Div (or any container component) instance to render multiple texts in different locations, encompass the text in another container component and add that component to the Div at the location you want. If you want to render an HTML Entity use the HTMLEntity component or set the html_enity attribute to True . import justpy as jp def entity_test (): wp = jp . WebPage () jp . Space ( num = 3 , a = wp ) jp . HTMLEntity ( entity = 'a&#768;' , a = wp , classes = 'text-lg' ) jp . Span ( text = 'a&#768;' , a = wp , classes = 'text-lg' , html_entity = True ) jp . Space ( num = 5 , a = wp ) jp . HTMLEntity ( entity = 'a&#769' , a = wp , classes = 'text-xl' ) jp . Span ( text = 'a&#769' , a = wp , classes = 'text-xl' , html_entity = True ) jp . Space ( num = 5 , a = wp ) jp . HTMLEntity ( entity = '&#8707;' , a = wp , classes = 'text-2xl' ) jp . Span ( text = '&#8707;' , a = wp , classes = 'text-2xl' , html_entity = True ) jp . Space ( num = 5 , a = wp ) jp . HTMLEntity ( entity = '&copy;' , a = wp , classes = 'text-3xl' ) jp . Span ( text = '&copy;' , a = wp , classes = 'text-3xl' , html_entity = True ) jp . Space ( num = 5 , a = wp ) return wp jp . justpy ( entity_test ) Info The Space component can be used to insert spaces. It creates a Span with num repeats of the html entity '&nbsp'. classes \u00b6 Type: string Default: \"\" (the empty string) The classes to attach to the element. Usually Tailwind classes, but may be any classes you define. Basically equivalent to the class attribute of HTML tags. import justpy as jp def classes_test (): wp = jp . WebPage () d = jp . Div ( text = 'Classes Example' , a = wp ) # Assign Tailwind classes to d d . classes = 'text-5xl text-white bg-blue-500 hover:bg-blue-700 m-2 p-2 w-64' return wp jp . justpy ( classes_test ) style \u00b6 Type: string Default: \"\" (the empty string) The CSS to attach to the element. Basically equivalent to the style attribute of HTML tags. import justpy as jp def style_test (): wp = jp . WebPage () for size in range ( 1 , 101 ): jp . Div ( text = f ' {size} ' , style = f 'font-size: {size} px; color: red' , a = wp , classes = 'inline cursor-pointer' , size = size , click = 'self.size *= 2; self.style=f\"font-size: {self.size} px; color: green\";' ) return wp jp . justpy ( style_test ) components \u00b6 Type: list Default: [] Holds the list of child elements in the Div. Strictly speaking these are not components, they are elements, instances of components. When the Div is rendered, the elements are rendered according to their place on the list, starting with the first. In the following example, the Div elements will show up in a different order each time the page is loaded because main_div.components is shuffled. import justpy as jp import random def shuffle_test (): wp = jp . WebPage () main_div = jp . Div ( classes = 'flex flex-wrap m-2 p-2 ' , a = wp ) for i in range ( 1 , 101 , 1 ): jp . Div ( text = f 'Div {i} ' , a = main_div , classes = 'm-2 p-2 text-xl text-white bg-blue-500' ) random . shuffle ( main_div . components ) return wp jp . justpy ( shuffle_test ) events \u00b6 Type: list Default: [] When an element is bound to an event, the event name (of type string) is added to events . You can use events to check which events the element will respond. Also, by removing an event name from the list, you will disable the element responding to that event. allowed_events \u00b6 Type: list Default: ['click', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave', 'input', 'change', 'after', 'before', 'keydown', 'keyup', 'keypress', 'focus', 'blur'] If an event name is not in allowed_events , JustPy will generate an error if you try to bind to that event. You can use the add_event method to add an allowed event to the list. additional_properties \u00b6 Type: list Default: [] JustPy does not pass all the JavaScript event properties by default since in most cases they are not needed. If you need additional properties from the JavasScript event, use the additional_properties attribute. In the example below, more fields are added to msg . import justpy as jp def my_click ( self , msg ): print ( msg ) self . text = 'I was clicked' def event_demo (): wp = jp . WebPage () wp . debug = True d = jp . Div ( text = 'Not clicked yet' , a = wp , classes = 'w-48 text-xl m-2 p-1 bg-blue-500 text-white' ) d . on ( 'click' , my_click ) d . additional_properties = [ 'screenX' , 'pageY' , 'altKey' , 'which' , 'movementX' , 'button' , 'buttons' ] return wp jp . justpy ( event_demo ) inner_html \u00b6 Type: string Default: \"\" (the empty string) Used to to set the HTML of an element directly. import justpy as jp def inner_html_test (): wp = jp . WebPage () for i in range ( 1 , 11 ): jp . Div ( inner_html = f '<span style=\"color: orange\"> {i} ) Hello!</span>' , a = wp , classes = 'm-2 p-2 text-3xl' ) return wp jp . justpy ( inner_html_test ) If inner_html is not the empty string, it will override any other content of the element show \u00b6 Type: boolean Default: True If set to False , the element is not rendered. See here set_focus \u00b6 Type: boolean Default: False If set to True , the element will have focus when the page is rendered. If multiple elements have the set_focus attribute set to True , the results will be unpredictable. The last element to be rendered by Vue will have focus. import justpy as jp # Try not using this event handler and see what happens def my_blur ( self , msg ): self . set_focus = False def focus_test (): wp = jp . WebPage () in1 = jp . Input ( classes = jp . Styles . input_classes , placeholder = 'Input 1' , a = wp , blur = my_blur ) in2 = jp . Input ( classes = jp . Styles . input_classes , placeholder = 'Input 2' , a = wp , blur = my_blur ) in3 = jp . Input ( classes = jp . Styles . input_classes , placeholder = 'Input 3' , a = wp , blur = my_blur ) in4 = jp . Input ( classes = jp . Styles . input_classes , placeholder = 'Input 4' , a = wp , blur = my_blur ) # Set focus on third Input element in3 . set_focus = True return wp jp . justpy ( focus_test ) children \u00b6 Type: list Default: [] When an element is created, can be used to create its children also. Useful if you like defining elements in a hierarchical way. New in version 0.10 import justpy as jp def children_test (): wp = jp . WebPage () div_classes = 'm-2 p-2 bg-blue-500 text-white text-lg' span_classes = 'm-2 p-2 bg-blue-500 text-yellow-700 text-xl' jp . Div ( children = [ jp . Div ( classes = div_classes , children = [ jp . Span ( text = 's1' , classes = span_classes ), jp . Span ( text = 's2' , classes = span_classes )]) , jp . Div ( text = 'd2' , classes = div_classes ), jp . Div ( text = 'd3' , classes = div_classes ), jp . Div ( text = 'd4' , classes = div_classes )], a = wp ) return wp jp . justpy ( children_test ) animation \u00b6 Type: string Default: \"\" (the empty string) Set the animation of the element. Uses animate.css Control the speed of the animation by adding classes: Class Name Speed Time slow 2s slower 3s fast 800ms faster 500ms For more information and additional options consult the animate.css documentation import justpy as jp import random input_classes = \"m-2 bg-gray-200 appearance-none border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" def animate ( self , msg ): self . d . delete_components () # remove all components from d directions = [ 'Up' , 'Down' , 'Left' , 'Right' ] html_entity = False for letter in self . text_to_animate . value : if letter == ' ' : letter = '&nbsp;' html_entity = True jp . Div ( animation = f 'fadeIn{random.choice(directions)}' , text = letter , html_entity = html_entity , classes = 'rounded-full bg-blue-500 text-white text-6xl' , a = self . d ) html_entity = False def animation_test (): wp = jp . WebPage () text_to_animate = jp . Input ( a = wp , classes = input_classes , placeholder = 'Enter text to animate' , value = 'Animation Demo!' , input = 'return True' ) animate_btn = jp . Button ( text = 'Animate!' , click = animate , classes = 'w-32 m-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded' , a = wp ) animate_btn . text_to_animate = text_to_animate d = jp . Div ( classes = 'flex items-center justify-center' , style = 'height: 500px' , a = wp ) animate_btn . d = d return wp jp . justpy ( animation_test ) id \u00b6 Type: string Default: Nothing assigned If you need to identify an element use the name attribute (or any other attribute you choose), NOT the id attribute. JustPy assigns a unique id to elements that are associated with events and uses it to identify which event handler to run. It is advised not to change an element's id or assign it an id delete_flag \u00b6 Type: boolean Default: True If set to False , element is not deleted when a page which it is on closes. In addition, non of its child components will be deleted. If you create an element that will be used on more than one page, set the value to False . event_propagation \u00b6 Type: boolean Default: True The current version of JustPy supports only event bubbling. Events originate in the innermost child and bubble up through the parents unless event_propagation is set to False . import justpy as jp def event_propagates (): wp = jp . WebPage () main_div = jp . Div ( classes = 'flex flex-wrap m-2 p-2 ' , a = wp , click = 'self.text=\"main div clicked\"' ) for i in range ( 1 , 10 ): jp . Div ( text = f 'Div {i} ' , a = main_div , classes = 'm-2 p-2 text-xl text-white bg-blue-500' , click = 'self.text=\"clicked\"' ) return wp @jp . SetRoute ( '/no_propagation' ) def event_does_not_propagate (): wp = jp . WebPage () main_div = jp . Div ( classes = 'flex flex-wrap m-2 p-2 ' , a = wp , click = 'self.text=\"main div clicked\"' ) for i in range ( 1 , 10 ): jp . Div ( text = f 'Div {i} ' , a = main_div , classes = 'm-2 p-2 text-xl text-white bg-blue-500' , event_propagation = False , click = 'self.text=\"clicked\"' ) return wp jp . justpy ( event_propagates ) vue_type \u00b6 Type: string Default: 'html_component' The Vue component to couple with the Python class. Used by the front end of the framework. If you change this, the component will not be rendered correctly When you develop components that require a Vue component as well, you will need to set this attribute in the Python class html_tag \u00b6 Type: string Default: 'div' The HTML tag that corresponds to the component. If you change it, the component may not render correctly. If you change this, the component may not be rendered correctly class_name \u00b6 Type: string Default: 'Div' The class (component) name of the element. Should be considered read only Global HTML attributes \u00b6 Div supports some HTML global attributes. Please review the Common Attributes section in the Tutorial. Methods \u00b6 def delete(self) Remove references to the object from JustPy internal data structures to allow garbage collection. def on(self, event_type, func) Bind a function to an event def remove_event(self, event_type) Remove and event from the element's allowed events def has_event_function(self, event_type) Returns True if the element has the specified event async def update(self) Updates just the element, not the whole page. The element is updated on all pages specified in the attribute pages . See Simple Message Board remove_page_from_pages(self, wp: WebPage) Remove a page from pages def add_page(self, wp: WebPage) and def add_page_to_pages(self, wp: WebPage) Add a page to pages def set_model(self, value) Set the model value async def run_event_function(self, event_type, event_data) Run an event function. This method takes two arguments in addition to self . The first is the event type. The second, is the dictionary we want passed as the second positional argument to the event handler. This is what we usually designate as msg in our event handler examples in the tutorial. See example here @staticmethod def convert_dict_to_object(d) Takes the dictionary created by convert_object_to_dict and returns an object. Can be used to make independent copies of objects. def __len__(self) len(c) returns the number of direct children the element c has def add_to_page(self, wp: WebPage) Adds the element to a page def add_attribute(self, attr, value) Adds an attribute that will be part of the dictionary created by convert_object_to_dict def add_event(self, event_type) and def add_allowed_event(self, event_type) Add an allowed event to the element def add_scoped_slot(self, slot, c) Relevant to Quasar and other Vue based frameworks or components. def to_html(self, indent=0, indent_step=0, format=True) Returns an HTML representation of the element def react(self, data) Executes just before the element is rendered. It is just pass for Div and is meant to be overridden by components that inherit from Div def convert_object_to_dict(self) Converts the element to a dictionary in the format the can be sent to the frontend to be rendered. def add_component(self, child, position=None, slot=None) Add a component at the specified position. def delete_components(self) Use to empty a container element like Div. Does not delete the text attribute def add(self, *args) Add all arguments as child elements after the current child elements def add_first(self, child) Add a child element before all other child elements def remove_component(self, component) Remove a child element def get_components(self) Get child elements as a list def first(self) Get first child element def last(self) Get last child element def model_update(self) Override as necessary. See example here","title":"HTML Components"},{"location":"reference/htmlcomponent/#html-components","text":"","title":"HTML Components"},{"location":"reference/htmlcomponent/#introduction","text":"In JustPy components are Python classes. All HTML components inherit from either the Div or Input component. The Input component itself inherits from the Div component. The reference will describe primarily the Div component and the Input component. It would be helpful to read the HTML Components chapter in the tutorial first.","title":"Introduction"},{"location":"reference/htmlcomponent/#div-component","text":"","title":"Div Component"},{"location":"reference/htmlcomponent/#introduction_1","text":"The Div component is the basic container component of JustPy. It is a component that can contain other components. It can of course, contain components that themselves are container components.","title":"Introduction"},{"location":"reference/htmlcomponent/#attributes","text":"","title":"Attributes"},{"location":"reference/htmlcomponent/#general","text":"Attributes can be set as keywords when an element is created. import justpy as jp jp . Div ( text = 'hello' , classes = 'text-red-500' ) They can also be set anytime after the element is created (except for delete_flag which needs to be set at creation). import justpy as jp d = jp . Div () d . text = 'hello' d . classes = 'text-red-500'","title":"General"},{"location":"reference/htmlcomponent/#text","text":"Type: string Default: \"\" (the empty string) The text attribute will always be rendered as the first child of the component. If you want a Div (or any container component) instance to render multiple texts in different locations, encompass the text in another container component and add that component to the Div at the location you want. If you want to render an HTML Entity use the HTMLEntity component or set the html_enity attribute to True . import justpy as jp def entity_test (): wp = jp . WebPage () jp . Space ( num = 3 , a = wp ) jp . HTMLEntity ( entity = 'a&#768;' , a = wp , classes = 'text-lg' ) jp . Span ( text = 'a&#768;' , a = wp , classes = 'text-lg' , html_entity = True ) jp . Space ( num = 5 , a = wp ) jp . HTMLEntity ( entity = 'a&#769' , a = wp , classes = 'text-xl' ) jp . Span ( text = 'a&#769' , a = wp , classes = 'text-xl' , html_entity = True ) jp . Space ( num = 5 , a = wp ) jp . HTMLEntity ( entity = '&#8707;' , a = wp , classes = 'text-2xl' ) jp . Span ( text = '&#8707;' , a = wp , classes = 'text-2xl' , html_entity = True ) jp . Space ( num = 5 , a = wp ) jp . HTMLEntity ( entity = '&copy;' , a = wp , classes = 'text-3xl' ) jp . Span ( text = '&copy;' , a = wp , classes = 'text-3xl' , html_entity = True ) jp . Space ( num = 5 , a = wp ) return wp jp . justpy ( entity_test ) Info The Space component can be used to insert spaces. It creates a Span with num repeats of the html entity '&nbsp'.","title":"text"},{"location":"reference/htmlcomponent/#classes","text":"Type: string Default: \"\" (the empty string) The classes to attach to the element. Usually Tailwind classes, but may be any classes you define. Basically equivalent to the class attribute of HTML tags. import justpy as jp def classes_test (): wp = jp . WebPage () d = jp . Div ( text = 'Classes Example' , a = wp ) # Assign Tailwind classes to d d . classes = 'text-5xl text-white bg-blue-500 hover:bg-blue-700 m-2 p-2 w-64' return wp jp . justpy ( classes_test )","title":"classes"},{"location":"reference/htmlcomponent/#style","text":"Type: string Default: \"\" (the empty string) The CSS to attach to the element. Basically equivalent to the style attribute of HTML tags. import justpy as jp def style_test (): wp = jp . WebPage () for size in range ( 1 , 101 ): jp . Div ( text = f ' {size} ' , style = f 'font-size: {size} px; color: red' , a = wp , classes = 'inline cursor-pointer' , size = size , click = 'self.size *= 2; self.style=f\"font-size: {self.size} px; color: green\";' ) return wp jp . justpy ( style_test )","title":"style"},{"location":"reference/htmlcomponent/#components","text":"Type: list Default: [] Holds the list of child elements in the Div. Strictly speaking these are not components, they are elements, instances of components. When the Div is rendered, the elements are rendered according to their place on the list, starting with the first. In the following example, the Div elements will show up in a different order each time the page is loaded because main_div.components is shuffled. import justpy as jp import random def shuffle_test (): wp = jp . WebPage () main_div = jp . Div ( classes = 'flex flex-wrap m-2 p-2 ' , a = wp ) for i in range ( 1 , 101 , 1 ): jp . Div ( text = f 'Div {i} ' , a = main_div , classes = 'm-2 p-2 text-xl text-white bg-blue-500' ) random . shuffle ( main_div . components ) return wp jp . justpy ( shuffle_test )","title":"components"},{"location":"reference/htmlcomponent/#events","text":"Type: list Default: [] When an element is bound to an event, the event name (of type string) is added to events . You can use events to check which events the element will respond. Also, by removing an event name from the list, you will disable the element responding to that event.","title":"events"},{"location":"reference/htmlcomponent/#allowed_events","text":"Type: list Default: ['click', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave', 'input', 'change', 'after', 'before', 'keydown', 'keyup', 'keypress', 'focus', 'blur'] If an event name is not in allowed_events , JustPy will generate an error if you try to bind to that event. You can use the add_event method to add an allowed event to the list.","title":"allowed_events"},{"location":"reference/htmlcomponent/#additional_properties","text":"Type: list Default: [] JustPy does not pass all the JavaScript event properties by default since in most cases they are not needed. If you need additional properties from the JavasScript event, use the additional_properties attribute. In the example below, more fields are added to msg . import justpy as jp def my_click ( self , msg ): print ( msg ) self . text = 'I was clicked' def event_demo (): wp = jp . WebPage () wp . debug = True d = jp . Div ( text = 'Not clicked yet' , a = wp , classes = 'w-48 text-xl m-2 p-1 bg-blue-500 text-white' ) d . on ( 'click' , my_click ) d . additional_properties = [ 'screenX' , 'pageY' , 'altKey' , 'which' , 'movementX' , 'button' , 'buttons' ] return wp jp . justpy ( event_demo )","title":"additional_properties"},{"location":"reference/htmlcomponent/#inner_html","text":"Type: string Default: \"\" (the empty string) Used to to set the HTML of an element directly. import justpy as jp def inner_html_test (): wp = jp . WebPage () for i in range ( 1 , 11 ): jp . Div ( inner_html = f '<span style=\"color: orange\"> {i} ) Hello!</span>' , a = wp , classes = 'm-2 p-2 text-3xl' ) return wp jp . justpy ( inner_html_test ) If inner_html is not the empty string, it will override any other content of the element","title":"inner_html"},{"location":"reference/htmlcomponent/#show","text":"Type: boolean Default: True If set to False , the element is not rendered. See here","title":"show"},{"location":"reference/htmlcomponent/#set_focus","text":"Type: boolean Default: False If set to True , the element will have focus when the page is rendered. If multiple elements have the set_focus attribute set to True , the results will be unpredictable. The last element to be rendered by Vue will have focus. import justpy as jp # Try not using this event handler and see what happens def my_blur ( self , msg ): self . set_focus = False def focus_test (): wp = jp . WebPage () in1 = jp . Input ( classes = jp . Styles . input_classes , placeholder = 'Input 1' , a = wp , blur = my_blur ) in2 = jp . Input ( classes = jp . Styles . input_classes , placeholder = 'Input 2' , a = wp , blur = my_blur ) in3 = jp . Input ( classes = jp . Styles . input_classes , placeholder = 'Input 3' , a = wp , blur = my_blur ) in4 = jp . Input ( classes = jp . Styles . input_classes , placeholder = 'Input 4' , a = wp , blur = my_blur ) # Set focus on third Input element in3 . set_focus = True return wp jp . justpy ( focus_test )","title":"set_focus"},{"location":"reference/htmlcomponent/#children","text":"Type: list Default: [] When an element is created, can be used to create its children also. Useful if you like defining elements in a hierarchical way. New in version 0.10 import justpy as jp def children_test (): wp = jp . WebPage () div_classes = 'm-2 p-2 bg-blue-500 text-white text-lg' span_classes = 'm-2 p-2 bg-blue-500 text-yellow-700 text-xl' jp . Div ( children = [ jp . Div ( classes = div_classes , children = [ jp . Span ( text = 's1' , classes = span_classes ), jp . Span ( text = 's2' , classes = span_classes )]) , jp . Div ( text = 'd2' , classes = div_classes ), jp . Div ( text = 'd3' , classes = div_classes ), jp . Div ( text = 'd4' , classes = div_classes )], a = wp ) return wp jp . justpy ( children_test )","title":"children"},{"location":"reference/htmlcomponent/#animation","text":"Type: string Default: \"\" (the empty string) Set the animation of the element. Uses animate.css Control the speed of the animation by adding classes: Class Name Speed Time slow 2s slower 3s fast 800ms faster 500ms For more information and additional options consult the animate.css documentation import justpy as jp import random input_classes = \"m-2 bg-gray-200 appearance-none border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" def animate ( self , msg ): self . d . delete_components () # remove all components from d directions = [ 'Up' , 'Down' , 'Left' , 'Right' ] html_entity = False for letter in self . text_to_animate . value : if letter == ' ' : letter = '&nbsp;' html_entity = True jp . Div ( animation = f 'fadeIn{random.choice(directions)}' , text = letter , html_entity = html_entity , classes = 'rounded-full bg-blue-500 text-white text-6xl' , a = self . d ) html_entity = False def animation_test (): wp = jp . WebPage () text_to_animate = jp . Input ( a = wp , classes = input_classes , placeholder = 'Enter text to animate' , value = 'Animation Demo!' , input = 'return True' ) animate_btn = jp . Button ( text = 'Animate!' , click = animate , classes = 'w-32 m-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded' , a = wp ) animate_btn . text_to_animate = text_to_animate d = jp . Div ( classes = 'flex items-center justify-center' , style = 'height: 500px' , a = wp ) animate_btn . d = d return wp jp . justpy ( animation_test )","title":"animation"},{"location":"reference/htmlcomponent/#id","text":"Type: string Default: Nothing assigned If you need to identify an element use the name attribute (or any other attribute you choose), NOT the id attribute. JustPy assigns a unique id to elements that are associated with events and uses it to identify which event handler to run. It is advised not to change an element's id or assign it an id","title":"id"},{"location":"reference/htmlcomponent/#delete_flag","text":"Type: boolean Default: True If set to False , element is not deleted when a page which it is on closes. In addition, non of its child components will be deleted. If you create an element that will be used on more than one page, set the value to False .","title":"delete_flag"},{"location":"reference/htmlcomponent/#event_propagation","text":"Type: boolean Default: True The current version of JustPy supports only event bubbling. Events originate in the innermost child and bubble up through the parents unless event_propagation is set to False . import justpy as jp def event_propagates (): wp = jp . WebPage () main_div = jp . Div ( classes = 'flex flex-wrap m-2 p-2 ' , a = wp , click = 'self.text=\"main div clicked\"' ) for i in range ( 1 , 10 ): jp . Div ( text = f 'Div {i} ' , a = main_div , classes = 'm-2 p-2 text-xl text-white bg-blue-500' , click = 'self.text=\"clicked\"' ) return wp @jp . SetRoute ( '/no_propagation' ) def event_does_not_propagate (): wp = jp . WebPage () main_div = jp . Div ( classes = 'flex flex-wrap m-2 p-2 ' , a = wp , click = 'self.text=\"main div clicked\"' ) for i in range ( 1 , 10 ): jp . Div ( text = f 'Div {i} ' , a = main_div , classes = 'm-2 p-2 text-xl text-white bg-blue-500' , event_propagation = False , click = 'self.text=\"clicked\"' ) return wp jp . justpy ( event_propagates )","title":"event_propagation"},{"location":"reference/htmlcomponent/#vue_type","text":"Type: string Default: 'html_component' The Vue component to couple with the Python class. Used by the front end of the framework. If you change this, the component will not be rendered correctly When you develop components that require a Vue component as well, you will need to set this attribute in the Python class","title":"vue_type"},{"location":"reference/htmlcomponent/#html_tag","text":"Type: string Default: 'div' The HTML tag that corresponds to the component. If you change it, the component may not render correctly. If you change this, the component may not be rendered correctly","title":"html_tag"},{"location":"reference/htmlcomponent/#class_name","text":"Type: string Default: 'Div' The class (component) name of the element. Should be considered read only","title":"class_name"},{"location":"reference/htmlcomponent/#global-html-attributes","text":"Div supports some HTML global attributes. Please review the Common Attributes section in the Tutorial.","title":"Global HTML attributes"},{"location":"reference/htmlcomponent/#methods","text":"def delete(self) Remove references to the object from JustPy internal data structures to allow garbage collection. def on(self, event_type, func) Bind a function to an event def remove_event(self, event_type) Remove and event from the element's allowed events def has_event_function(self, event_type) Returns True if the element has the specified event async def update(self) Updates just the element, not the whole page. The element is updated on all pages specified in the attribute pages . See Simple Message Board remove_page_from_pages(self, wp: WebPage) Remove a page from pages def add_page(self, wp: WebPage) and def add_page_to_pages(self, wp: WebPage) Add a page to pages def set_model(self, value) Set the model value async def run_event_function(self, event_type, event_data) Run an event function. This method takes two arguments in addition to self . The first is the event type. The second, is the dictionary we want passed as the second positional argument to the event handler. This is what we usually designate as msg in our event handler examples in the tutorial. See example here @staticmethod def convert_dict_to_object(d) Takes the dictionary created by convert_object_to_dict and returns an object. Can be used to make independent copies of objects. def __len__(self) len(c) returns the number of direct children the element c has def add_to_page(self, wp: WebPage) Adds the element to a page def add_attribute(self, attr, value) Adds an attribute that will be part of the dictionary created by convert_object_to_dict def add_event(self, event_type) and def add_allowed_event(self, event_type) Add an allowed event to the element def add_scoped_slot(self, slot, c) Relevant to Quasar and other Vue based frameworks or components. def to_html(self, indent=0, indent_step=0, format=True) Returns an HTML representation of the element def react(self, data) Executes just before the element is rendered. It is just pass for Div and is meant to be overridden by components that inherit from Div def convert_object_to_dict(self) Converts the element to a dictionary in the format the can be sent to the frontend to be rendered. def add_component(self, child, position=None, slot=None) Add a component at the specified position. def delete_components(self) Use to empty a container element like Div. Does not delete the text attribute def add(self, *args) Add all arguments as child elements after the current child elements def add_first(self, child) Add a child element before all other child elements def remove_component(self, component) Remove a child element def get_components(self) Get child elements as a list def first(self) Get first child element def last(self) Get last child element def model_update(self) Override as necessary. See example here","title":"Methods"},{"location":"reference/justpy/","text":"The justpy Command \u00b6 The justpy command starts the web sever and the async loop in which the application runs. Unless the justpy command is executed, no web pages will be served. No other command in the file after the justpy command will be executed (unless the start_server option is False ) so it should be the last command in the program file. def justpy(func=None, *, start_server=True, websockets=True, host=HOST, port=PORT, startup=None, **kwargs) func - Function to run if no route assigned functions are available. This is the default function to run if the URL is not recognized as a designated route. If no function is provided, the framework displays the 'Page not found' message. All other arguments are keyword arguments. start_server - If False , the uvicorn server is not started. Use this if you want to run the uvicorn server from the command line: uvicorn --host 0.0.0.0 --port 8000 test:app You need to explicitly specify the host and port (as well as any other uvicorn option you require) since the configuration file values are not used in this case. If test.py is your main program file where you import justpy then for the above to run you need to add the following line to it after importing justpy: app = jp . app # assuming import justpy as jp This exposes the starlette app to uvicorn. websockets - If False , all pages in the application will use Ajax instead of Websockets by default. host - Set to the configuration file HOST setting by default. If not specified in configuration file, it is `127.0.0.1' port - Set to the configuration file PORT setting by default. If not specified in configuration file, it is 8000 startup - The function to run before starting the web server. The async loop has already been started but the web server will not start until the function terminates. All other keyword arguments are used to set the template options. You can these also in the configuration file. template_options = { 'tailwind' : TAILWIND , 'quasar' : QUASAR , 'highcharts' : HIGHCHARTS , 'aggrid' : AGGRID , 'static_name' : STATIC_NAME } For example, if you don't want Highcharts to be loaded, set the keyword parameter highcharts to False .","title":"The justpy Command"},{"location":"reference/justpy/#the-justpy-command","text":"The justpy command starts the web sever and the async loop in which the application runs. Unless the justpy command is executed, no web pages will be served. No other command in the file after the justpy command will be executed (unless the start_server option is False ) so it should be the last command in the program file. def justpy(func=None, *, start_server=True, websockets=True, host=HOST, port=PORT, startup=None, **kwargs) func - Function to run if no route assigned functions are available. This is the default function to run if the URL is not recognized as a designated route. If no function is provided, the framework displays the 'Page not found' message. All other arguments are keyword arguments. start_server - If False , the uvicorn server is not started. Use this if you want to run the uvicorn server from the command line: uvicorn --host 0.0.0.0 --port 8000 test:app You need to explicitly specify the host and port (as well as any other uvicorn option you require) since the configuration file values are not used in this case. If test.py is your main program file where you import justpy then for the above to run you need to add the following line to it after importing justpy: app = jp . app # assuming import justpy as jp This exposes the starlette app to uvicorn. websockets - If False , all pages in the application will use Ajax instead of Websockets by default. host - Set to the configuration file HOST setting by default. If not specified in configuration file, it is `127.0.0.1' port - Set to the configuration file PORT setting by default. If not specified in configuration file, it is 8000 startup - The function to run before starting the web server. The async loop has already been started but the web server will not start until the function terminates. All other keyword arguments are used to set the template options. You can these also in the configuration file. template_options = { 'tailwind' : TAILWIND , 'quasar' : QUASAR , 'highcharts' : HIGHCHARTS , 'aggrid' : AGGRID , 'static_name' : STATIC_NAME } For example, if you don't want Highcharts to be loaded, set the keyword parameter highcharts to False .","title":"The justpy Command"},{"location":"reference/notes/","text":"Notes \u00b6 delete vs remove \u00b6 There is a difference between remove and delete. Remove is just basically: self.components.remove(component) It does not remove the component (an instance of a Python class) from memory, only from the list of components of some other component. Delete removes all references within JustPy to an instance so that the Python garbage collection can reclaim its memory. When you delete a component before removing it from its parent's component list, you remove all references to it from the internal JustPy data structures but a reference remains in its parent's component list. The framework automatically deletes all components on a page when a browser tab displaying the page is closed (unless the delete_flag is set to False). Alternatively, you can set their show attribute to False and then they will be deleted by the framework when the browser tab closes. If you remove an element from a page, and it closes later, it will not be deleted automatically. So you may first want to remove it and then delete it. In most use cases the memory leak is small so unless you have huge traffic you don't need to worry about deleting components until you see a problem emerging. The worst case is you need to restart the server more often. The delete method also deletes all components the component contains, therefore you don't need to delete them separately (again, unless a child component as the delete_flag set to False). Only components that the user interacts with or contain components that user interacts with need to deleted because otherwise the framework does not include any reference to them. The components that need deletion include components that explicitly have been assigned an event (like click for a button) or any component that has an input event to which the framework assigns an event even if the user does not (in order to update the value of the component on the server side in the before event handler).","title":"Notes"},{"location":"reference/notes/#notes","text":"","title":"Notes"},{"location":"reference/notes/#delete-vs-remove","text":"There is a difference between remove and delete. Remove is just basically: self.components.remove(component) It does not remove the component (an instance of a Python class) from memory, only from the list of components of some other component. Delete removes all references within JustPy to an instance so that the Python garbage collection can reclaim its memory. When you delete a component before removing it from its parent's component list, you remove all references to it from the internal JustPy data structures but a reference remains in its parent's component list. The framework automatically deletes all components on a page when a browser tab displaying the page is closed (unless the delete_flag is set to False). Alternatively, you can set their show attribute to False and then they will be deleted by the framework when the browser tab closes. If you remove an element from a page, and it closes later, it will not be deleted automatically. So you may first want to remove it and then delete it. In most use cases the memory leak is small so unless you have huge traffic you don't need to worry about deleting components until you see a problem emerging. The worst case is you need to restart the server more often. The delete method also deletes all components the component contains, therefore you don't need to delete them separately (again, unless a child component as the delete_flag set to False). Only components that the user interacts with or contain components that user interacts with need to deleted because otherwise the framework does not include any reference to them. The components that need deletion include components that explicitly have been assigned an event (like click for a button) or any component that has an input event to which the framework assigns an event even if the user does not (in order to update the value of the component on the server side in the before event handler).","title":"delete vs remove"},{"location":"reference/webpage/","text":"The WebPage Class \u00b6 The WebPage class is used to instantiate web pages. A JustPy request handler must always return an instance of this class or of a class that inherits from this class. Attributes \u00b6 components \u00b6 Type: list Default: [] List of components on the page. Only direct children are on the list. use_websockets \u00b6 Type: boolean Default: True Example: import justpy as jp wp = jp . WebPage () wp . use_websockets = False Disables Websockets and uses Ajax instead for the page. You can disable Websockets by default for all pages by setting the websockets keyword argument of justpy to False . examples delete_flag \u00b6 Type: boolean Default: True Usage: import justpy as jp wp = jp . WebPage () wp . delete_flag = False When delete_flag is False the WebPage instance is not deleted when the page closes. Furthermore, none of the elements on the page are deleted either. example highcharts_theme \u00b6 Type: string or None Default: None Sets the theme for the Higcharts charts on the page. Can be one of: ['avocado', 'dark-blue', 'dark-green', 'dark-unica', 'gray', 'grid-light', 'grid', 'high-contrast-dark', 'high-contrast-light', 'sand-signika', 'skies', 'sunset'] page_id \u00b6 Type: int Default: Automatically generated by JustPy When a WebPage instance is created (instantiated), an id is automatically generated for it. The id is the key in the dictionary that holds all WebPage s. When an event occurs in the browser, the id of the page is sent together with other information about the event. You usually do not need to use this attribute as the WebPage instance itself (along with the id) is provided to the event handlers. Do not change this attribute. template_file \u00b6 Type: string Default: 'tailwind.html' Can be either 'tailwind.html' or 'quasar.html'. title \u00b6 Type: string Default: JustPy The title of the page and the label on the browser tab. import justpy as jp input_classes = \"m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" async def input_demo ( request ): wp = jp . WebPage () def change_title_and_url ( self , msg ): msg . page . display_url = self . value msg . page . title = self . value in1 = jp . Input ( a = wp , classes = input_classes , placeholder = 'Type here to change title and url' , input = change_title_and_url ) return wp jp . justpy ( input_demo ) display_url \u00b6 Type: string Default: None The URL to display in the browser address, see example above. If None , url not set redirect \u00b6 Type: string Default: None Url to redirect to. If None , no redirection is attempted open \u00b6 Type: string Default: None Url to open in new tab. If None , False or the empty string, no new tab is opened. favicon \u00b6 Type: string Default: None Url to favicon. If None , False or the empty string, the default favicon is used. css \u00b6 Type: string Default: None CSS to inject into the page. The string is inserted in style tag in the head of the document. head_html and body_html \u00b6 Type: string Default: '' From version 0.0.7 A string of any extra HTML to put in the head section or body section of the template. Can be additional JavaScript for example. wp . head_html = \"\"\" <script src=\"/my_scripts.js\"></script> \"\"\" Simple example: import justpy as jp def test_head (): wp = jp . WebPage () wp . head_html = '<script>console.log(\"Hello there from head\");</script>' wp . body_html = '<script>console.log(\"Hello there from body\");</script>' jp . Div ( text = 'Testing...' , a = wp ) return wp jp . justpy ( test_head ) html \u00b6 Type: string Default: '' (the empty string) If not the empty string, overrides everything else and sets the HTML on the page to this value. body_style \u00b6 Type: string Default: '' (the empty string) Sets the style attribute for the body html element of the page body_classes \u00b6 Type: string Default: '' (the empty string) Sets the classes for the body html element of the page dark \u00b6 Type: boolean Default: False Only applicable currently with the Quasar pages. Set to true for Quasar's dark mode. data \u00b6 Type: dictionary Default: {} (the empty dictionary) See Tutorial link reload_interval \u00b6 Type: float Default: None See Tutorial link use_cache \u00b6 Type: boolean Default: False If True the rendering process does not call the page's build_list method and uses the value of the cache attribute instead. cache \u00b6 Place the cache content in this attribute Methods \u00b6 add_component(self, child, position=None) \u00b6 Adds a child component at the specified position. If position is None or not specified, adds component as the last child. add(self, *args) \u00b6 Adds all arguments as child elements at last position. remove_component(self, component) or remove(self, component) \u00b6 Removes a component from the page if it is there. If not, raises an exception. get_components(self) \u00b6 Returns a list of all the elements on the page. last(self) \u00b6 Returns the last element on the page ( self.components[-1] ) __len__(self) \u00b6 len(wp) returns the number of direct children elements the page has. delete_components(self) \u00b6 Deletes all the components on the page. This calls all the components' delete functions. This removes any reference to them from the internal JustPy data structures and allows garbage collection remove_page(self) \u00b6 Removes the reference to the page for the page directory. If there was no other reference to the page, the Python garbage collector will eventually reclaim the memory used by the page. to_html(self, indent=0, indent_step=0, format=True) \u00b6 Returns an HTML string representing the page. Set indent_step to an integer larger than 0 to make output human readable. build_list(self) \u00b6 This is the method JustPy calls to render the page. This method converts all elements on the page to dictionaries and creates a list with these dictionaries. The result of build_list is the input to the Vue app that renders the page in the browser. react(self) \u00b6 This method does nothing in the original class. It is is called by build_list just before the list is actually built. If you want to preform some action just before the page is rendered, write a new page class that inherits from WebPage and overrides react . async def update(self) \u00b6 This method updates all browser tabs that the page is rendered on. JustPy keeps track of all the websocket connections to the rendered pages and uses them to update the page. async def delayed_update(self, delay) \u00b6 Same as update but with a delay. The argument specifies the delay in seconds. on_disconnect(self, websocket=None) \u00b6 Override if you want to do something special when one of the tabs the page is rendered on closes. import justpy as jp class MyPage ( jp . WebPage ): async def on_disconnect ( self , websocket = None ): await super () . on_disconnect () # Do what you want to do on disconnect here print ( 'Page disconnected' ) def close_test (): wp = MyPage () for i in range ( 10 ): jp . Div ( text = f 'Div {i} ' , a = wp , classes = 'bg-blue-500 text-white m-2 p-2 w-32' ) return wp jp . justpy ( close_test ) async def run_javascript(self, javascript_string, request_id='', send=True) \u00b6 Runs JavaScript code on the page. The method has two keyword arguments: request_id : A user supplied identification for the run request. Can be used in combination with the result_ready page event to obtain the result of the computation send : By default, the result of the command is sent to the server. In some cases, you may need to execute a promise and handle sending to the server from within your code (see second example below). In those cases, set send to False to stop the result being sent twice. Simple example: import justpy as jp async def my_click ( self , msg ): await msg . page . run_javascript ( \"\"\" for (var i = 0; i<10; i++) { console.log('Line: ' + i); } \"\"\" ) def javascript_test (): wp = jp . WebPage () d = jp . Div ( a = wp , classes = 'm-2' ) b = jp . Button ( text = 'Run Script' , a = d , classes = jp . Styles . button_simple , click = my_click ) return wp jp . justpy ( javascript_test ) Getting the browser location: import justpy as jp javascript_string = \"\"\" var options = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }; function success(pos) { var crd = pos.coords; console.log('Your current position is:'); console.log(`Latitude : $ {crd.latitude} `); console.log(`Longitude: $ {crd.longitude} `); console.log(`More or less $ {crd.accuracy} meters.`); e.result = {latitude: crd.latitude, longitude: crd.longitude, accuracy: crd.accuracy}; send_to_server(e, 'page_event', false); } function error(err) { console.warn(`ERROR($ {err.code} ): $ {err.message} `); e.result = 'Error'; send_to_server(e, 'page_event', false); } navigator.geolocation.getCurrentPosition(success, error, options); \"\"\" async def result_ready ( self , msg ): if msg . request_id == 'geo_location' : msg . page . add ( jp . Div ( text = f 'longitude: {msg.result.longitude} Latitude: {msg.result.latitude} Accuracy: {msg.result.accuracy} ' , classes = 'm-2 p-2 text-lg border' )) async def page_ready ( self , msg ): jp . run_task ( self . run_javascript ( javascript_string , request_id = 'geo_location' , send = False )) def result_ready_test (): wp = jp . WebPage () wp . on ( 'page_ready' , page_ready ) wp . on ( 'result_ready' , result_ready ) # Some arbitrary content wp . d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for i in range ( 1 , 31 ): jp . Div ( text = f 'Div {i} ' , a = wp . d , classes = 'border m-2 p-2 text-xs' ) return wp jp . justpy ( result_ready_test ) async def reload(self) \u00b6 Forces a page reload. await wp . reload ()","title":"WebPage class"},{"location":"reference/webpage/#the-webpage-class","text":"The WebPage class is used to instantiate web pages. A JustPy request handler must always return an instance of this class or of a class that inherits from this class.","title":"The WebPage Class"},{"location":"reference/webpage/#attributes","text":"","title":"Attributes"},{"location":"reference/webpage/#components","text":"Type: list Default: [] List of components on the page. Only direct children are on the list.","title":"components"},{"location":"reference/webpage/#use_websockets","text":"Type: boolean Default: True Example: import justpy as jp wp = jp . WebPage () wp . use_websockets = False Disables Websockets and uses Ajax instead for the page. You can disable Websockets by default for all pages by setting the websockets keyword argument of justpy to False . examples","title":"use_websockets"},{"location":"reference/webpage/#delete_flag","text":"Type: boolean Default: True Usage: import justpy as jp wp = jp . WebPage () wp . delete_flag = False When delete_flag is False the WebPage instance is not deleted when the page closes. Furthermore, none of the elements on the page are deleted either. example","title":"delete_flag"},{"location":"reference/webpage/#highcharts_theme","text":"Type: string or None Default: None Sets the theme for the Higcharts charts on the page. Can be one of: ['avocado', 'dark-blue', 'dark-green', 'dark-unica', 'gray', 'grid-light', 'grid', 'high-contrast-dark', 'high-contrast-light', 'sand-signika', 'skies', 'sunset']","title":"highcharts_theme"},{"location":"reference/webpage/#page_id","text":"Type: int Default: Automatically generated by JustPy When a WebPage instance is created (instantiated), an id is automatically generated for it. The id is the key in the dictionary that holds all WebPage s. When an event occurs in the browser, the id of the page is sent together with other information about the event. You usually do not need to use this attribute as the WebPage instance itself (along with the id) is provided to the event handlers. Do not change this attribute.","title":"page_id"},{"location":"reference/webpage/#template_file","text":"Type: string Default: 'tailwind.html' Can be either 'tailwind.html' or 'quasar.html'.","title":"template_file"},{"location":"reference/webpage/#title","text":"Type: string Default: JustPy The title of the page and the label on the browser tab. import justpy as jp input_classes = \"m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" async def input_demo ( request ): wp = jp . WebPage () def change_title_and_url ( self , msg ): msg . page . display_url = self . value msg . page . title = self . value in1 = jp . Input ( a = wp , classes = input_classes , placeholder = 'Type here to change title and url' , input = change_title_and_url ) return wp jp . justpy ( input_demo )","title":"title"},{"location":"reference/webpage/#display_url","text":"Type: string Default: None The URL to display in the browser address, see example above. If None , url not set","title":"display_url"},{"location":"reference/webpage/#redirect","text":"Type: string Default: None Url to redirect to. If None , no redirection is attempted","title":"redirect"},{"location":"reference/webpage/#open","text":"Type: string Default: None Url to open in new tab. If None , False or the empty string, no new tab is opened.","title":"open"},{"location":"reference/webpage/#favicon","text":"Type: string Default: None Url to favicon. If None , False or the empty string, the default favicon is used.","title":"favicon"},{"location":"reference/webpage/#css","text":"Type: string Default: None CSS to inject into the page. The string is inserted in style tag in the head of the document.","title":"css"},{"location":"reference/webpage/#head_html-and-body_html","text":"Type: string Default: '' From version 0.0.7 A string of any extra HTML to put in the head section or body section of the template. Can be additional JavaScript for example. wp . head_html = \"\"\" <script src=\"/my_scripts.js\"></script> \"\"\" Simple example: import justpy as jp def test_head (): wp = jp . WebPage () wp . head_html = '<script>console.log(\"Hello there from head\");</script>' wp . body_html = '<script>console.log(\"Hello there from body\");</script>' jp . Div ( text = 'Testing...' , a = wp ) return wp jp . justpy ( test_head )","title":"head_html and body_html"},{"location":"reference/webpage/#html","text":"Type: string Default: '' (the empty string) If not the empty string, overrides everything else and sets the HTML on the page to this value.","title":"html"},{"location":"reference/webpage/#body_style","text":"Type: string Default: '' (the empty string) Sets the style attribute for the body html element of the page","title":"body_style"},{"location":"reference/webpage/#body_classes","text":"Type: string Default: '' (the empty string) Sets the classes for the body html element of the page","title":"body_classes"},{"location":"reference/webpage/#dark","text":"Type: boolean Default: False Only applicable currently with the Quasar pages. Set to true for Quasar's dark mode.","title":"dark"},{"location":"reference/webpage/#data","text":"Type: dictionary Default: {} (the empty dictionary) See Tutorial link","title":"data"},{"location":"reference/webpage/#reload_interval","text":"Type: float Default: None See Tutorial link","title":"reload_interval"},{"location":"reference/webpage/#use_cache","text":"Type: boolean Default: False If True the rendering process does not call the page's build_list method and uses the value of the cache attribute instead.","title":"use_cache"},{"location":"reference/webpage/#cache","text":"Place the cache content in this attribute","title":"cache"},{"location":"reference/webpage/#methods","text":"","title":"Methods"},{"location":"reference/webpage/#add_componentself-child-positionnone","text":"Adds a child component at the specified position. If position is None or not specified, adds component as the last child.","title":"add_component(self, child, position=None)"},{"location":"reference/webpage/#addself-args","text":"Adds all arguments as child elements at last position.","title":"add(self, *args)"},{"location":"reference/webpage/#remove_componentself-component-or-removeself-component","text":"Removes a component from the page if it is there. If not, raises an exception.","title":"remove_component(self, component) or remove(self, component)"},{"location":"reference/webpage/#get_componentsself","text":"Returns a list of all the elements on the page.","title":"get_components(self)"},{"location":"reference/webpage/#lastself","text":"Returns the last element on the page ( self.components[-1] )","title":"last(self)"},{"location":"reference/webpage/#__len__self","text":"len(wp) returns the number of direct children elements the page has.","title":"__len__(self)"},{"location":"reference/webpage/#delete_componentsself","text":"Deletes all the components on the page. This calls all the components' delete functions. This removes any reference to them from the internal JustPy data structures and allows garbage collection","title":"delete_components(self)"},{"location":"reference/webpage/#remove_pageself","text":"Removes the reference to the page for the page directory. If there was no other reference to the page, the Python garbage collector will eventually reclaim the memory used by the page.","title":"remove_page(self)"},{"location":"reference/webpage/#to_htmlself-indent0-indent_step0-formattrue","text":"Returns an HTML string representing the page. Set indent_step to an integer larger than 0 to make output human readable.","title":"to_html(self, indent=0, indent_step=0, format=True)"},{"location":"reference/webpage/#build_listself","text":"This is the method JustPy calls to render the page. This method converts all elements on the page to dictionaries and creates a list with these dictionaries. The result of build_list is the input to the Vue app that renders the page in the browser.","title":"build_list(self)"},{"location":"reference/webpage/#reactself","text":"This method does nothing in the original class. It is is called by build_list just before the list is actually built. If you want to preform some action just before the page is rendered, write a new page class that inherits from WebPage and overrides react .","title":"react(self)"},{"location":"reference/webpage/#async-def-updateself","text":"This method updates all browser tabs that the page is rendered on. JustPy keeps track of all the websocket connections to the rendered pages and uses them to update the page.","title":"async def update(self)"},{"location":"reference/webpage/#async-def-delayed_updateself-delay","text":"Same as update but with a delay. The argument specifies the delay in seconds.","title":"async def delayed_update(self, delay)"},{"location":"reference/webpage/#on_disconnectself-websocketnone","text":"Override if you want to do something special when one of the tabs the page is rendered on closes. import justpy as jp class MyPage ( jp . WebPage ): async def on_disconnect ( self , websocket = None ): await super () . on_disconnect () # Do what you want to do on disconnect here print ( 'Page disconnected' ) def close_test (): wp = MyPage () for i in range ( 10 ): jp . Div ( text = f 'Div {i} ' , a = wp , classes = 'bg-blue-500 text-white m-2 p-2 w-32' ) return wp jp . justpy ( close_test )","title":"on_disconnect(self, websocket=None)"},{"location":"reference/webpage/#async-def-run_javascriptself-javascript_string-request_id-sendtrue","text":"Runs JavaScript code on the page. The method has two keyword arguments: request_id : A user supplied identification for the run request. Can be used in combination with the result_ready page event to obtain the result of the computation send : By default, the result of the command is sent to the server. In some cases, you may need to execute a promise and handle sending to the server from within your code (see second example below). In those cases, set send to False to stop the result being sent twice. Simple example: import justpy as jp async def my_click ( self , msg ): await msg . page . run_javascript ( \"\"\" for (var i = 0; i<10; i++) { console.log('Line: ' + i); } \"\"\" ) def javascript_test (): wp = jp . WebPage () d = jp . Div ( a = wp , classes = 'm-2' ) b = jp . Button ( text = 'Run Script' , a = d , classes = jp . Styles . button_simple , click = my_click ) return wp jp . justpy ( javascript_test ) Getting the browser location: import justpy as jp javascript_string = \"\"\" var options = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }; function success(pos) { var crd = pos.coords; console.log('Your current position is:'); console.log(`Latitude : $ {crd.latitude} `); console.log(`Longitude: $ {crd.longitude} `); console.log(`More or less $ {crd.accuracy} meters.`); e.result = {latitude: crd.latitude, longitude: crd.longitude, accuracy: crd.accuracy}; send_to_server(e, 'page_event', false); } function error(err) { console.warn(`ERROR($ {err.code} ): $ {err.message} `); e.result = 'Error'; send_to_server(e, 'page_event', false); } navigator.geolocation.getCurrentPosition(success, error, options); \"\"\" async def result_ready ( self , msg ): if msg . request_id == 'geo_location' : msg . page . add ( jp . Div ( text = f 'longitude: {msg.result.longitude} Latitude: {msg.result.latitude} Accuracy: {msg.result.accuracy} ' , classes = 'm-2 p-2 text-lg border' )) async def page_ready ( self , msg ): jp . run_task ( self . run_javascript ( javascript_string , request_id = 'geo_location' , send = False )) def result_ready_test (): wp = jp . WebPage () wp . on ( 'page_ready' , page_ready ) wp . on ( 'result_ready' , result_ready ) # Some arbitrary content wp . d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for i in range ( 1 , 31 ): jp . Div ( text = f 'Div {i} ' , a = wp . d , classes = 'border m-2 p-2 text-xs' ) return wp jp . justpy ( result_ready_test )","title":"async def run_javascript(self, javascript_string, request_id='', send=True)"},{"location":"reference/webpage/#async-def-reloadself","text":"Forces a page reload. await wp . reload ()","title":"async def reload(self)"},{"location":"tutorial/advanced_components/","text":"Advanced Components \u00b6 Warning Work in progress. The example works but requires much more elucidation Introduction \u00b6 In most cases, components can be defined using Python only as previously described in this tutorial. In some cases however, in parallel to the Python definition, a Vue.js component also needs to be created. In this chapter, we will create a signing pad component based on signature_pad Info If you are not familiar with Vue.js, this chapter will not be very useful to you. The Components Directory \u00b6 Under your applications static directory (the default is the directory the application is run form) create another directory called components . Put the your JavaScript component definition there. Files must all have the extension .js . The application will load these files automatically. Python \u00b6 import justpy as jp class SignaturePad ( jp . JustpyBaseComponent ): vue_type = 'signaturepad' def __init__ ( self , ** kwargs ): self . options = jp . Dict () self . classes = '' self . style = '' self . width = 400 self . height = 200 self . clear = False self . show = True self . event_propagation = True self . pages = {} kwargs [ 'temp' ] = False # Force an id to be assigned to pad super () . __init__ ( ** kwargs ) self . allowed_events = [ 'onEnd' , 'onBegin' ] if type ( self . options ) != jp . Dict : self . options = jp . Dict ( self . options ) self . initialize ( ** kwargs ) def add_to_page ( self , wp : jp . WebPage ): wp . add_component ( self ) def react ( self , data ): pass def convert_object_to_dict ( self ): d = {} d [ 'vue_type' ] = self . vue_type d [ 'id' ] = self . id d [ 'show' ] = self . show d [ 'classes' ] = self . classes d [ 'style' ] = self . style d [ 'event_propagation' ] = self . event_propagation d [ 'def' ] = self . options d [ 'events' ] = self . events d [ 'width' ] = self . width d [ 'height' ] = self . height d [ 'clear' ] = self . clear d [ 'options' ] = self . options return d def my_end ( self , msg ): print ( msg ) self . data = msg . data async def clear_pad ( self , msg ): self . pad . clear = True await msg . page . update () self . pad . clear = False return True def pad_test (): wp = jp . WebPage () wp . head_html = '<script src=\"https://cdn.jsdelivr.net/npm/signature_pad@2.3.2/dist/signature_pad.min.js\"></script>' pad = SignaturePad ( a = wp , style = 'background-color: white; border: 1px solid;' , classes = 'm-2' , onEnd = my_end ) pad . options = { 'penColor' : 'blue' } clear_btn = jp . Button ( text = 'Clear Pad' , classes = jp . Styles . button_simple + ' m-2' , a = wp , click = clear_pad ) clear_btn . pad = pad return wp jp . justpy ( pad_test ) Vue.js Component \u00b6 var signature_pads = {}; Vue . component ( 'signaturepad' , { template : `<canvas v-bind:id=\"jp_props.id\" :class=\"jp_props.classes\" :style=\"jp_props.style\" :width=\"jp_props.width\" height=\"jp_props.height\"></canvas>` , methods : { pad_change () { var id = this . $props . jp_props . id . toString (); var canvas = document . getElementById ( id ); var signaturePad = new SignaturePad ( canvas , this . $props . jp_props . options ); signature_pads [ id ] = signaturePad ; var events = this . $props . jp_props . events ; var props = this . $props ; function onEnd () { if ( events . includes ( 'onEnd' )) { var data = signaturePad . toDataURL ( 'image/png' ); var point_data = signaturePad . toData (); var e = { 'event_type' : 'onEnd' , 'id' : props . jp_props . id , 'class_name' : props . jp_props . class_name , 'html_tag' : props . jp_props . html_tag , 'vue_type' : props . jp_props . vue_type , 'page_id' : page_id , 'websocket_id' : websocket_id , 'data' : data , 'point_data' : point_data }; send_to_server ( e , 'event' ); } } signaturePad . onEnd = onEnd ; } }, mounted () { this . pad_change (); }, updated () { if ( this . $props . jp_props . clear ) { signature_pads [ this . $props . jp_props . id . toString ()]. clear (); } }, props : { jp_props : Object } }); FullCalendar Example \u00b6 FullCalendar is a full featured JavaScript Calendar The following implementation does not support all the features and events but is a sound basis to build on. Python file: import justpy as jp class FullCalendar ( jp . JustpyBaseComponent ): vue_type = 'fullcalendar' def __init__ ( self , ** kwargs ): self . options = jp . Dict () self . classes = '' self . style = '' self . show = True self . event_propagation = True self . pages = {} kwargs [ 'temp' ] = False # Force an id to be assigned super () . __init__ ( ** kwargs ) self . allowed_events = [ 'eventClick' , 'eventDrop' ] if type ( self . options ) != jp . Dict : self . options = jp . Dict ( self . options ) self . initialize ( ** kwargs ) def add_to_page ( self , wp : jp . WebPage ): wp . add_component ( self ) def react ( self , data ): pass async def run_method ( self , command , websocket ): await websocket . send_json ({ 'type' : 'run_method' , 'data' : command , 'id' : self . id }) # So the page itself does not update, return True not None return True def convert_object_to_dict ( self ): d = {} d [ 'vue_type' ] = self . vue_type d [ 'id' ] = self . id d [ 'show' ] = self . show d [ 'classes' ] = self . classes d [ 'style' ] = self . style d [ 'event_propagation' ] = self . event_propagation d [ 'events' ] = self . events d [ 'options' ] = self . options return d calendar_options = { 'plugins' : [ 'dayGrid' , 'interaction' ], 'editable' : True , 'header' : { 'left' : '' , 'center' : 'title' , 'right' : 'today prev,next' }, 'defaultDate' : '2020-05-15' , 'events' : [ { 'title' : 'This is an event' , 'start' : '2020-05-02' , 'end' : '2020-05-12' , 'color' : 'red' , 'editable' : True }, { 'title' : 'event with a URL' , 'url' : 'https://www.google.com/' , 'start' : '2020-05-03' } ] } # https://fullcalendar.io/docs/plugin-index head_html = \"\"\" <link rel=\"stylesheet\" href=\"https://unpkg.com/@fullcalendar/core@4.4.0/main.min.css\"> <link rel=\"stylesheet\" href=\"https://unpkg.com/@fullcalendar/daygrid@4.4.0/main.min.css\"> <script src=\"https://unpkg.com/@fullcalendar/core@4.4.0/main.min.js\"></script> <script src=\"https://unpkg.com/@fullcalendar/daygrid@4.4.0/main.min.js\"></script> <script src=\"https://unpkg.com/@fullcalendar/interaction@4.4.0/main.min.js\"></script> \"\"\" async def add_event ( self , msg ): print ( msg ) self . calendar . options [ 'events' ] . append ({ 'title' : 'Very new event' , 'start' : '2020-05-02' , 'end' : '2020-05-05' , 'color' : 'green' , 'editable' : True }) def event_click ( self , msg ): print ( msg ) def event_drop ( self , msg ): print ( msg ) print ( msg . all_events ) self . options [ 'events' ] = msg . all_events def calendar_test (): wp = jp . QuasarPage () wp . head_html = head_html calendar = FullCalendar ( a = wp , classes = 'q-ma-lg' , style = 'width: 700px;' ) calendar . options = calendar_options calendar . on ( 'eventClick' , event_click ) calendar . on ( 'eventDrop' , event_drop ) b = jp . QBtn ( label = 'Add Event' , a = wp , classes = 'q-ma-lg' , click = add_event ) b . calendar = calendar return wp jp . justpy ( calendar_test ) Vue.js component: var full_calendars = {}; Vue . component ( 'fullcalendar' , { template : `<div v-bind:id=\"jp_props.id\" :class=\"jp_props.classes\" :style=\"jp_props.style\" ></div>` , methods : { get_all_events ( calendar ) { let all_events = []; for ( let event_obj of calendar . getEvents ()) { all_events . push ( this . create_object_from_event ( event_obj )) } return all_events ; }, create_object_from_event ( event_obj ) { // https://fullcalendar.io/docs/event-object const event_properties = [ 'id' , 'groupId' , 'allDay' , 'start' , 'end' , 'title' , 'url' , 'classNames' , 'editable' , 'startEditable' , 'durationEditable' , 'resourceEditable' , 'rendering' , 'overlap' , 'constraint' , 'backgroundColor' , 'borderColor' , 'textColor' , 'extendedProps' ]; let event_data = {}; for ( let i of event_properties ) { event_data [ i ] = event_obj [ i ]; } return event_data ; }, calendar_change () { var id = this . $props . jp_props . id . toString (); var events = this . $props . jp_props . events ; var props = this . $props ; var calendarEl = document . getElementById ( id ); var calendar = new FullCalendar . Calendar ( calendarEl , this . $props . jp_props . options ); const parent_comp = this ; if ( events . includes ( 'eventClick' )) // https://fullcalendar.io/docs/eventClick calendar . on ( 'eventClick' , function ( info ) { var e = { 'event_type' : 'eventClick' , 'id' : props . jp_props . id , 'class_name' : props . jp_props . class_name , 'html_tag' : props . jp_props . html_tag , 'vue_type' : props . jp_props . vue_type , 'page_id' : page_id , 'websocket_id' : websocket_id , 'event_data' : parent_comp . create_object_from_event ( info . event ), 'all_events' : parent_comp . get_all_events ( calendar ) }; send_to_server ( e , 'event' ); }); if ( events . includes ( 'eventDrop' )) // https://fullcalendar.io/docs/eventDrop calendar . on ( 'eventDrop' , function ( info ) { var e = { 'event_type' : 'eventDrop' , 'id' : props . jp_props . id , 'class_name' : props . jp_props . class_name , 'html_tag' : props . jp_props . html_tag , 'vue_type' : props . jp_props . vue_type , 'page_id' : page_id , 'websocket_id' : websocket_id , 'event_data' : parent_comp . create_object_from_event ( info . event ), 'old_event_data' : parent_comp . create_object_from_event ( info . oldEvent ), 'delta' : info . delta , 'all_events' : parent_comp . get_all_events ( calendar ) }; send_to_server ( e , 'event' ); }); full_calendars [ id ] = calendar ; comp_dict [ this . $props . jp_props . id ] = calendar ; calendar . render (); }, }, mounted () { this . calendar_change (); }, updated () { var calendar = comp_dict [ this . $props . jp_props . id ]; calendar . destroy (); this . calendar_change (); }, props : { jp_props : Object } });","title":"Advanced Components"},{"location":"tutorial/advanced_components/#advanced-components","text":"Warning Work in progress. The example works but requires much more elucidation","title":"Advanced Components"},{"location":"tutorial/advanced_components/#introduction","text":"In most cases, components can be defined using Python only as previously described in this tutorial. In some cases however, in parallel to the Python definition, a Vue.js component also needs to be created. In this chapter, we will create a signing pad component based on signature_pad Info If you are not familiar with Vue.js, this chapter will not be very useful to you.","title":"Introduction"},{"location":"tutorial/advanced_components/#the-components-directory","text":"Under your applications static directory (the default is the directory the application is run form) create another directory called components . Put the your JavaScript component definition there. Files must all have the extension .js . The application will load these files automatically.","title":"The Components Directory"},{"location":"tutorial/advanced_components/#python","text":"import justpy as jp class SignaturePad ( jp . JustpyBaseComponent ): vue_type = 'signaturepad' def __init__ ( self , ** kwargs ): self . options = jp . Dict () self . classes = '' self . style = '' self . width = 400 self . height = 200 self . clear = False self . show = True self . event_propagation = True self . pages = {} kwargs [ 'temp' ] = False # Force an id to be assigned to pad super () . __init__ ( ** kwargs ) self . allowed_events = [ 'onEnd' , 'onBegin' ] if type ( self . options ) != jp . Dict : self . options = jp . Dict ( self . options ) self . initialize ( ** kwargs ) def add_to_page ( self , wp : jp . WebPage ): wp . add_component ( self ) def react ( self , data ): pass def convert_object_to_dict ( self ): d = {} d [ 'vue_type' ] = self . vue_type d [ 'id' ] = self . id d [ 'show' ] = self . show d [ 'classes' ] = self . classes d [ 'style' ] = self . style d [ 'event_propagation' ] = self . event_propagation d [ 'def' ] = self . options d [ 'events' ] = self . events d [ 'width' ] = self . width d [ 'height' ] = self . height d [ 'clear' ] = self . clear d [ 'options' ] = self . options return d def my_end ( self , msg ): print ( msg ) self . data = msg . data async def clear_pad ( self , msg ): self . pad . clear = True await msg . page . update () self . pad . clear = False return True def pad_test (): wp = jp . WebPage () wp . head_html = '<script src=\"https://cdn.jsdelivr.net/npm/signature_pad@2.3.2/dist/signature_pad.min.js\"></script>' pad = SignaturePad ( a = wp , style = 'background-color: white; border: 1px solid;' , classes = 'm-2' , onEnd = my_end ) pad . options = { 'penColor' : 'blue' } clear_btn = jp . Button ( text = 'Clear Pad' , classes = jp . Styles . button_simple + ' m-2' , a = wp , click = clear_pad ) clear_btn . pad = pad return wp jp . justpy ( pad_test )","title":"Python"},{"location":"tutorial/advanced_components/#vuejs-component","text":"var signature_pads = {}; Vue . component ( 'signaturepad' , { template : `<canvas v-bind:id=\"jp_props.id\" :class=\"jp_props.classes\" :style=\"jp_props.style\" :width=\"jp_props.width\" height=\"jp_props.height\"></canvas>` , methods : { pad_change () { var id = this . $props . jp_props . id . toString (); var canvas = document . getElementById ( id ); var signaturePad = new SignaturePad ( canvas , this . $props . jp_props . options ); signature_pads [ id ] = signaturePad ; var events = this . $props . jp_props . events ; var props = this . $props ; function onEnd () { if ( events . includes ( 'onEnd' )) { var data = signaturePad . toDataURL ( 'image/png' ); var point_data = signaturePad . toData (); var e = { 'event_type' : 'onEnd' , 'id' : props . jp_props . id , 'class_name' : props . jp_props . class_name , 'html_tag' : props . jp_props . html_tag , 'vue_type' : props . jp_props . vue_type , 'page_id' : page_id , 'websocket_id' : websocket_id , 'data' : data , 'point_data' : point_data }; send_to_server ( e , 'event' ); } } signaturePad . onEnd = onEnd ; } }, mounted () { this . pad_change (); }, updated () { if ( this . $props . jp_props . clear ) { signature_pads [ this . $props . jp_props . id . toString ()]. clear (); } }, props : { jp_props : Object } });","title":"Vue.js Component"},{"location":"tutorial/advanced_components/#fullcalendar-example","text":"FullCalendar is a full featured JavaScript Calendar The following implementation does not support all the features and events but is a sound basis to build on. Python file: import justpy as jp class FullCalendar ( jp . JustpyBaseComponent ): vue_type = 'fullcalendar' def __init__ ( self , ** kwargs ): self . options = jp . Dict () self . classes = '' self . style = '' self . show = True self . event_propagation = True self . pages = {} kwargs [ 'temp' ] = False # Force an id to be assigned super () . __init__ ( ** kwargs ) self . allowed_events = [ 'eventClick' , 'eventDrop' ] if type ( self . options ) != jp . Dict : self . options = jp . Dict ( self . options ) self . initialize ( ** kwargs ) def add_to_page ( self , wp : jp . WebPage ): wp . add_component ( self ) def react ( self , data ): pass async def run_method ( self , command , websocket ): await websocket . send_json ({ 'type' : 'run_method' , 'data' : command , 'id' : self . id }) # So the page itself does not update, return True not None return True def convert_object_to_dict ( self ): d = {} d [ 'vue_type' ] = self . vue_type d [ 'id' ] = self . id d [ 'show' ] = self . show d [ 'classes' ] = self . classes d [ 'style' ] = self . style d [ 'event_propagation' ] = self . event_propagation d [ 'events' ] = self . events d [ 'options' ] = self . options return d calendar_options = { 'plugins' : [ 'dayGrid' , 'interaction' ], 'editable' : True , 'header' : { 'left' : '' , 'center' : 'title' , 'right' : 'today prev,next' }, 'defaultDate' : '2020-05-15' , 'events' : [ { 'title' : 'This is an event' , 'start' : '2020-05-02' , 'end' : '2020-05-12' , 'color' : 'red' , 'editable' : True }, { 'title' : 'event with a URL' , 'url' : 'https://www.google.com/' , 'start' : '2020-05-03' } ] } # https://fullcalendar.io/docs/plugin-index head_html = \"\"\" <link rel=\"stylesheet\" href=\"https://unpkg.com/@fullcalendar/core@4.4.0/main.min.css\"> <link rel=\"stylesheet\" href=\"https://unpkg.com/@fullcalendar/daygrid@4.4.0/main.min.css\"> <script src=\"https://unpkg.com/@fullcalendar/core@4.4.0/main.min.js\"></script> <script src=\"https://unpkg.com/@fullcalendar/daygrid@4.4.0/main.min.js\"></script> <script src=\"https://unpkg.com/@fullcalendar/interaction@4.4.0/main.min.js\"></script> \"\"\" async def add_event ( self , msg ): print ( msg ) self . calendar . options [ 'events' ] . append ({ 'title' : 'Very new event' , 'start' : '2020-05-02' , 'end' : '2020-05-05' , 'color' : 'green' , 'editable' : True }) def event_click ( self , msg ): print ( msg ) def event_drop ( self , msg ): print ( msg ) print ( msg . all_events ) self . options [ 'events' ] = msg . all_events def calendar_test (): wp = jp . QuasarPage () wp . head_html = head_html calendar = FullCalendar ( a = wp , classes = 'q-ma-lg' , style = 'width: 700px;' ) calendar . options = calendar_options calendar . on ( 'eventClick' , event_click ) calendar . on ( 'eventDrop' , event_drop ) b = jp . QBtn ( label = 'Add Event' , a = wp , classes = 'q-ma-lg' , click = add_event ) b . calendar = calendar return wp jp . justpy ( calendar_test ) Vue.js component: var full_calendars = {}; Vue . component ( 'fullcalendar' , { template : `<div v-bind:id=\"jp_props.id\" :class=\"jp_props.classes\" :style=\"jp_props.style\" ></div>` , methods : { get_all_events ( calendar ) { let all_events = []; for ( let event_obj of calendar . getEvents ()) { all_events . push ( this . create_object_from_event ( event_obj )) } return all_events ; }, create_object_from_event ( event_obj ) { // https://fullcalendar.io/docs/event-object const event_properties = [ 'id' , 'groupId' , 'allDay' , 'start' , 'end' , 'title' , 'url' , 'classNames' , 'editable' , 'startEditable' , 'durationEditable' , 'resourceEditable' , 'rendering' , 'overlap' , 'constraint' , 'backgroundColor' , 'borderColor' , 'textColor' , 'extendedProps' ]; let event_data = {}; for ( let i of event_properties ) { event_data [ i ] = event_obj [ i ]; } return event_data ; }, calendar_change () { var id = this . $props . jp_props . id . toString (); var events = this . $props . jp_props . events ; var props = this . $props ; var calendarEl = document . getElementById ( id ); var calendar = new FullCalendar . Calendar ( calendarEl , this . $props . jp_props . options ); const parent_comp = this ; if ( events . includes ( 'eventClick' )) // https://fullcalendar.io/docs/eventClick calendar . on ( 'eventClick' , function ( info ) { var e = { 'event_type' : 'eventClick' , 'id' : props . jp_props . id , 'class_name' : props . jp_props . class_name , 'html_tag' : props . jp_props . html_tag , 'vue_type' : props . jp_props . vue_type , 'page_id' : page_id , 'websocket_id' : websocket_id , 'event_data' : parent_comp . create_object_from_event ( info . event ), 'all_events' : parent_comp . get_all_events ( calendar ) }; send_to_server ( e , 'event' ); }); if ( events . includes ( 'eventDrop' )) // https://fullcalendar.io/docs/eventDrop calendar . on ( 'eventDrop' , function ( info ) { var e = { 'event_type' : 'eventDrop' , 'id' : props . jp_props . id , 'class_name' : props . jp_props . class_name , 'html_tag' : props . jp_props . html_tag , 'vue_type' : props . jp_props . vue_type , 'page_id' : page_id , 'websocket_id' : websocket_id , 'event_data' : parent_comp . create_object_from_event ( info . event ), 'old_event_data' : parent_comp . create_object_from_event ( info . oldEvent ), 'delta' : info . delta , 'all_events' : parent_comp . get_all_events ( calendar ) }; send_to_server ( e , 'event' ); }); full_calendars [ id ] = calendar ; comp_dict [ this . $props . jp_props . id ] = calendar ; calendar . render (); }, }, mounted () { this . calendar_change (); }, updated () { var calendar = comp_dict [ this . $props . jp_props . id ]; calendar . destroy (); this . calendar_change (); }, props : { jp_props : Object } });","title":"FullCalendar Example"},{"location":"tutorial/ajax/","text":"Using Ajax instead of WebSockets \u00b6 Using Ajax to Handle Events \u00b6 By default, JustPy uses WebSockets as the communication protocol between the frontend and the backend. The advantage of WebSockets is that it allows the server to \"push\" data to the browser. There may be applications where either you do not want to or cannot use WebSockets (due to hosting limitations for example). In the justpy command if the websockets keyword argument is set to False , web pages will not attempt to establish a WebSockets connection with the server. Instead, events and pertinent data will be sent to the backend using Ajax. Your program will still be able to respond to UI events in the browser but will not be able to push data to browsers (you will not be able to implement chat like applications for example). import justpy as jp def hello_test (): wp = jp . WebPage () for i in range ( 10 ): jp . Hello ( a = wp ) return wp jp . justpy ( hello_test , websockets = False ) The program above will use Ajax to handle clicks on the Hello elements. You van verify this by using the debugging tools of your browser (in Chrome press CTRL+Shift+I and go to the \"Network\" tab) Note In most cases, users will not notice any difference in the performance of the application if you use Ajax instead of WebSockets. If your hosting solution does not support WebSockets, give the Ajax option a try. Ajax Page Reload \u00b6 There may be cases where you do not want to use WebSockets but still want the content on the users' pages to refresh periodically. This is done in JustPy by setting the reload_interval attribute of the page to the number of seconds between each reload. The page does not reload in the strictest sense of that word, it just refreshes its content using an Ajax call to the server as you would do in a single page application. For example, this feature is useful for implementing dashboards. Below is a very simple dashboard that includes just one element that is updated by a background task every second while users' browser tabs poll the updated content every 2.5 seconds. import justpy as jp import asyncio wp = jp . WebPage ( delete_flag = False ) wp . reload_interval = 2.5 count_div = jp . Div ( a = wp , classes = 'text-center m-4 p-4 text-white bg-blue-500' , style = 'font-size: 200px' ) async def increment_counter ( start ): count_div . counter = start while True : count_div . counter += 1 count_div . text = str ( count_div . counter ) await asyncio . sleep ( 1 ) def start_counting (): jp . run_task ( increment_counter ( 500 )) def reload_demo (): return wp jp . justpy ( reload_demo , startup = start_counting , websockets = False )","title":"Ajax vs. WebSockets"},{"location":"tutorial/ajax/#using-ajax-instead-of-websockets","text":"","title":"Using Ajax instead of WebSockets"},{"location":"tutorial/ajax/#using-ajax-to-handle-events","text":"By default, JustPy uses WebSockets as the communication protocol between the frontend and the backend. The advantage of WebSockets is that it allows the server to \"push\" data to the browser. There may be applications where either you do not want to or cannot use WebSockets (due to hosting limitations for example). In the justpy command if the websockets keyword argument is set to False , web pages will not attempt to establish a WebSockets connection with the server. Instead, events and pertinent data will be sent to the backend using Ajax. Your program will still be able to respond to UI events in the browser but will not be able to push data to browsers (you will not be able to implement chat like applications for example). import justpy as jp def hello_test (): wp = jp . WebPage () for i in range ( 10 ): jp . Hello ( a = wp ) return wp jp . justpy ( hello_test , websockets = False ) The program above will use Ajax to handle clicks on the Hello elements. You van verify this by using the debugging tools of your browser (in Chrome press CTRL+Shift+I and go to the \"Network\" tab) Note In most cases, users will not notice any difference in the performance of the application if you use Ajax instead of WebSockets. If your hosting solution does not support WebSockets, give the Ajax option a try.","title":"Using Ajax to Handle Events"},{"location":"tutorial/ajax/#ajax-page-reload","text":"There may be cases where you do not want to use WebSockets but still want the content on the users' pages to refresh periodically. This is done in JustPy by setting the reload_interval attribute of the page to the number of seconds between each reload. The page does not reload in the strictest sense of that word, it just refreshes its content using an Ajax call to the server as you would do in a single page application. For example, this feature is useful for implementing dashboards. Below is a very simple dashboard that includes just one element that is updated by a background task every second while users' browser tabs poll the updated content every 2.5 seconds. import justpy as jp import asyncio wp = jp . WebPage ( delete_flag = False ) wp . reload_interval = 2.5 count_div = jp . Div ( a = wp , classes = 'text-center m-4 p-4 text-white bg-blue-500' , style = 'font-size: 200px' ) async def increment_counter ( start ): count_div . counter = start while True : count_div . counter += 1 count_div . text = str ( count_div . counter ) await asyncio . sleep ( 1 ) def start_counting (): jp . run_task ( increment_counter ( 500 )) def reload_demo (): return wp jp . justpy ( reload_demo , startup = start_counting , websockets = False )","title":"Ajax Page Reload"},{"location":"tutorial/altair/","text":"Altair Charts \u00b6 Altair charts are supported by JustPy using the AltairChart component. The AltairChart component supports visualization of any Vega defined object. Instead of setting the component's chart attribute, set the vega_source attribute with the Vega language definition. In the example below, in addition to the default route, the \"/line\" route is also defined. It is an example of how a slider can be used to change a chart. import altair as alt import justpy as jp # Load a simple dataset as a pandas DataFrame from vega_datasets import data cars = data . cars () car_chart = alt . Chart ( cars ) . mark_point () . encode ( x = 'Horsepower' , y = 'Miles_per_Gallon' , color = 'Origin' , ) . properties ( width = 500 , height = 300 ) def altair_chart_test ( request ): wp = jp . WebPage ( tailwind = True ) wp . altair_chart = jp . AltairChart ( chart = car_chart , a = wp , classes = 'm-8' ) return wp def change_limit ( self , msg ): wp = msg . page wp . chart . chart = create_chart ( self . value ) def create_chart ( value ): source = alt . sequence ( start = 0 , stop = value , step = 0.1 , as_ = 'x' ) return alt . Chart ( source ) . mark_line () . transform_calculate ( sin = 'sin(datum.x)' , cos = 'cos(datum.x)' ) . transform_fold ( [ 'sin' , 'cos' ] ) . encode ( x = 'x:Q' , y = 'value:Q' , color = 'key:N' ) . properties ( width = 500 , height = 300 ) @jp . SetRoute ( '/line' ) def line_chart ( request ): wp = jp . QuasarPage ( tailwind = True ) jp . QSlider ( a = wp , classes = 'm-8 p-2' , style = 'width: 500px' , input = change_limit , label = True , label_always = True , value = 10 , min = 1 , max = 50 , snap = True , markers = True ) wp . chart = jp . AltairChart ( chart = create_chart ( 10 ), a = wp , classes = 'm-4 p-2' ) return wp jp . justpy ( altair_chart_test , VEGA = True )","title":"Altair Charting"},{"location":"tutorial/altair/#altair-charts","text":"Altair charts are supported by JustPy using the AltairChart component. The AltairChart component supports visualization of any Vega defined object. Instead of setting the component's chart attribute, set the vega_source attribute with the Vega language definition. In the example below, in addition to the default route, the \"/line\" route is also defined. It is an example of how a slider can be used to change a chart. import altair as alt import justpy as jp # Load a simple dataset as a pandas DataFrame from vega_datasets import data cars = data . cars () car_chart = alt . Chart ( cars ) . mark_point () . encode ( x = 'Horsepower' , y = 'Miles_per_Gallon' , color = 'Origin' , ) . properties ( width = 500 , height = 300 ) def altair_chart_test ( request ): wp = jp . WebPage ( tailwind = True ) wp . altair_chart = jp . AltairChart ( chart = car_chart , a = wp , classes = 'm-8' ) return wp def change_limit ( self , msg ): wp = msg . page wp . chart . chart = create_chart ( self . value ) def create_chart ( value ): source = alt . sequence ( start = 0 , stop = value , step = 0.1 , as_ = 'x' ) return alt . Chart ( source ) . mark_line () . transform_calculate ( sin = 'sin(datum.x)' , cos = 'cos(datum.x)' ) . transform_fold ( [ 'sin' , 'cos' ] ) . encode ( x = 'x:Q' , y = 'value:Q' , color = 'key:N' ) . properties ( width = 500 , height = 300 ) @jp . SetRoute ( '/line' ) def line_chart ( request ): wp = jp . QuasarPage ( tailwind = True ) jp . QSlider ( a = wp , classes = 'm-8 p-2' , style = 'width: 500px' , input = change_limit , label = True , label_always = True , value = 10 , min = 1 , max = 50 , snap = True , markers = True ) wp . chart = jp . AltairChart ( chart = create_chart ( 10 ), a = wp , classes = 'm-4 p-2' ) return wp jp . justpy ( altair_chart_test , VEGA = True )","title":"Altair Charts"},{"location":"tutorial/basic_concepts/","text":"The Basic Concepts \u00b6 JustPy Components \u00b6 JustPy components are classes that instantiate reusable elements that can be be rendered in a browser. Out of the box, JustPy comes with many components. You can use the available JustPy components and also build more complex components using other components as building blocks. In JustPy, components are implemented as Python classes. When you define a new component, you do so by defining a new Python class. A JustPy element is an instance of a component class. import justpy as jp p = jp . P () p . text = 'Hello!' In the example above, p is an instance of the class P . Its text attribute is set to 'Hello!'. The above is similar to the HTML element: < p > Hello! </ p > You can set the JustPy element attributes when the element is created (synonym for instantiated) using keyword arguments to make code shorter and clearer: import justpy as jp p = jp . P ( text = 'Hello!' ) Just creating an element is not very useful. We need to get it on a web page and into the user's browser tab. We will do this next. JustPy Web Pages \u00b6 In JustPy, web pages are instances of the JustPy class WebPage . You create a web page the same way you create any class instance in Python: import justpy as jp wp = jp . WebPage () In the example above we created the web page wp . It is an empty web page that does not contain any elements. Let's create an element and add it to the page: import justpy as jp wp = jp . WebPage () p = jp . P ( text = 'Hello World!' ) wp . add ( p ) # Same as p.add_to(wp), wp = wp + p, wp += p In the example above, we create a web page. Then we create a p element and add it to the page using the add method. Since adding an element to a page is very common, there is a way to do so using the keyword argument a : import justpy as jp wp = jp . WebPage () p = jp . P ( text = 'Hello World!' , a = wp ) This code snippet has the same functionality as the one above it. JustPy Requests \u00b6 So far we have created a page and added an element to it. We haven't yet loaded the page into the user's browser. Note In this tutorial, I will call the process of delivering a Web page to a user \" rendering the page \". When you type a URL into your browser's Address Bar and tell your browser to navigate to that address, the browser generates a request; it requests data from the server the URL you entered points to. When a request comes from a browser, the JustPy framework runs a user defined function. This function must return a web page which is then rendered in the browser that sent the request. All that you as a developer need to do is write the function that takes a request and returns a web page. The framework takes care of the rest. Hello World \u00b6 Here is a basic example: import justpy as jp def hello_world (): wp = jp . WebPage () p = jp . P ( text = 'Hello World!' , a = wp ) return wp jp . justpy ( hello_world ) The function hello_world creates a web page, adds a paragraph element to it and returns the page. Note In this tutorial, functions like hello_world will be called \"request handlers\". The jp.justpy(hello_world) command starts a web server and sends all requests to the function hello_world . Run the program above (as explained in getting started ). You should see 'Hello World!' in your browser. More Hello World \u00b6 Saying hello once isn't enough! We would like to say \"hello\" ten times. We also want to let the user know how many times we said \"hello\". More specifically, we would like \"Hello World!\" to show up ten times on the page and be enumerated. In addition, we would like to use a bigger font each time. import justpy as jp def hello_world (): wp = jp . WebPage () for i in range ( 1 , 11 ): jp . P ( text = f ' {i} ) Hello World!' , a = wp , style = f 'font-size: {10*i}px' ) return wp jp . justpy ( hello_world ) Run the program above and look at the result in your browser. Warning Don't forget to terminate the previous program first. Two JustPy servers cannot run at the same time on the same port. The P instances are created inside a loop with the loop index being used to give each paragraph some different text and a different font size. The style attribute in JustPy is the same as the HTML style attribute. It allows using CSS properties to style the element. For example, change the style assignment to: style = f 'color: blue; font-size: {10*i}px' and see what happens. Tailwind and JustPy \u00b6 Another way to style elements is to use classes. By default, instances of WebPage support styling using Tailwind classes. If you are familiar with CSS, checkout Tailwind. For me, it is a joy to work with. Info You can also put your own CSS on a page and use your own class definitions by setting the css attribute of a page. Let's use Tailwind classes to style our page: import justpy as jp def hello_world (): wp = jp . WebPage () my_paragraph_design = \"w-64 bg-blue-500 m-2 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\" for i in range ( 1 , 11 ): jp . P ( text = f ' {i} ) Hello World!' , a = wp , classes = my_paragraph_design ) return wp jp . justpy ( hello_world ) In this program Tailwind classes are used to make the output a little nicer. The JustPy attribute classes is equivalent to the HTML attribute class (which is a reserved word in Python). Creating Web Pages Once \u00b6 You may have noticed that since we have been serving the same page to everyone, there is no need to create a new page each time a request is made. We can create a page one time, and serve the same page for all requests: import justpy as jp wp = jp . WebPage ( delete_flag = False ) my_paragraph_design = \"w-64 bg-blue-500 m-2 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\" for i in range ( 1 , 11 ): jp . P ( text = f ' {i} ) Hello World!' , a = wp , classes = my_paragraph_design ) def hello_world (): return wp jp . justpy ( hello_world ) Info When you define a page that is going to be rendered in more than one browser tab or page, you need to set its delete_flag to False . Otherwise, the page (the instance of WebPage to be precise) will be deleted when a browser tab or window that renders that page is closed. The default is for JustPy to remove all references to the page and the elements on it so that the Python garbage collector can reclaim the memory. Warning When a page's (or element's) delete_flag is set to False , none of its child elements will be deleted, even if their delete_flag is True . In the next part of the tutorial you will learn how to deal with events such as a mouse click.","title":"Basic Concepts"},{"location":"tutorial/basic_concepts/#the-basic-concepts","text":"","title":"The Basic Concepts"},{"location":"tutorial/basic_concepts/#justpy-components","text":"JustPy components are classes that instantiate reusable elements that can be be rendered in a browser. Out of the box, JustPy comes with many components. You can use the available JustPy components and also build more complex components using other components as building blocks. In JustPy, components are implemented as Python classes. When you define a new component, you do so by defining a new Python class. A JustPy element is an instance of a component class. import justpy as jp p = jp . P () p . text = 'Hello!' In the example above, p is an instance of the class P . Its text attribute is set to 'Hello!'. The above is similar to the HTML element: < p > Hello! </ p > You can set the JustPy element attributes when the element is created (synonym for instantiated) using keyword arguments to make code shorter and clearer: import justpy as jp p = jp . P ( text = 'Hello!' ) Just creating an element is not very useful. We need to get it on a web page and into the user's browser tab. We will do this next.","title":"JustPy Components"},{"location":"tutorial/basic_concepts/#justpy-web-pages","text":"In JustPy, web pages are instances of the JustPy class WebPage . You create a web page the same way you create any class instance in Python: import justpy as jp wp = jp . WebPage () In the example above we created the web page wp . It is an empty web page that does not contain any elements. Let's create an element and add it to the page: import justpy as jp wp = jp . WebPage () p = jp . P ( text = 'Hello World!' ) wp . add ( p ) # Same as p.add_to(wp), wp = wp + p, wp += p In the example above, we create a web page. Then we create a p element and add it to the page using the add method. Since adding an element to a page is very common, there is a way to do so using the keyword argument a : import justpy as jp wp = jp . WebPage () p = jp . P ( text = 'Hello World!' , a = wp ) This code snippet has the same functionality as the one above it.","title":"JustPy Web Pages"},{"location":"tutorial/basic_concepts/#justpy-requests","text":"So far we have created a page and added an element to it. We haven't yet loaded the page into the user's browser. Note In this tutorial, I will call the process of delivering a Web page to a user \" rendering the page \". When you type a URL into your browser's Address Bar and tell your browser to navigate to that address, the browser generates a request; it requests data from the server the URL you entered points to. When a request comes from a browser, the JustPy framework runs a user defined function. This function must return a web page which is then rendered in the browser that sent the request. All that you as a developer need to do is write the function that takes a request and returns a web page. The framework takes care of the rest.","title":"JustPy Requests"},{"location":"tutorial/basic_concepts/#hello-world","text":"Here is a basic example: import justpy as jp def hello_world (): wp = jp . WebPage () p = jp . P ( text = 'Hello World!' , a = wp ) return wp jp . justpy ( hello_world ) The function hello_world creates a web page, adds a paragraph element to it and returns the page. Note In this tutorial, functions like hello_world will be called \"request handlers\". The jp.justpy(hello_world) command starts a web server and sends all requests to the function hello_world . Run the program above (as explained in getting started ). You should see 'Hello World!' in your browser.","title":"Hello World"},{"location":"tutorial/basic_concepts/#more-hello-world","text":"Saying hello once isn't enough! We would like to say \"hello\" ten times. We also want to let the user know how many times we said \"hello\". More specifically, we would like \"Hello World!\" to show up ten times on the page and be enumerated. In addition, we would like to use a bigger font each time. import justpy as jp def hello_world (): wp = jp . WebPage () for i in range ( 1 , 11 ): jp . P ( text = f ' {i} ) Hello World!' , a = wp , style = f 'font-size: {10*i}px' ) return wp jp . justpy ( hello_world ) Run the program above and look at the result in your browser. Warning Don't forget to terminate the previous program first. Two JustPy servers cannot run at the same time on the same port. The P instances are created inside a loop with the loop index being used to give each paragraph some different text and a different font size. The style attribute in JustPy is the same as the HTML style attribute. It allows using CSS properties to style the element. For example, change the style assignment to: style = f 'color: blue; font-size: {10*i}px' and see what happens.","title":"More Hello World"},{"location":"tutorial/basic_concepts/#tailwind-and-justpy","text":"Another way to style elements is to use classes. By default, instances of WebPage support styling using Tailwind classes. If you are familiar with CSS, checkout Tailwind. For me, it is a joy to work with. Info You can also put your own CSS on a page and use your own class definitions by setting the css attribute of a page. Let's use Tailwind classes to style our page: import justpy as jp def hello_world (): wp = jp . WebPage () my_paragraph_design = \"w-64 bg-blue-500 m-2 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\" for i in range ( 1 , 11 ): jp . P ( text = f ' {i} ) Hello World!' , a = wp , classes = my_paragraph_design ) return wp jp . justpy ( hello_world ) In this program Tailwind classes are used to make the output a little nicer. The JustPy attribute classes is equivalent to the HTML attribute class (which is a reserved word in Python).","title":"Tailwind and JustPy"},{"location":"tutorial/basic_concepts/#creating-web-pages-once","text":"You may have noticed that since we have been serving the same page to everyone, there is no need to create a new page each time a request is made. We can create a page one time, and serve the same page for all requests: import justpy as jp wp = jp . WebPage ( delete_flag = False ) my_paragraph_design = \"w-64 bg-blue-500 m-2 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\" for i in range ( 1 , 11 ): jp . P ( text = f ' {i} ) Hello World!' , a = wp , classes = my_paragraph_design ) def hello_world (): return wp jp . justpy ( hello_world ) Info When you define a page that is going to be rendered in more than one browser tab or page, you need to set its delete_flag to False . Otherwise, the page (the instance of WebPage to be precise) will be deleted when a browser tab or window that renders that page is closed. The default is for JustPy to remove all references to the page and the elements on it so that the Python garbage collector can reclaim the memory. Warning When a page's (or element's) delete_flag is set to False , none of its child elements will be deleted, even if their delete_flag is True . In the next part of the tutorial you will learn how to deal with events such as a mouse click.","title":"Creating Web Pages Once"},{"location":"tutorial/before_after_events/","text":"The before and after Events \u00b6 Occasionally, you need to do something before an event handler is run, or after the event handler is run. For example, before the input event handler is run, you would like the value of the Python element to reflect the value of the respective input element on the page. Even if you have not assigned an input handler to that particular element, you may want to update the value anyway so it is available for other event handlers or background tasks. In fact, this is what happens with Input and QInput elements. Even when they are not assigned an input event handler, they run an event handler for the before event to correctly update the value of the element. In the example below, a different notification is shown for each button clicked. This is done by setting the show attribute of the notification to True in the click event handler. Then, the after event handler is run, and it sets the show attribute back to False so that it is not displayed next time the page is updated. JustPy updates the page after an event handler for any event that is not before or after is run (unless the event handler does not return None ). JustPy does not update the page after the before and after event handlers. Try running the example below as is and then without binding an after event handler to the buttons and see what happens. import justpy as jp btn_classes = jp . Styles . button_outline + ' m-2' notification_classes = 'm-2 text-center text-xl bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded w-64' def btn_click ( self , msg ): self . nl [ self . list_index ] . show = True def btn_after ( self , msg ): self . nl [ self . list_index ] . show = False def after_demo (): wp = jp . WebPage () btn_list = [] notification_list = [] for index , btn_text in enumerate ([ 'First' , 'Second' , 'Third' ]): btn_list . append ( jp . Button ( text = f ' {btn_text} Button' , classes = btn_classes , a = wp , nl = notification_list , list_index = index , click = btn_click , after = btn_after )) for notification_text in [ 'First' , 'Second' , 'Third' ]: notification_list . append ( jp . Div ( text = f ' {notification_text} Notification' , classes = notification_classes , a = wp , show = False )) return wp jp . justpy ( after_demo )","title":"The before and after Events"},{"location":"tutorial/before_after_events/#the-before-and-after-events","text":"Occasionally, you need to do something before an event handler is run, or after the event handler is run. For example, before the input event handler is run, you would like the value of the Python element to reflect the value of the respective input element on the page. Even if you have not assigned an input handler to that particular element, you may want to update the value anyway so it is available for other event handlers or background tasks. In fact, this is what happens with Input and QInput elements. Even when they are not assigned an input event handler, they run an event handler for the before event to correctly update the value of the element. In the example below, a different notification is shown for each button clicked. This is done by setting the show attribute of the notification to True in the click event handler. Then, the after event handler is run, and it sets the show attribute back to False so that it is not displayed next time the page is updated. JustPy updates the page after an event handler for any event that is not before or after is run (unless the event handler does not return None ). JustPy does not update the page after the before and after event handlers. Try running the example below as is and then without binding an after event handler to the buttons and see what happens. import justpy as jp btn_classes = jp . Styles . button_outline + ' m-2' notification_classes = 'm-2 text-center text-xl bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded w-64' def btn_click ( self , msg ): self . nl [ self . list_index ] . show = True def btn_after ( self , msg ): self . nl [ self . list_index ] . show = False def after_demo (): wp = jp . WebPage () btn_list = [] notification_list = [] for index , btn_text in enumerate ([ 'First' , 'Second' , 'Third' ]): btn_list . append ( jp . Button ( text = f ' {btn_text} Button' , classes = btn_classes , a = wp , nl = notification_list , list_index = index , click = btn_click , after = btn_after )) for notification_text in [ 'First' , 'Second' , 'Third' ]: notification_list . append ( jp . Div ( text = f ' {notification_text} Notification' , classes = notification_classes , a = wp , show = False )) return wp jp . justpy ( after_demo )","title":"The before and after Events"},{"location":"tutorial/bokeh/","text":"Bokeh Charts \u00b6 Bokeh charts can be added to a web page using the BokehChart component. If you plan to update the chart, set the style or classes of the element to the height of the chart. This will eliminate flicker on update. The example below puts three bokeh charts on the page. import justpy as jp import bokeh bokeh . sampledata . download () # Run this the first time you run the program from bokeh.plotting import figure , output_file , show from bokeh.sampledata.iris import flowers from bokeh.embed.standalone import json_item from bokeh.models import LogColorMapper from bokeh.palettes import Viridis6 as palette1 from bokeh.plotting import figure from bokeh.sampledata.unemployment import data as unemployment from bokeh.sampledata.us_counties import data as counties1 def create_iris_figure ( * , width = 500 , height = 500 ): colormap = { 'setosa' : 'red' , 'versicolor' : 'green' , 'virginica' : 'blue' } colors = [ colormap [ x ] for x in flowers [ 'species' ]] p = figure ( title = \"Iris Morphology\" , plot_width = width , plot_height = height ) p . xaxis . axis_label = 'Petal Length' p . yaxis . axis_label = 'Petal Width' p . circle ( flowers [ \"petal_length\" ], flowers [ \"petal_width\" ], color = colors , fill_alpha = 0.2 , size = 10 ) return p def create_texas_figure ( * , width = 500 , height = 500 ): palette = tuple ( reversed ( palette1 )) counties = { code : county for code , county in counties1 . items () if county [ \"state\" ] == \"tx\" } county_xs = [ county [ \"lons\" ] for county in counties . values ()] county_ys = [ county [ \"lats\" ] for county in counties . values ()] county_names = [ county [ 'name' ] for county in counties . values ()] county_rates = [ unemployment [ county_id ] for county_id in counties ] color_mapper = LogColorMapper ( palette = palette ) data = dict ( x = county_xs , y = county_ys , name = county_names , rate = county_rates , ) TOOLS = \"pan,wheel_zoom,reset,hover,save\" p = figure ( title = \"Texas Unemployment, 2009\" , tools = TOOLS , x_axis_location = None , y_axis_location = None , tooltips = [ ( \"Name\" , \"@name\" ), ( \"Unemployment rate\" , \"@rate%\" ), ( \"(Long, Lat)\" , \"($x, $y)\" ) ]) p . grid . grid_line_color = None p . hover . point_policy = \"follow_mouse\" p . patches ( 'x' , 'y' , source = data , fill_color = { 'field' : 'rate' , 'transform' : color_mapper }, fill_alpha = 0.7 , line_color = \"white\" , line_width = 0.5 ) return p def bokeh_test ( request ): wp = jp . WebPage ( tailwind = True ) p = create_iris_figure () wp . c = jp . BokehChart ( chart = p , a = wp ) p1 = create_iris_figure ( width = 300 , height = 300 ) jp . BokehChart ( chart = p1 , a = wp ) p2 = create_texas_figure () jp . BokehChart ( chart = p2 , a = wp ) return wp jp . justpy ( bokeh_test , BOKEH = True )","title":"Bokeh Charting"},{"location":"tutorial/bokeh/#bokeh-charts","text":"Bokeh charts can be added to a web page using the BokehChart component. If you plan to update the chart, set the style or classes of the element to the height of the chart. This will eliminate flicker on update. The example below puts three bokeh charts on the page. import justpy as jp import bokeh bokeh . sampledata . download () # Run this the first time you run the program from bokeh.plotting import figure , output_file , show from bokeh.sampledata.iris import flowers from bokeh.embed.standalone import json_item from bokeh.models import LogColorMapper from bokeh.palettes import Viridis6 as palette1 from bokeh.plotting import figure from bokeh.sampledata.unemployment import data as unemployment from bokeh.sampledata.us_counties import data as counties1 def create_iris_figure ( * , width = 500 , height = 500 ): colormap = { 'setosa' : 'red' , 'versicolor' : 'green' , 'virginica' : 'blue' } colors = [ colormap [ x ] for x in flowers [ 'species' ]] p = figure ( title = \"Iris Morphology\" , plot_width = width , plot_height = height ) p . xaxis . axis_label = 'Petal Length' p . yaxis . axis_label = 'Petal Width' p . circle ( flowers [ \"petal_length\" ], flowers [ \"petal_width\" ], color = colors , fill_alpha = 0.2 , size = 10 ) return p def create_texas_figure ( * , width = 500 , height = 500 ): palette = tuple ( reversed ( palette1 )) counties = { code : county for code , county in counties1 . items () if county [ \"state\" ] == \"tx\" } county_xs = [ county [ \"lons\" ] for county in counties . values ()] county_ys = [ county [ \"lats\" ] for county in counties . values ()] county_names = [ county [ 'name' ] for county in counties . values ()] county_rates = [ unemployment [ county_id ] for county_id in counties ] color_mapper = LogColorMapper ( palette = palette ) data = dict ( x = county_xs , y = county_ys , name = county_names , rate = county_rates , ) TOOLS = \"pan,wheel_zoom,reset,hover,save\" p = figure ( title = \"Texas Unemployment, 2009\" , tools = TOOLS , x_axis_location = None , y_axis_location = None , tooltips = [ ( \"Name\" , \"@name\" ), ( \"Unemployment rate\" , \"@rate%\" ), ( \"(Long, Lat)\" , \"($x, $y)\" ) ]) p . grid . grid_line_color = None p . hover . point_policy = \"follow_mouse\" p . patches ( 'x' , 'y' , source = data , fill_color = { 'field' : 'rate' , 'transform' : color_mapper }, fill_alpha = 0.7 , line_color = \"white\" , line_width = 0.5 ) return p def bokeh_test ( request ): wp = jp . WebPage ( tailwind = True ) p = create_iris_figure () wp . c = jp . BokehChart ( chart = p , a = wp ) p1 = create_iris_figure ( width = 300 , height = 300 ) jp . BokehChart ( chart = p1 , a = wp ) p2 = create_texas_figure () jp . BokehChart ( chart = p2 , a = wp ) return wp jp . justpy ( bokeh_test , BOKEH = True )","title":"Bokeh Charts"},{"location":"tutorial/configuration/","text":"Configuration \u00b6 Introduction \u00b6 JustPy is configured by settings in the justpy.env file. The file is not strictly required, as there are defaults for all settings. Here is an example of a configuration file: HIGHCHARTS = True AGGRID = True LOGGING_LEVEL = DEBUG LATENCY = 50 SECRET_KEY = '$$$my_secret_string$$$' Since the default for whether to include the Highcharts library is True , the first line is not required (neither are the second or fifth). Simulating Latency \u00b6 The LATENCY option is one I like to work with. When it is set, JustPy adds the specified milliseconds to each communication between the server and the web pages. In this way you can simulate locally the effect of network latency and see if it hinders the user experience. Working Locally without an Internet Connection \u00b6 If you set the option NO_INTERNET to True , JustPy will not attempt to use the internet to retrieve the JavasScript libraries it needs, and will use instead copies that are part of the package. The downside is that between versions of JustPy, the JavaScript libraries will not be updated to the latest version. Since version 0.1.0 the default for this option is True . Quasar Version \u00b6 New in version 0.1.0 You can specify the Quasar version to use: QUASAR_VERSION = '1.9.4' When NO_INTERNET is true, version 1.9.4 is used.","title":"Configuration"},{"location":"tutorial/configuration/#configuration","text":"","title":"Configuration"},{"location":"tutorial/configuration/#introduction","text":"JustPy is configured by settings in the justpy.env file. The file is not strictly required, as there are defaults for all settings. Here is an example of a configuration file: HIGHCHARTS = True AGGRID = True LOGGING_LEVEL = DEBUG LATENCY = 50 SECRET_KEY = '$$$my_secret_string$$$' Since the default for whether to include the Highcharts library is True , the first line is not required (neither are the second or fifth).","title":"Introduction"},{"location":"tutorial/configuration/#simulating-latency","text":"The LATENCY option is one I like to work with. When it is set, JustPy adds the specified milliseconds to each communication between the server and the web pages. In this way you can simulate locally the effect of network latency and see if it hinders the user experience.","title":"Simulating Latency"},{"location":"tutorial/configuration/#working-locally-without-an-internet-connection","text":"If you set the option NO_INTERNET to True , JustPy will not attempt to use the internet to retrieve the JavasScript libraries it needs, and will use instead copies that are part of the package. The downside is that between versions of JustPy, the JavaScript libraries will not be updated to the latest version. Since version 0.1.0 the default for this option is True .","title":"Working Locally without an Internet Connection"},{"location":"tutorial/configuration/#quasar-version","text":"New in version 0.1.0 You can specify the Quasar version to use: QUASAR_VERSION = '1.9.4' When NO_INTERNET is true, version 1.9.4 is used.","title":"Quasar Version"},{"location":"tutorial/custom_components/","text":"Creating Your Own Components \u00b6 The idea behind component programming is simple and compelling: Build a component once, and then reuse it either in the same application or in different applications. In JustPy, components are Python classes and so are custom components. Creating a component in JustPy means in most cases declaring a new Python class. In some cases, developing complex JustPy components requires also developing a Vue.js component. For example, the HighCharts charting component required developing a Vue.js component. For JustPy to support Quasar components, a Vue.js component was also required. It turns out that all Quasar components can be supported with one Vue.js component and that simplified matters considerably. However, let's start with the basics. Most components require only writing a Python class and no knowledge of Vue.js or JavaScript is required. Some components described here have features that are covered in other parts of the tutorial. Don't feel the need to finish this section in one go. If you find you need to go to other sections and return later, please do so. Pill Button Component \u00b6 Our first component is a very simple one. It is a Button that is formatted to look like a pill . import justpy as jp class PillButton ( jp . Button ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . set_classes ( 'bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full' ) def comp_test (): wp = jp . WebPage () for i in range ( 5 ): PillButton ( text = 'Pill Button' , click = 'self.text=\"I was clicked\"' , a = wp , classes = 'm-2' ) return wp jp . justpy ( comp_test ) Our new component, PillButton, inherits from Button and therefore will have all the attributes and functionality of Button. The only change we make is to redefine __init__ , the method that is called when an instance is created. In this case the method calls the __init__ of the super class (Button in our case) and then sets the classes that format the button. Warning The line super().__init__(**kwargs) is a MUST in component's __init__ Without it, the instances of the components will not be created correctly. In most cases, only default values for keyword arguments should precede it. Let's add a custom attribute to the component that will determine the background color of the button. import justpy as jp class PillButton ( jp . Button ): def __init__ ( self , ** kwargs ): self . bg_color = 'blue' super () . __init__ ( ** kwargs ) self . set_classes ( f 'bg- {self.bg_color} -500 hover:bg- {self.bg_color} -700 text-white font-bold py-2 px-4 rounded-full' ) def comp_test (): wp = jp . WebPage () for color in [ 'blue' , 'red' , 'orange' , 'pink' ]: PillButton ( bg_color = color , text = 'Pill Button' , click = 'self.text=\"I was clicked\"' , a = wp , classes = 'm-2' ) return wp jp . justpy ( comp_test ) When we create the PillButton instances we set the attribute bg_color . Each of the four PillButton instances will have a different background color. Notice that the default for bg_color is 'blue' and it is set before the line super().__init__(**kwargs) . This allows it to be overwritten by the keyword arguments. Try moving the line setting the default after the line calling the super and see what happens. Instead of setting the defaults for your attributes in __init__ you can set a class attribute like so: class PillButton ( jp . Button ): bg_color = 'blue' def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . set_classes ( f 'bg- {self.bg_color} -500 hover:bg- {self.bg_color} -700 text-white font-bold py-2 px-4 rounded-full' ) Both methods work the same as Python uses the class attribute if it does not find an instance attribute. Alert Component \u00b6 This component is based on this example from the Tailwind documentation. The HTML the component is based on looks like this: html_string = \"\"\" <div class=\"bg-teal-100 border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md\" role=\"alert\"> <div class=\"flex\"> <div class=\"py-1\"> <svg class=\"fill-current h-6 w-6 text-teal-500 mr-4\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\"> <path d=\"M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z\"/></svg> </div> <div> <p class=\"font-bold\">Our privacy policy has changed</p> <p class=\"text-sm\">Make sure you know how these changes affect you.</p> </div> </div> </div> \"\"\" We will use parse_html to easily convert this to JustPy commands. Run the following program. As it does not start a web server, there is no need to load a web page. We will be interested only in the printout. import justpy as jp # Example based on https://tailwindcss.com/components/alerts/#top-accent-border html_string = \"\"\" <div class=\"bg-teal-100 border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md\" role=\"alert\"> <div class=\"flex\"> <div class=\"py-1\"> <svg class=\"fill-current h-6 w-6 text-teal-500 mr-4\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\"> <path d=\"M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z\"/></svg> </div> <div> <p class=\"font-bold\">Our privacy policy has changed</p> <p class=\"text-sm\">Make sure you know how these changes affect you.</p> </div> </div> </div> \"\"\" d = jp . parse_html ( html_string ) for c in d . commands : print ( c ) The printout is the following: root = jp . Div ( name = 'root' ) c1 = jp . Div ( classes = 'bg-teal-100 border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md' , role = 'alert' , a = root ) c2 = jp . Div ( classes = 'flex' , a = c1 ) c3 = jp . Div ( classes = 'py-1' , a = c2 ) c4 = jp . Svg ( classes = 'fill-current h-6 w-6 text-teal-500 mr-4' , xmlns = 'http://www.w3.org/2000/svg' , viewBox = '0 0 20 20' , a = c3 ) c5 = jp . Path ( d = 'M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z' , a = c4 ) c6 = jp . Div ( a = c2 ) c7 = jp . P ( classes = 'font-bold' , a = c6 , text = 'Our privacy policy has changed' ) c8 = jp . P ( classes = 'text-sm' , a = c6 , text = 'Make sure you know how these changes affect you.' ) These are the JustPy commands required to duplicate the elements defined in the HTML. We are now are ready to define our component. We will call it MyAlert . import justpy as jp class MyAlert ( jp . Div ): def __init__ ( self , ** kwargs ): self . title_text = 'This is the title' self . body_text = 'This is the body' super () . __init__ ( ** kwargs ) # Important! see below root = self c1 = jp . Div ( classes = 'bg-teal-100 border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md' , role = 'alert' , a = root ) c2 = jp . Div ( classes = 'flex' , a = c1 ) c3 = jp . Div ( classes = 'py-1' , a = c2 ) c4 = jp . Svg ( classes = 'fill-current h-6 w-6 text-teal-500 mr-4' , xmlns = 'http://www.w3.org/2000/svg' , viewBox = '0 0 20 20' , a = c3 ) c5 = jp . Path ( d = 'M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z' , a = c4 ) c6 = jp . Div ( a = c2 ) c7 = jp . P ( classes = 'font-bold text-lg' , a = c6 , text = self . title_text ) c8 = jp . P ( classes = 'text-sm' , a = c6 , text = self . body_text ) def alert_test (): wp = jp . WebPage () d = MyAlert ( a = wp , classes = 'm-2 w-1/4' , title_text = 'hello' , body_text = 'How is everybody?' ) d . title_text = 'Shalom' return wp jp . justpy ( alert_test ) Warning The line super().__init__(**kwargs) is a MUST in custom component's __init__ Without it, the instances of the components will not be created correctly. Only default values for keyword arguments should precede it. When you run the program above, notice that the title of the MyAlert instance is rendered as 'Hello' instead of 'Shalom' even though the line d.title_text = 'Shalom' is executed after it is created (this problem also exists with the PillButton component we defined above). To fix this bug we need to assign the attributes title_text and body_text to the text of the appropriate elements when the instance is rendered, not when it is created. Note As part of the rendering process, JustPy converts class instances to a Python dictionary representation that will later be sent as JSON to the web page and will be the input to the Vue.js frontend. This is done using the convert_object_to_dict method that each component class has. The react Method \u00b6 Every JustPy component supports the react method. It is run just just before a class instance is converted to a dictionary. It receives two arguments, the instance and the data attribute of its parent element or that of the WebPage if it has no parent. In base JustPy elements, react does nothing. It is there to be overridden in user defined components. The modified program looks like this: import justpy as jp class MyAlert ( jp . Div ): def __init__ ( self , ** kwargs ): self . title_text = 'This is the title' self . body_text = 'This is the body' super () . __init__ ( ** kwargs ) root = self c1 = jp . Div ( classes = 'bg-teal-100 border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md' , role = 'alert' , a = root ) c2 = jp . Div ( classes = 'flex' , a = c1 ) c3 = jp . Div ( classes = 'py-1' , a = c2 ) c4 = jp . Svg ( classes = 'fill-current h-6 w-6 text-teal-500 mr-4' , xmlns = 'http://www.w3.org/2000/svg' , viewBox = '0 0 20 20' , a = c3 ) c5 = jp . Path ( d = 'M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z' , a = c4 ) c6 = jp . Div ( a = c2 ) c7 = jp . P ( classes = 'font-bold text-lg' , a = c6 , text = self . title_text ) c8 = jp . P ( classes = 'text-sm' , a = c6 , text = self . body_text ) self . title_p = c7 self . body_p = c8 def react ( self , data ): self . title_p . text = self . title_text self . body_p . text = self . body_text self . text = '' greetings = [ 'Bonjour' , 'Hola' , 'Zdravstvuyte' , 'N\u01d0n h\u01ceo' , 'Salve' , 'Konnichiwa' , 'Guten Tag' , 'Ol\u00e1' , 'Anyoung haseyo' , 'Asalaam alaikum' , 'Goddag' , 'Shikamoo' , 'Goedendag' , 'Yassas' , 'Dzie\u0144 dobry' , 'Selamat siang' , 'Namaste' , 'Merhaba' , 'Shalom' , ' God dag' ] def translate ( self , msg ): self . title_text = 'Hello' def alert_test (): wp = jp . WebPage () for greeting in greetings : d = MyAlert ( a = wp , classes = 'm-2 w-1/4' , title_text = 'hello' , body_text = 'How is everybody?' ) d . on ( 'click' , translate ) d . title_text = greeting return wp jp . justpy ( alert_test ) At the end of __init__ we added the two lines: self . title_p = c7 self . body_p = c8 These two attributes now hold the paragraphs where the title and body will be placed. In the react method, the text attributes of the paragraphs are set. Just as a precaution, the text attribute of the parent element is set to the empty string (if it is not empty, the text will be rendered and the result will not be what we want). In the request handler, alert_test , we use the new component to render alerts with greetings in different languages. We also added an event handler for the mouse click that changes the title to \"Hello\". We now have a component, MyAlert that we can reuse as we please in any project (and of course share with our fellow programmers). Date Card Component \u00b6 Here is an example of a simple date card component based on this design. import justpy as jp class CalendarDate ( jp . Div ): def __init__ ( self , ** kwargs ): self . month = 'Jan' self . year = '2010' self . weekday = 'Sun' self . day = '1' self . color = 'red' super () . __init__ ( ** kwargs ) self . inner_html = f \"\"\" <div class=\"w-24 rounded-t overflow-hidden bg-white text-center m-2 cursor-default\"> <div class=\"bg- {self.color} -500 text-white py-1\"> {self.month} </div> <div class=\"pt-1 border-l border-r\"> <span class=\"text-4xl font-bold\"> {self.day} </span> </div> <div class=\"pb-2 px-2 border-l border-r border-b rounded-b flex justify-between\"> <span class=\"text-xs font-bold\"> {self.weekday} </span> <span class=\"text-xs font-bold\"> {self.year} </span> </div> </div> \"\"\" def comp_test (): wp = jp . WebPage () year = 2019 month = 'Feb' d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for day in range ( 1 , 11 ): CalendarDate ( day = day , month = month , year = year , color = 'teal' , a = d , animation = 'bounceIn' ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for day in range ( 5 , 26 ): CalendarDate ( day = day , month = 'Jul' , year = '2005' , color = 'yellow' , a = d ) return wp jp . justpy ( comp_test ) In this custom component we are using the template like behavior of Python f-strings to create a date card with some features that can be changed. This simple component inherits from the component Div . It changes only the __init__ method and inherits all the others. Notice the super().__init__(**kwargs) line in __init__ . It is required to take care of all the plumbing that goes along with a JustPy component. This line executes the __init__ of Div . We define the defaults for the component specific attributes before this line so as not to overwrite keyword arguments that the user has provided and are assigned to attributes in the superclass __init__ . This component works well enough but has a flaw. The inner_html attribute is set in __init__ when the instance is created. If for example, the instance's day attribute is changed after __init__ has run, it would not be reflected in the inner html and the component will not be rendered correctly. To solve this problem, we need to move setting inner_html from the time the instance was created to the time it is rendered. Every JustPy component has a method called react that is called each time before the object is converted to a dict. The example above can therefore be written as follows: import justpy as jp class CalendarDate ( jp . Div ): def __init__ ( self , ** kwargs ): self . month = 'Jan' self . year = '2010' self . weekday = 'Sun' self . day = '1' self . color = 'red' super () . __init__ ( ** kwargs ) def react ( self , data ): self . inner_html = f \"\"\" <div class=\"w-24 rounded-t overflow-hidden bg-white text-center m-2 cursor-default\"> <div class=\"bg- {self.color} -500 text-white py-1\"> {self.month} </div> <div class=\"pt-1 border-l border-r\"> <span class=\"text-4xl font-bold\"> {self.day} </span> </div> <div class=\"pb-2 px-2 border-l border-r border-b rounded-b flex justify-between\"> <span class=\"text-xs font-bold\"> {self.weekday} </span> <span class=\"text-xs font-bold\"> {self.year} </span> </div> </div> \"\"\" def comp_test (): wp = jp . WebPage () year = 2019 month = 'Feb' d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for day in range ( 1 , 11 ): CalendarDate ( day = day , month = month , year = year , color = 'teal' , a = d , animation = 'bounceIn' ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for day in range ( 5 , 26 ): c = CalendarDate ( day = day , month = 'Jul' , year = '2005' , color = 'yellow' , a = d ) c . day += 1 # Notice how the date starts from 6 and not from 5. return wp jp . justpy ( comp_test ) The react method accepts an additional argument to self. The argument data is the data attribute of the element's direct parent. If the element has no parent, it is the data attribute of the page. Using react we can have child elements change their behavior when rendered based on the data attribute of their parent or the page they are on. For example, let's make the color of the component dependent on the data attribute of their parent container. import justpy as jp class CalendarDate ( jp . Div ): def __init__ ( self , ** kwargs ): self . month = 'Jan' self . year = '2010' self . weekday = 'Sun' self . day = '1' self . color = 'red' super () . __init__ ( ** kwargs ) def react ( self , data ): self . inner_html = f \"\"\" <div class=\"w-24 rounded-t overflow-hidden bg-white text-center m-2 cursor-default\"> <div class=\"bg- {data['color']} -500 text-white py-1\"> {self.month} </div> <div class=\"pt-1 border-l border-r\"> <span class=\"text-4xl font-bold\"> {self.day} </span> </div> <div class=\"pb-2 px-2 border-l border-r border-b rounded-b flex justify-between\"> <span class=\"text-xs font-bold\"> {self.weekday} </span> <span class=\"text-xs font-bold\"> {self.year} </span> </div> </div> \"\"\" def change_color ( self , msg ): self . d . data [ \"color\" ] = self . value def comp_test (): wp = jp . WebPage () year = 2019 month = 'Feb' d = jp . Div ( classes = 'flex flex-wrap' , a = wp , data = { 'color' : 'purple' }) for day in range ( 1 , 11 ): CalendarDate ( day = day , month = month , year = year , color = 'teal' , a = d ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp , data = { 'color' : 'red' }) for day in range ( 5 , 26 ): c = CalendarDate ( day = day , month = 'Jul' , year = '2005' , color = 'yellow' , a = d ) c . day += 1 # Notice how the date starts from 6 and not from 5. colors = [ 'red' , 'green' , 'blue' , 'pink' , 'yellow' , 'teal' , 'purple' ] s = jp . Select ( classes = 'w-32 text-xl m-2 p-2 bg-white border rounded-full' , a = wp , value = 'red' , change = change_color ) s . d = d for color in colors : s . add ( jp . Option ( value = color , text = color , classes = f 'bg- {color} -600' )) return wp jp . justpy ( comp_test ) This example is a little more complex as we have added a Select component at the bottom of the page. Try changing the selected color. The color of the CalendarDate instances in the second group changes because in the event handler, change_color we change the data attribute of the parent Div, d . The function change_color sets the value of the 'color' key in the data dictionary of the Div that holds the CalendarDate instances to the new value of the Select element. In this example, we changed the react function so it uses this value instead of self.color (which was used in the previous example) to set the color to display. A few more words about Select: A Select component includes Option components. In this example we add them to the Select using a predefined list of colors. When a specific option is selected, its value attribute becomes the value attribute of the Select. The change in value is acted upon by binding a method to the change event of the Select instance. Hello Component \u00b6 JustPy comes with a simple Hello component, which we will now examine. First run the following short program. import justpy as jp def hello_test (): wp = jp . WebPage () h = jp . Hello () for i in range ( 5 ): wp . add ( h ) return wp jp . justpy ( hello_test ) The program puts five Hello elements on the page. Click any one of them. All five will show the number of times any element was clicked because each time through the loop, we add the same element to the page. There may be 5 rendered elements on the page, but for JustPy, these are the same element. If we would like there to be independent components on the page, we would write the program in the following way: import justpy as jp def hello_test (): wp = jp . WebPage () for i in range ( 5 ): wp . add ( jp . Hello ()) # or jp.Hello(a=wp) return wp jp . justpy ( hello_test ) In this program, each time thorough the loop we create a new Hello element and add it to the page. When any element is clicked, no other element on the page is affected. Let's look more closely at the Hello component. This is the way it is defined: class Hello ( Div ): def __init__ ( self , ** kwargs ): self . counter = 1 super () . __init__ ( ** kwargs ) self . classes = 'm-1 p-1 text-2xl text-center text-white bg-blue-500 hover:bg-blue-800 cursor-pointer' self . text = 'Hello! (click me)' def click ( self , msg ): self . text = f 'Hello! I was clicked {self.counter} times' self . counter += 1 self . on ( 'click' , click ) Again, JustPy components are Python classes. In our case, Hello inherits from Div and only changes Div 's __init__ . In __init__ we first initialize a counter for the instance. This is a new attribute that is not initialized by Div . Then we call the super class __init__ , in our case the __init__ of Div. This call provides Hello with the initializations required to work correctly inside the JustPy framework. Since we are calling the super class __init__ after having provided a default value to the counter attribute, we can overwrite it with a keyword argument. Try running the following: import justpy as jp def hello_test (): wp = jp . WebPage () for i in range ( 5 ): jp . Hello ( a = wp , counter = 100 ) return wp jp . justpy ( hello_test ) Since counter is initialized to 100, the components will start counting from 100. The call to the super class __init__ takes care of assigning the keyword arguments. If we had put the initialization of counter after the call to the super class __init__ , the keyword argument would have had no effect. Next, in the definition of Hello , we set the classes of the component to give it some basic design and we set the text. Then we define the click event handler and assign it to the instance. That's it. Let's say we are not pleased with the Hello message and its colors and want to define a better Hello component. This is how we would do it: import justpy as jp class MyHello ( jp . Hello ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . classes = 'm-1 p-1 text-6xl text-center text-red-500 bg-yellow-500 hover:bg-yellow-800 cursor-pointer' self . text = 'Much Better Hello! (click me)' def hello_test (): wp = jp . WebPage () for i in range ( 5 ): MyHello ( a = wp , counter = 100 ) return wp jp . justpy ( hello_test ) We define a new component called MyHello which inherits from Hello . By running the super class __init__ in the __init__ of MyHello , we get all the functionality of Hello . We then just modify the classes and text. Calculator Component \u00b6 Base component \u00b6 We will build a calculator component in stages. First, we will create a component that does not handle events or the model attribute. Please run the following example. from justpy import Div , Input , Button , WebPage , justpy class Calculator ( Div ): btn_classes = 'w-1/4 text-xl font-bold p-2 m-1 border bg-gray-200 hover:bg-gray-700 shadow' layout_text = [[ '7' , '8' , '9' , '*' ], [ '4' , '5' , '6' , '-' ], [ '1' , '2' , '3' , '+' ], [ 'C' , '0' , '.' , '=' ]] def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . value = 0 self . tape = Input ( classes = 'block p-2 m-2 border text-right text-sm bg-gray-200' , a = self , readonly = True , value = ' ' , style = 'width: 90%' ) self . result = Input ( classes = 'block p-2 m-2 border text-2xl text-right' , a = self , readonly = True , value = '0' , style = 'width: 90%' ) for line in self . __class__ . layout_text : d = Div ( classes = 'flex w-auto m-2' , a = self ) for b in line : b1 = Button ( text = b , a = d , classes = self . __class__ . btn_classes , click = self . calculator_click ) b1 . calc = self @staticmethod def calculator_click ( self , msg ): calc = self . calc if self . text == 'C' : calc . result . value = '0' calc . tape . value = ' ' calc . value = 0 elif self . text == '=' : calc . result . value = str ( eval ( calc . tape . value )) calc . value = eval ( calc . tape . value ) calc . tape . value = calc . result . value else : if calc . tape . value [ - 1 ] in '*+-/' or self . text in '*+-/' : calc . tape . value += ' ' + self . text else : calc . tape . value += self . text try : calc . result . value = str ( eval ( calc . tape . value )) calc . value = eval ( calc . tape . value ) except : pass def calculator_test (): wp = WebPage () for i in range ( 10 ): c = Calculator ( a = wp , classes = 'm-1 border inline-block' , style = 'width: 250px' ) return wp justpy ( calculator_test ) First let's look at the function calculator_test . This function creates a WebPage and adds ten instances of the Calculator component to it. Try changing the number of calculators on the page by changing the argument to range. Once a JustPy component has been defined, it is simple to reuse it. The Calculator component can be used now in multiple projects. JustPy components are Python classes. The Calculator component is therefore a Python class. The Calculator class inherits from Div so Calculator is endowed from the start will all the features and capabilities of the Div component. These features are used in __init__ , in order to add the other components needed to implement the calculator. The class __init__ first calls the class __init__ of the super class (in this case Div). If a class inherits from another JustPy component, you must run the __init__ of the super class. It then sets the value attribute to 0 and adds two Input components, one for the tape and one for the result. The two Inputs are assigned to instance attributes for future reference and added to self (which is a Div and therefore other components can be added to it). The Inputs are also designated readonly so that the user cannot type in them. After the two Input elements are added to the instance, two nested loops are used to add the calculator buttons based on the layout list which is a list of lists. Each child list represents a line of buttons. Each button is assigned the same click event handler, self.calculator_click which is a static method of the Calculator class (we could have defined the event handler inside the __init__ function instead). We also assign to the button calc attribute a reference to the Calculator instance of which the button is part of. This is used in the click event handler to set the value of the Calculator instance. In this example, for the sake of brevity, we implemented a very simple state machine for the calculator that is not perfect (for example, it does not handle 0 in front of a number), but for our purposes, it will do. The state machine is inside the calculator_click event handler. All buttons on the calculator use the same event handler but it differentiates between the buttons based on self.text which is unique for each button. Handling the change event \u00b6 As it is currently defined, Calculator does not support any useful events. We would like to add a meaningful change event to it. This event will fire when the value of the Calculator instance changes. We do this by modifying the click event handler of the buttons. The value of the Calculator instance does not change unless some button is clicked. We therefore check if the specific button click changed the value and if that is the case, we run the change event handler of the Calculator instance. This is how the result looks like: from justpy import Div , Input , Button , WebPage , justpy class Calculator ( Div ): btn_classes = 'w-1/4 text-xl font-bold p-2 m-1 border bg-gray-200 hover:bg-gray-700 shadow' layout_text = [[ '7' , '8' , '9' , '*' ], [ '4' , '5' , '6' , '-' ], [ '1' , '2' , '3' , '+' ], [ 'C' , '0' , '.' , '=' ]] def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . value = 0 self . tape = Input ( classes = 'block p-2 m-2 border text-right text-sm bg-gray-200' , a = self , readonly = True , value = ' ' , style = 'width: 90%' ) self . result = Input ( classes = 'block p-2 m-2 border text-2xl text-right' , a = self , readonly = True , value = '0' , style = 'width: 90%' ) for line in type ( self ) . layout_text : d = Div ( classes = 'flex w-auto m-2' , a = self ) for b in line : b1 = Button ( text = b , a = d , classes = type ( self ) . btn_classes , click = self . calculator_click ) b1 . calc = self @staticmethod async def calculator_click ( self , msg ): calc = self . calc try : tape_value = eval ( calc . tape . value ) except : tape_value = 0 changed = False if self . text == 'C' : calc . result . value = '0' calc . tape . value = ' ' if calc . value != 0 : calc . value = 0 changed = True elif self . text == '=' : if calc . value != tape_value : calc . value = tape_value changed = True calc . result . value = str ( tape_value ) calc . tape . value = str ( tape_value ) else : if calc . tape . value [ - 1 ] in '*+-/' or self . text in '*+-/' : calc . tape . value += ' ' + self . text else : calc . tape . value += self . text try : tape_value = eval ( calc . tape . value ) calc . result . value = str ( tape_value ) if calc . value != tape_value : calc . value = tape_value changed = True except : pass if changed : if calc . has_event_function ( 'change' ): calc_msg = msg calc_msg . event_type = 'change' calc_msg . id = calc . id calc_msg . button_text = self . text calc_msg . value = calc . value calc_msg . class_name = calc . __class__ . __name__ return await calc . run_event_function ( 'change' , calc_msg ) def calc_change ( self , msg ): print ( 'In change' ) print ( msg ) self . d . text = self . value def calculator_test (): wp = WebPage () c = Calculator ( a = wp , classes = 'm-1 border inline-block' , style = 'width: 250px' , change = calc_change ) d = Div ( classes = 'border m-2 p-1 w-64 text-xl' , text = '0' , a = wp ) c . d = d return wp justpy ( calculator_test ) Run the program above. You will see that the value of the calculator is reflected in the Div below it since that is what we defined the change event handler to do. In the click event handler we use a flag called changed that is set to True by the state machine logic if an operation that changes the value of the calculator occurs. At the end of the event handler, we check if changed is True . If it is, we check whether the instance has a change event handler. We do this by using the method has_event_function which is a basic method of all JustPy components. If there is a change event handler, we run the event handler using the run_event_function method which is also a basic method of all JustPy components. This method takes two arguments in addition to self . The first is the event type. The second, is the dictionary we want passed as the second positional argument to the event handler. This is what we usually designate as msg in our event handlers. Before calling run_event_function we modify some values in msg to make it more informative. In general, you would create the appropriate msg for how you believe the component will be used. In our case we have added the button_text key which stores the text of the last button that was clicked and that generated the change event. Note Please note that run_event_function is an async method and therefore since calculator_click awaits it, it needs to be a coroutine also and is defined using async. Adding a model attribute \u00b6 To make Calculator complete, we will also add handling of the model attribute to it. This is quite simple in our case. First, we need to remember that Calculator inherits from Div and is a derived (child) class of Div. The Div model_update method sets the Div instance's text attribute to the model. Therefore, we need to override it to do nothing so we don't see the value as text at the top of the calculator. Try removing the model_update method from the example below and see what happens. from justpy import Div , Input , Button , WebPage , justpy class Calculator ( Div ): btn_classes = 'w-1/4 text-xl font-bold p-2 m-1 border bg-gray-200 hover:bg-gray-700 shadow' layout_text = [[ '7' , '8' , '9' , '*' ], [ '4' , '5' , '6' , '-' ], [ '1' , '2' , '3' , '+' ], [ 'C' , '0' , '.' , '=' ]] def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . value = 0 self . tape = Input ( classes = 'block p-2 m-2 border text-right text-sm bg-gray-200' , a = self , readonly = True , value = ' ' , style = 'width: 90%' ) self . result = Input ( classes = 'block p-2 m-2 border text-2xl text-right' , a = self , readonly = True , value = '0' , style = 'width: 90%' ) for line in type ( self ) . layout_text : d = Div ( classes = 'flex w-auto m-2' , a = self ) for b in line : b1 = Button ( text = b , a = d , classes = type ( self ) . btn_classes , click = self . calculator_click ) b1 . calc = self @staticmethod async def calculator_click ( self , msg ): calc = self . calc try : tape_value = eval ( calc . tape . value ) except : tape_value = 0 changed = False if self . text == 'C' : calc . result . value = '0' calc . tape . value = ' ' if calc . value != 0 : calc . value = 0 changed = True elif self . text == '=' : if calc . value != tape_value : calc . value = tape_value changed = True calc . result . value = str ( tape_value ) calc . tape . value = str ( tape_value ) else : if calc . tape . value [ - 1 ] in '*+-/' or self . text in '*+-/' : calc . tape . value += ' ' + self . text else : calc . tape . value += self . text try : tape_value = eval ( calc . tape . value ) calc . result . value = str ( tape_value ) if calc . value != tape_value : calc . value = tape_value changed = True except : pass if changed : calc . set_model ( calc . value ) #******************** updates model if calc . has_event_function ( 'change' ): calc_msg = msg calc_msg . event_type = 'change' calc_msg . id = calc . id calc_msg . button_text = self . text calc_msg . value = calc . value calc_msg . class_name = calc . __class__ . __name__ return await calc . run_event_function ( 'change' , calc_msg ) def model_update ( self ): pass def calculator_test (): wp = WebPage ( data = { 'value' : 0 }) Calculator ( a = wp , classes = 'm-1 border inline-block' , style = 'width: 250px' , model = [ wp , 'value' ]) for i in range ( 5 ): Div ( classes = 'border m-2 p-1 w-64 text-xl' , text = '0' , a = wp , model = [ wp , 'value' ]) return wp justpy ( calculator_test ) Notice that we have added a call to the method set_model in the click event handler. This method checks if the component has a model attribute and if so, sets it to the method's argument. The set_model method is defined as follows: def set_model ( self , value ): if hasattr ( self , 'model' ): self . model [ 0 ] . data [ self . model [ 1 ]] = value The model attribute, as we defined it above is one directional. The component only sets model value but does not change any of its other attribute values based on changes in model . Tab Group Component \u00b6 This component allows inserting content in tabs and displaying it based on the tab selected. If the animation attribute is set to True , the transition between tabs is animated. The type of animation and its speed can also be set. A tab is added by calling the add_tab method. This method accepts three arguments (in addition to self). The first is the id of the tab. When the tab is selected, its value will become the id of the tab selected. Converesely, when the value attribute is set, if a tab with a corresponding id exists, it will be shown. The second argument is the label to display for the tab's selection. The third argument is the content of the tab. Typically it would be a container element such as a Div instance that contains other elements. In this component, the method convert_object_to_dict , is overridden. This is the method that executes each time an instance of the component is rendered. It is simpler in this case than using the react method that is called by the super class convert_object_to_dict . It also allows the flexibility of overriding the react method in components that inherit from the Tabs component. Below we also define another component, TabPills, that inherits from Tabs and just changes the appearance of the tabs label line. It does so by just changing a few class variables. Tip When creating custom components, it makes sense to make the design a function of class variables. This simplifies creating new components with a different design. In the example below we use three tab components to display charts and pictures. from justpy import Div , WebPage , Ul , Li , HighCharts , A , justpy import justpy as jp class Tabs ( Div ): tab_label_classes = 'overflow-hidden cursor-pointer bg-white inline-block py-2 px-4 text-blue-500 hover:text-blue-800 font-semibold' tab_label_classes_selected = 'overflow-hidden cursor-pointer bg-white inline-block border-l border-t border-r rounded-t py-2 px-4 text-blue-700 font-semibold' item_classes = 'flex-shrink mr-1' item_classes_selected = 'flex-shrink -mb-px mr-1' wrapper_style = 'display: flex; position: absolute; width: 100%; height: 100%; align-items: center; justify-content: center; background-color: #fff;' def __init__ ( self , ** kwargs ): self . tabs = [] # list of {'id': id, 'label': label, 'content': content} self . value = None # The value of the tabs component is the id of the selected tab self . content_height = 500 self . last_rendered_value = None self . animation = False self . animation_next = 'slideInRight' self . animation_prev = 'slideOutLeft' self . animation_speed = 'faster' # '' | 'slow' | 'slower' | 'fast' | 'faster' super () . __init__ ( ** kwargs ) self . tab_list = Ul ( classes = \"flex flex-wrap border-b\" , a = self ) self . content_div = Div ( a = self ) self . delete_list = [] def __setattr__ ( self , key , value ): if key == 'value' : try : self . previous_value = self . value except : pass self . __dict__ [ key ] = value def add_tab ( self , id , label , content ): self . tabs . append ({ 'id' : id , 'label' : label , 'content' : content }) if not self . value : self . value = id def get_tab_by_id ( self , id ): for tab in self . tabs : if tab [ 'id' ] == id : return tab return None def set_content_div ( self , tab ): self . content_div . add ( tab [ 'content' ]) self . content_div . set_classes ( 'relative overflow-hidden border' ) self . content_div . style = f 'height: {self.content_height} px' def set_content_animate ( self , tab ): self . wrapper_div_classes = self . animation_speed # Component in this will be centered if self . previous_value : self . wrapper_div = Div ( classes = self . wrapper_div_classes , animation = self . animation_next , temp = True , style = f ' {self.wrapper_style} z-index: 50;' , a = self . content_div ) self . wrapper_div . add ( tab [ 'content' ]) self . wrapper_div = Div ( classes = self . wrapper_div_classes , animation = self . animation_prev , temp = True , style = f ' {self.wrapper_style} z-index: 0;' , a = self . content_div ) self . wrapper_div . add ( self . get_tab_by_id ( self . previous_value )[ 'content' ]) else : self . wrapper_div = Div ( classes = self . wrapper_div_classes , temp = True , a = self . content_div , style = self . wrapper_style ) self . wrapper_div . add ( tab [ 'content' ]) self . content_div . set_classes ( 'relative overflow-hidden border' ) self . content_div . style = f 'height: {self.content_height} px' def model_update ( self ): val = self . model [ 0 ] . data [ self . model [ 1 ]] if self . get_tab_by_id ( val ): self . value = val def delete ( self ): for c in self . delete_list : c . delete_flag = True c . delete () c . needs_deletion = False if self . delete_flag : for tab in self . tabs : tab [ 'content' ] . delete () tab [ 'content' ] = None super () . delete () @staticmethod async def tab_click ( self , msg ): if self . tabs . value != self . tab_id : previous_tab = self . tabs . value self . tabs . value = self . tab_id if hasattr ( self . tabs , 'model' ): self . tabs . model [ 0 ] . data [ self . tabs . model [ 1 ]] = self . tabs . value # Run change if it exists if self . tabs . has_event_function ( 'change' ): msg . previous_tab = previous_tab msg . new_tab = self . tabs . value msg . id = self . tabs . id msg . value = self . tabs . value msg . class_name = self . tabs . __class__ . __name__ return await self . tabs . run_event_function ( 'change' , msg ) else : return True # No need to update page def convert_object_to_dict ( self ): if hasattr ( self , 'model' ): self . model_update () self . set_classes ( 'flex flex-col' ) self . tab_list . delete_components () self . content_div . components = [] for tab in self . tabs : if tab [ 'id' ] != self . value : tab_li = Li ( a = self . tab_list , classes = self . item_classes ) li_item = A ( text = tab [ 'label' ], classes = self . tab_label_classes , a = tab_li , delete_flag = False ) self . delete_list . append ( li_item ) else : tab_li = Li ( a = self . tab_list , classes = self . item_classes_selected ) li_item = A ( text = tab [ 'label' ], classes = self . tab_label_classes_selected , a = tab_li , delete_flag = False ) self . delete_list . append ( li_item ) if self . animation and ( self . value != self . last_rendered_value ): self . set_content_animate ( tab ) else : self . set_content_div ( tab ) li_item . tab_id = tab [ 'id' ] li_item . tabs = self li_item . on ( 'click' , self . tab_click ) self . last_rendered_value = self . value d = super () . convert_object_to_dict () return d class TabsPills ( Tabs ): tab_label_classes = 'cursor-pointer inline-block border border-white rounded hover:border-gray-200 text-blue-500 hover:bg-gray-200 py-1 px-3' tab_label_classes_selected = 'cursor-pointer inline-block border border-blue-500 rounded py-1 px-3 bg-blue-500 text-white' item_classes = 'flex-shrink mr-3' item_classes_selected = 'flex-shrink -mb-px mr-3' my_chart_def = \"\"\" { chart: { type: 'bar' }, title: { text: 'Fruit Consumption' }, xAxis: { categories: ['Apples', 'Bananas', 'Oranges'] }, yAxis: { title: { text: 'Fruit eaten' } }, series: [{ name: 'Jane', data: [1, 0, 4], animation: false }, { name: 'John', data: [5, 7, 3], animation: false }] } \"\"\" # https://dog.ceo/api/breed/papillon/images/random pics_french_bulldogs = [ '5458' , '7806' , '5667' , '4860' ] pics_papillons = [ '5037' , '2556' , '7606' , '8241' ] def tab_change ( self , msg ): print ( 'in change' , msg ) def tab_comp_test (): wp = jp . WebPage ( data = { 'tab' : 'id2556' }) t = Tabs ( a = wp , classes = 'w-3/4 m-4' , style = '' , animation = True , content_height = 550 ) for chart_type in [ 'bar' , 'column' , 'line' , 'spline' ]: d = jp . Div ( style = Tabs . wrapper_style , delete_flag = True ) my_chart = jp . HighCharts ( a = d , classes = 'm-2 p-2 border' , style = 'width: 1000px;' , options = my_chart_def , use_cache = False ) my_chart . options . chart . type = chart_type my_chart . options . title . text = f 'Chart of Type {chart_type.capitalize()}' my_chart . options . subtitle . text = f 'Subtitle {chart_type.capitalize()}' t . add_tab ( f 'id {chart_type} ' , f ' {chart_type} ' , d ) d_flex = Div ( classes = 'flex' , a = wp ) # Container for the two dog pictures tabs t = Tabs ( a = d_flex , classes = ' w-1/2 m-4' , animation = True , content_height = 550 , model = [ wp , 'tab' ], change = tab_change ) for pic_id in pics_papillons : d = jp . Div ( style = Tabs . wrapper_style ) jp . Img ( src = f 'https://images.dog.ceo/breeds/papillon/n02086910_ {pic_id} .jpg' , a = d ) t . add_tab ( f 'id {pic_id} ' , f 'Pic {pic_id} ' , d ) t = TabsPills ( a = d_flex , classes = 'w-1/2 m-4' , animation = True , content_height = 550 , change = tab_change ) for pic_id in pics_french_bulldogs : d = jp . Div ( style = Tabs . wrapper_style ) jp . Img ( src = f 'https://images.dog.ceo/breeds/bulldog-french/n02108915_ {pic_id} .jpg' , a = d ) t . add_tab ( f 'id {pic_id} ' , f 'Pic {pic_id} ' , d ) input_classes = \"w-1/3 m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" in1 = jp . Input ( classes = input_classes , model = [ wp , 'tab' ], a = wp ) return wp justpy ( tab_comp_test ) Table Component \u00b6 The AutoTable component takes a list of lists and formats it into a nice looking table. The first list is used as the headers for the table. In the example below, we read a CSV file into a pandas frame, convert it to a list of lists and add the column names as the first list and then use the component. Note You need pandas installed to run the example below. import justpy as jp import pandas as pd class AutoTable ( jp . Table ): td_classes = 'border px-4 py-2 text-center' tr_even_classes = 'bg-gray-100 ' tr_odd_classes = '' th_classes = 'px-4 py-2' def __init__ ( self , ** kwargs ): self . values = [] super () . __init__ ( ** kwargs ) def react ( self , data ): self . set_class ( 'table-auto' ) #First row of values is header if self . values : headers = self . values [ 0 ] thead = jp . Thead ( a = self ) tr = jp . Tr ( a = thead ) for item in headers : jp . Th ( text = item , classes = self . th_classes , a = tr ) tbody = jp . Tbody ( a = self ) for i , row in enumerate ( self . values [ 1 :]): if i % 2 == 1 : tr = jp . Tr ( classes = self . tr_even_classes , a = tbody ) else : tr = jp . Tr ( classes = self . tr_odd_classes , a = tbody ) for item in row : jp . Td ( text = item , classes = self . td_classes , a = tr ) wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) wm_df [ 'Year' ] = wm_df [ 'Year' ] . astype ( 'str' ) headers = list ( wm_df . columns ) table_data = wm_df . to_numpy () . tolist () table_data . insert ( 0 , headers ) def table_test (): wp = jp . WebPage () d = jp . Div ( classes = 'w-7/8 m-2 p-3 border rounded-lg ' , a = wp ) AutoTable ( values = table_data , a = d , classes = 'block p-4 overflow-auto' , style = 'height: 90vh' ) return wp jp . justpy ( table_test ) Quasar QInput Component with Integrated QDate and QTime \u00b6 import justpy as jp # https://quasar.dev/vue-components/date#With-QInput class QInputDateTime ( jp . QInput ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) date_slot = jp . QIcon ( name = 'event' , classes = 'cursor-pointer' ) c2 = jp . QPopupProxy ( transition_show = 'scale' , transition_hide = 'scale' , a = date_slot ) self . date = jp . QDate ( mask = 'YYYY-MM-DD HH:mm' , name = 'date' , a = c2 ) time_slot = jp . QIcon ( name = 'access_time' , classes = 'cursor-pointer' ) c2 = jp . QPopupProxy ( transition_show = 'scale' , transition_hide = 'scale' , a = time_slot ) self . time = jp . QTime ( mask = 'YYYY-MM-DD HH:mm' , format24h = True , name = 'time' , a = c2 ) self . date . parent = self self . time . parent = self self . date . value = self . value self . time . value = self . value self . prepend_slot = date_slot self . append_slot = time_slot self . date . on ( 'input' , self . date_time_change ) self . time . on ( 'input' , self . date_time_change ) self . on ( 'input' , self . input_change ) @staticmethod def date_time_change ( self , msg ): self . parent . value = self . value self . parent . date . value = self . value self . parent . time . value = self . value @staticmethod def input_change ( self , msg ): self . date . value = self . value self . time . value = self . value def input_test (): wp = jp . QuasarPage () QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '' ) QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '2020-03-01 12:44' ) QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '2021-04-01 14:44' ) QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '2022-05-01 18:44' ) return wp jp . justpy ( input_test ) Component to Link Chart and Grid \u00b6 Please see linking charts and grids for an explanation. When you use ag-Grid's filtering and sorting options, the results are not just reflected in the grid, but also in the chart. import justpy as jp import pandas as pd class LinkedChartGrid ( jp . Div ): def __init__ ( self , df , x , y , ** kwargs ): super () . __init__ ( ** kwargs ) self . df = df self . x = x self . y = y self . kind = kwargs . get ( 'kind' , 'column' ) self . stacking = kwargs . get ( 'stacking' , '' ) self . title = kwargs . get ( 'title' , '' ) self . subtitle = kwargs . get ( 'subtitle' , '' ) self . set_classes ( 'flex flex-col' ) self . chart = df . jp . plot ( x , y , a = self , classes = 'm-2 p-2 border' , kind = self . kind , stacking = self . stacking , title = self . title , subtitle = self . subtitle ) self . grid = df . jp . ag_grid ( a = self ) self . grid . parent = self for event_name in [ 'sortChanged' , 'filterChanged' , 'columnMoved' , 'rowDragEnd' ]: self . grid . on ( event_name , self . grid_change ) @staticmethod def grid_change ( self , msg ): self . parent . df = jp . read_csv_from_string ( msg . data ) c = self . parent . df . jp . plot ( self . parent . x , self . parent . y , kind = self . parent . kind , title = self . parent . title , subtitle = self . parent . subtitle , stacking = self . parent . stacking ) self . parent . chart . options = c . options alcohol_df = pd . read_csv ( 'https://raw.githubusercontent.com/fivethirtyeight/data/master/alcohol-consumption/drinks.csv' , encoding = \"ISO-8859-1\" ) bad_drivers_df = pd . read_csv ( 'https://raw.githubusercontent.com/fivethirtyeight/data/master/bad-drivers/bad-drivers.csv' , encoding = \"ISO-8859-1\" ) def grid_test (): wp = jp . WebPage () c = LinkedChartGrid ( alcohol_df , 0 , [ 1 , 2 , 3 , 4 ], kind = 'column' , a = wp , classes = 'm-4 p-2 border' , stacking = 'normal' , title = 'Alcohol Consumption per Country' , subtitle = '538 data' ) LinkedChartGrid ( bad_drivers_df , 0 , [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ], kind = 'column' , a = wp , classes = 'm-4 p-2 border-4' , title = 'Bad Drivers per US State' , subtitle = '538 data' ) return wp jp . justpy ( grid_test )","title":"Creating Your Own Components"},{"location":"tutorial/custom_components/#creating-your-own-components","text":"The idea behind component programming is simple and compelling: Build a component once, and then reuse it either in the same application or in different applications. In JustPy, components are Python classes and so are custom components. Creating a component in JustPy means in most cases declaring a new Python class. In some cases, developing complex JustPy components requires also developing a Vue.js component. For example, the HighCharts charting component required developing a Vue.js component. For JustPy to support Quasar components, a Vue.js component was also required. It turns out that all Quasar components can be supported with one Vue.js component and that simplified matters considerably. However, let's start with the basics. Most components require only writing a Python class and no knowledge of Vue.js or JavaScript is required. Some components described here have features that are covered in other parts of the tutorial. Don't feel the need to finish this section in one go. If you find you need to go to other sections and return later, please do so.","title":"Creating Your Own Components"},{"location":"tutorial/custom_components/#pill-button-component","text":"Our first component is a very simple one. It is a Button that is formatted to look like a pill . import justpy as jp class PillButton ( jp . Button ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . set_classes ( 'bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full' ) def comp_test (): wp = jp . WebPage () for i in range ( 5 ): PillButton ( text = 'Pill Button' , click = 'self.text=\"I was clicked\"' , a = wp , classes = 'm-2' ) return wp jp . justpy ( comp_test ) Our new component, PillButton, inherits from Button and therefore will have all the attributes and functionality of Button. The only change we make is to redefine __init__ , the method that is called when an instance is created. In this case the method calls the __init__ of the super class (Button in our case) and then sets the classes that format the button. Warning The line super().__init__(**kwargs) is a MUST in component's __init__ Without it, the instances of the components will not be created correctly. In most cases, only default values for keyword arguments should precede it. Let's add a custom attribute to the component that will determine the background color of the button. import justpy as jp class PillButton ( jp . Button ): def __init__ ( self , ** kwargs ): self . bg_color = 'blue' super () . __init__ ( ** kwargs ) self . set_classes ( f 'bg- {self.bg_color} -500 hover:bg- {self.bg_color} -700 text-white font-bold py-2 px-4 rounded-full' ) def comp_test (): wp = jp . WebPage () for color in [ 'blue' , 'red' , 'orange' , 'pink' ]: PillButton ( bg_color = color , text = 'Pill Button' , click = 'self.text=\"I was clicked\"' , a = wp , classes = 'm-2' ) return wp jp . justpy ( comp_test ) When we create the PillButton instances we set the attribute bg_color . Each of the four PillButton instances will have a different background color. Notice that the default for bg_color is 'blue' and it is set before the line super().__init__(**kwargs) . This allows it to be overwritten by the keyword arguments. Try moving the line setting the default after the line calling the super and see what happens. Instead of setting the defaults for your attributes in __init__ you can set a class attribute like so: class PillButton ( jp . Button ): bg_color = 'blue' def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . set_classes ( f 'bg- {self.bg_color} -500 hover:bg- {self.bg_color} -700 text-white font-bold py-2 px-4 rounded-full' ) Both methods work the same as Python uses the class attribute if it does not find an instance attribute.","title":"Pill Button Component"},{"location":"tutorial/custom_components/#alert-component","text":"This component is based on this example from the Tailwind documentation. The HTML the component is based on looks like this: html_string = \"\"\" <div class=\"bg-teal-100 border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md\" role=\"alert\"> <div class=\"flex\"> <div class=\"py-1\"> <svg class=\"fill-current h-6 w-6 text-teal-500 mr-4\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\"> <path d=\"M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z\"/></svg> </div> <div> <p class=\"font-bold\">Our privacy policy has changed</p> <p class=\"text-sm\">Make sure you know how these changes affect you.</p> </div> </div> </div> \"\"\" We will use parse_html to easily convert this to JustPy commands. Run the following program. As it does not start a web server, there is no need to load a web page. We will be interested only in the printout. import justpy as jp # Example based on https://tailwindcss.com/components/alerts/#top-accent-border html_string = \"\"\" <div class=\"bg-teal-100 border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md\" role=\"alert\"> <div class=\"flex\"> <div class=\"py-1\"> <svg class=\"fill-current h-6 w-6 text-teal-500 mr-4\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\"> <path d=\"M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z\"/></svg> </div> <div> <p class=\"font-bold\">Our privacy policy has changed</p> <p class=\"text-sm\">Make sure you know how these changes affect you.</p> </div> </div> </div> \"\"\" d = jp . parse_html ( html_string ) for c in d . commands : print ( c ) The printout is the following: root = jp . Div ( name = 'root' ) c1 = jp . Div ( classes = 'bg-teal-100 border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md' , role = 'alert' , a = root ) c2 = jp . Div ( classes = 'flex' , a = c1 ) c3 = jp . Div ( classes = 'py-1' , a = c2 ) c4 = jp . Svg ( classes = 'fill-current h-6 w-6 text-teal-500 mr-4' , xmlns = 'http://www.w3.org/2000/svg' , viewBox = '0 0 20 20' , a = c3 ) c5 = jp . Path ( d = 'M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z' , a = c4 ) c6 = jp . Div ( a = c2 ) c7 = jp . P ( classes = 'font-bold' , a = c6 , text = 'Our privacy policy has changed' ) c8 = jp . P ( classes = 'text-sm' , a = c6 , text = 'Make sure you know how these changes affect you.' ) These are the JustPy commands required to duplicate the elements defined in the HTML. We are now are ready to define our component. We will call it MyAlert . import justpy as jp class MyAlert ( jp . Div ): def __init__ ( self , ** kwargs ): self . title_text = 'This is the title' self . body_text = 'This is the body' super () . __init__ ( ** kwargs ) # Important! see below root = self c1 = jp . Div ( classes = 'bg-teal-100 border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md' , role = 'alert' , a = root ) c2 = jp . Div ( classes = 'flex' , a = c1 ) c3 = jp . Div ( classes = 'py-1' , a = c2 ) c4 = jp . Svg ( classes = 'fill-current h-6 w-6 text-teal-500 mr-4' , xmlns = 'http://www.w3.org/2000/svg' , viewBox = '0 0 20 20' , a = c3 ) c5 = jp . Path ( d = 'M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z' , a = c4 ) c6 = jp . Div ( a = c2 ) c7 = jp . P ( classes = 'font-bold text-lg' , a = c6 , text = self . title_text ) c8 = jp . P ( classes = 'text-sm' , a = c6 , text = self . body_text ) def alert_test (): wp = jp . WebPage () d = MyAlert ( a = wp , classes = 'm-2 w-1/4' , title_text = 'hello' , body_text = 'How is everybody?' ) d . title_text = 'Shalom' return wp jp . justpy ( alert_test ) Warning The line super().__init__(**kwargs) is a MUST in custom component's __init__ Without it, the instances of the components will not be created correctly. Only default values for keyword arguments should precede it. When you run the program above, notice that the title of the MyAlert instance is rendered as 'Hello' instead of 'Shalom' even though the line d.title_text = 'Shalom' is executed after it is created (this problem also exists with the PillButton component we defined above). To fix this bug we need to assign the attributes title_text and body_text to the text of the appropriate elements when the instance is rendered, not when it is created. Note As part of the rendering process, JustPy converts class instances to a Python dictionary representation that will later be sent as JSON to the web page and will be the input to the Vue.js frontend. This is done using the convert_object_to_dict method that each component class has.","title":"Alert Component"},{"location":"tutorial/custom_components/#the-react-method","text":"Every JustPy component supports the react method. It is run just just before a class instance is converted to a dictionary. It receives two arguments, the instance and the data attribute of its parent element or that of the WebPage if it has no parent. In base JustPy elements, react does nothing. It is there to be overridden in user defined components. The modified program looks like this: import justpy as jp class MyAlert ( jp . Div ): def __init__ ( self , ** kwargs ): self . title_text = 'This is the title' self . body_text = 'This is the body' super () . __init__ ( ** kwargs ) root = self c1 = jp . Div ( classes = 'bg-teal-100 border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md' , role = 'alert' , a = root ) c2 = jp . Div ( classes = 'flex' , a = c1 ) c3 = jp . Div ( classes = 'py-1' , a = c2 ) c4 = jp . Svg ( classes = 'fill-current h-6 w-6 text-teal-500 mr-4' , xmlns = 'http://www.w3.org/2000/svg' , viewBox = '0 0 20 20' , a = c3 ) c5 = jp . Path ( d = 'M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z' , a = c4 ) c6 = jp . Div ( a = c2 ) c7 = jp . P ( classes = 'font-bold text-lg' , a = c6 , text = self . title_text ) c8 = jp . P ( classes = 'text-sm' , a = c6 , text = self . body_text ) self . title_p = c7 self . body_p = c8 def react ( self , data ): self . title_p . text = self . title_text self . body_p . text = self . body_text self . text = '' greetings = [ 'Bonjour' , 'Hola' , 'Zdravstvuyte' , 'N\u01d0n h\u01ceo' , 'Salve' , 'Konnichiwa' , 'Guten Tag' , 'Ol\u00e1' , 'Anyoung haseyo' , 'Asalaam alaikum' , 'Goddag' , 'Shikamoo' , 'Goedendag' , 'Yassas' , 'Dzie\u0144 dobry' , 'Selamat siang' , 'Namaste' , 'Merhaba' , 'Shalom' , ' God dag' ] def translate ( self , msg ): self . title_text = 'Hello' def alert_test (): wp = jp . WebPage () for greeting in greetings : d = MyAlert ( a = wp , classes = 'm-2 w-1/4' , title_text = 'hello' , body_text = 'How is everybody?' ) d . on ( 'click' , translate ) d . title_text = greeting return wp jp . justpy ( alert_test ) At the end of __init__ we added the two lines: self . title_p = c7 self . body_p = c8 These two attributes now hold the paragraphs where the title and body will be placed. In the react method, the text attributes of the paragraphs are set. Just as a precaution, the text attribute of the parent element is set to the empty string (if it is not empty, the text will be rendered and the result will not be what we want). In the request handler, alert_test , we use the new component to render alerts with greetings in different languages. We also added an event handler for the mouse click that changes the title to \"Hello\". We now have a component, MyAlert that we can reuse as we please in any project (and of course share with our fellow programmers).","title":"The react Method"},{"location":"tutorial/custom_components/#date-card-component","text":"Here is an example of a simple date card component based on this design. import justpy as jp class CalendarDate ( jp . Div ): def __init__ ( self , ** kwargs ): self . month = 'Jan' self . year = '2010' self . weekday = 'Sun' self . day = '1' self . color = 'red' super () . __init__ ( ** kwargs ) self . inner_html = f \"\"\" <div class=\"w-24 rounded-t overflow-hidden bg-white text-center m-2 cursor-default\"> <div class=\"bg- {self.color} -500 text-white py-1\"> {self.month} </div> <div class=\"pt-1 border-l border-r\"> <span class=\"text-4xl font-bold\"> {self.day} </span> </div> <div class=\"pb-2 px-2 border-l border-r border-b rounded-b flex justify-between\"> <span class=\"text-xs font-bold\"> {self.weekday} </span> <span class=\"text-xs font-bold\"> {self.year} </span> </div> </div> \"\"\" def comp_test (): wp = jp . WebPage () year = 2019 month = 'Feb' d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for day in range ( 1 , 11 ): CalendarDate ( day = day , month = month , year = year , color = 'teal' , a = d , animation = 'bounceIn' ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for day in range ( 5 , 26 ): CalendarDate ( day = day , month = 'Jul' , year = '2005' , color = 'yellow' , a = d ) return wp jp . justpy ( comp_test ) In this custom component we are using the template like behavior of Python f-strings to create a date card with some features that can be changed. This simple component inherits from the component Div . It changes only the __init__ method and inherits all the others. Notice the super().__init__(**kwargs) line in __init__ . It is required to take care of all the plumbing that goes along with a JustPy component. This line executes the __init__ of Div . We define the defaults for the component specific attributes before this line so as not to overwrite keyword arguments that the user has provided and are assigned to attributes in the superclass __init__ . This component works well enough but has a flaw. The inner_html attribute is set in __init__ when the instance is created. If for example, the instance's day attribute is changed after __init__ has run, it would not be reflected in the inner html and the component will not be rendered correctly. To solve this problem, we need to move setting inner_html from the time the instance was created to the time it is rendered. Every JustPy component has a method called react that is called each time before the object is converted to a dict. The example above can therefore be written as follows: import justpy as jp class CalendarDate ( jp . Div ): def __init__ ( self , ** kwargs ): self . month = 'Jan' self . year = '2010' self . weekday = 'Sun' self . day = '1' self . color = 'red' super () . __init__ ( ** kwargs ) def react ( self , data ): self . inner_html = f \"\"\" <div class=\"w-24 rounded-t overflow-hidden bg-white text-center m-2 cursor-default\"> <div class=\"bg- {self.color} -500 text-white py-1\"> {self.month} </div> <div class=\"pt-1 border-l border-r\"> <span class=\"text-4xl font-bold\"> {self.day} </span> </div> <div class=\"pb-2 px-2 border-l border-r border-b rounded-b flex justify-between\"> <span class=\"text-xs font-bold\"> {self.weekday} </span> <span class=\"text-xs font-bold\"> {self.year} </span> </div> </div> \"\"\" def comp_test (): wp = jp . WebPage () year = 2019 month = 'Feb' d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for day in range ( 1 , 11 ): CalendarDate ( day = day , month = month , year = year , color = 'teal' , a = d , animation = 'bounceIn' ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for day in range ( 5 , 26 ): c = CalendarDate ( day = day , month = 'Jul' , year = '2005' , color = 'yellow' , a = d ) c . day += 1 # Notice how the date starts from 6 and not from 5. return wp jp . justpy ( comp_test ) The react method accepts an additional argument to self. The argument data is the data attribute of the element's direct parent. If the element has no parent, it is the data attribute of the page. Using react we can have child elements change their behavior when rendered based on the data attribute of their parent or the page they are on. For example, let's make the color of the component dependent on the data attribute of their parent container. import justpy as jp class CalendarDate ( jp . Div ): def __init__ ( self , ** kwargs ): self . month = 'Jan' self . year = '2010' self . weekday = 'Sun' self . day = '1' self . color = 'red' super () . __init__ ( ** kwargs ) def react ( self , data ): self . inner_html = f \"\"\" <div class=\"w-24 rounded-t overflow-hidden bg-white text-center m-2 cursor-default\"> <div class=\"bg- {data['color']} -500 text-white py-1\"> {self.month} </div> <div class=\"pt-1 border-l border-r\"> <span class=\"text-4xl font-bold\"> {self.day} </span> </div> <div class=\"pb-2 px-2 border-l border-r border-b rounded-b flex justify-between\"> <span class=\"text-xs font-bold\"> {self.weekday} </span> <span class=\"text-xs font-bold\"> {self.year} </span> </div> </div> \"\"\" def change_color ( self , msg ): self . d . data [ \"color\" ] = self . value def comp_test (): wp = jp . WebPage () year = 2019 month = 'Feb' d = jp . Div ( classes = 'flex flex-wrap' , a = wp , data = { 'color' : 'purple' }) for day in range ( 1 , 11 ): CalendarDate ( day = day , month = month , year = year , color = 'teal' , a = d ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp , data = { 'color' : 'red' }) for day in range ( 5 , 26 ): c = CalendarDate ( day = day , month = 'Jul' , year = '2005' , color = 'yellow' , a = d ) c . day += 1 # Notice how the date starts from 6 and not from 5. colors = [ 'red' , 'green' , 'blue' , 'pink' , 'yellow' , 'teal' , 'purple' ] s = jp . Select ( classes = 'w-32 text-xl m-2 p-2 bg-white border rounded-full' , a = wp , value = 'red' , change = change_color ) s . d = d for color in colors : s . add ( jp . Option ( value = color , text = color , classes = f 'bg- {color} -600' )) return wp jp . justpy ( comp_test ) This example is a little more complex as we have added a Select component at the bottom of the page. Try changing the selected color. The color of the CalendarDate instances in the second group changes because in the event handler, change_color we change the data attribute of the parent Div, d . The function change_color sets the value of the 'color' key in the data dictionary of the Div that holds the CalendarDate instances to the new value of the Select element. In this example, we changed the react function so it uses this value instead of self.color (which was used in the previous example) to set the color to display. A few more words about Select: A Select component includes Option components. In this example we add them to the Select using a predefined list of colors. When a specific option is selected, its value attribute becomes the value attribute of the Select. The change in value is acted upon by binding a method to the change event of the Select instance.","title":"Date Card Component"},{"location":"tutorial/custom_components/#hello-component","text":"JustPy comes with a simple Hello component, which we will now examine. First run the following short program. import justpy as jp def hello_test (): wp = jp . WebPage () h = jp . Hello () for i in range ( 5 ): wp . add ( h ) return wp jp . justpy ( hello_test ) The program puts five Hello elements on the page. Click any one of them. All five will show the number of times any element was clicked because each time through the loop, we add the same element to the page. There may be 5 rendered elements on the page, but for JustPy, these are the same element. If we would like there to be independent components on the page, we would write the program in the following way: import justpy as jp def hello_test (): wp = jp . WebPage () for i in range ( 5 ): wp . add ( jp . Hello ()) # or jp.Hello(a=wp) return wp jp . justpy ( hello_test ) In this program, each time thorough the loop we create a new Hello element and add it to the page. When any element is clicked, no other element on the page is affected. Let's look more closely at the Hello component. This is the way it is defined: class Hello ( Div ): def __init__ ( self , ** kwargs ): self . counter = 1 super () . __init__ ( ** kwargs ) self . classes = 'm-1 p-1 text-2xl text-center text-white bg-blue-500 hover:bg-blue-800 cursor-pointer' self . text = 'Hello! (click me)' def click ( self , msg ): self . text = f 'Hello! I was clicked {self.counter} times' self . counter += 1 self . on ( 'click' , click ) Again, JustPy components are Python classes. In our case, Hello inherits from Div and only changes Div 's __init__ . In __init__ we first initialize a counter for the instance. This is a new attribute that is not initialized by Div . Then we call the super class __init__ , in our case the __init__ of Div. This call provides Hello with the initializations required to work correctly inside the JustPy framework. Since we are calling the super class __init__ after having provided a default value to the counter attribute, we can overwrite it with a keyword argument. Try running the following: import justpy as jp def hello_test (): wp = jp . WebPage () for i in range ( 5 ): jp . Hello ( a = wp , counter = 100 ) return wp jp . justpy ( hello_test ) Since counter is initialized to 100, the components will start counting from 100. The call to the super class __init__ takes care of assigning the keyword arguments. If we had put the initialization of counter after the call to the super class __init__ , the keyword argument would have had no effect. Next, in the definition of Hello , we set the classes of the component to give it some basic design and we set the text. Then we define the click event handler and assign it to the instance. That's it. Let's say we are not pleased with the Hello message and its colors and want to define a better Hello component. This is how we would do it: import justpy as jp class MyHello ( jp . Hello ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . classes = 'm-1 p-1 text-6xl text-center text-red-500 bg-yellow-500 hover:bg-yellow-800 cursor-pointer' self . text = 'Much Better Hello! (click me)' def hello_test (): wp = jp . WebPage () for i in range ( 5 ): MyHello ( a = wp , counter = 100 ) return wp jp . justpy ( hello_test ) We define a new component called MyHello which inherits from Hello . By running the super class __init__ in the __init__ of MyHello , we get all the functionality of Hello . We then just modify the classes and text.","title":"Hello Component"},{"location":"tutorial/custom_components/#calculator-component","text":"","title":"Calculator Component"},{"location":"tutorial/custom_components/#base-component","text":"We will build a calculator component in stages. First, we will create a component that does not handle events or the model attribute. Please run the following example. from justpy import Div , Input , Button , WebPage , justpy class Calculator ( Div ): btn_classes = 'w-1/4 text-xl font-bold p-2 m-1 border bg-gray-200 hover:bg-gray-700 shadow' layout_text = [[ '7' , '8' , '9' , '*' ], [ '4' , '5' , '6' , '-' ], [ '1' , '2' , '3' , '+' ], [ 'C' , '0' , '.' , '=' ]] def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . value = 0 self . tape = Input ( classes = 'block p-2 m-2 border text-right text-sm bg-gray-200' , a = self , readonly = True , value = ' ' , style = 'width: 90%' ) self . result = Input ( classes = 'block p-2 m-2 border text-2xl text-right' , a = self , readonly = True , value = '0' , style = 'width: 90%' ) for line in self . __class__ . layout_text : d = Div ( classes = 'flex w-auto m-2' , a = self ) for b in line : b1 = Button ( text = b , a = d , classes = self . __class__ . btn_classes , click = self . calculator_click ) b1 . calc = self @staticmethod def calculator_click ( self , msg ): calc = self . calc if self . text == 'C' : calc . result . value = '0' calc . tape . value = ' ' calc . value = 0 elif self . text == '=' : calc . result . value = str ( eval ( calc . tape . value )) calc . value = eval ( calc . tape . value ) calc . tape . value = calc . result . value else : if calc . tape . value [ - 1 ] in '*+-/' or self . text in '*+-/' : calc . tape . value += ' ' + self . text else : calc . tape . value += self . text try : calc . result . value = str ( eval ( calc . tape . value )) calc . value = eval ( calc . tape . value ) except : pass def calculator_test (): wp = WebPage () for i in range ( 10 ): c = Calculator ( a = wp , classes = 'm-1 border inline-block' , style = 'width: 250px' ) return wp justpy ( calculator_test ) First let's look at the function calculator_test . This function creates a WebPage and adds ten instances of the Calculator component to it. Try changing the number of calculators on the page by changing the argument to range. Once a JustPy component has been defined, it is simple to reuse it. The Calculator component can be used now in multiple projects. JustPy components are Python classes. The Calculator component is therefore a Python class. The Calculator class inherits from Div so Calculator is endowed from the start will all the features and capabilities of the Div component. These features are used in __init__ , in order to add the other components needed to implement the calculator. The class __init__ first calls the class __init__ of the super class (in this case Div). If a class inherits from another JustPy component, you must run the __init__ of the super class. It then sets the value attribute to 0 and adds two Input components, one for the tape and one for the result. The two Inputs are assigned to instance attributes for future reference and added to self (which is a Div and therefore other components can be added to it). The Inputs are also designated readonly so that the user cannot type in them. After the two Input elements are added to the instance, two nested loops are used to add the calculator buttons based on the layout list which is a list of lists. Each child list represents a line of buttons. Each button is assigned the same click event handler, self.calculator_click which is a static method of the Calculator class (we could have defined the event handler inside the __init__ function instead). We also assign to the button calc attribute a reference to the Calculator instance of which the button is part of. This is used in the click event handler to set the value of the Calculator instance. In this example, for the sake of brevity, we implemented a very simple state machine for the calculator that is not perfect (for example, it does not handle 0 in front of a number), but for our purposes, it will do. The state machine is inside the calculator_click event handler. All buttons on the calculator use the same event handler but it differentiates between the buttons based on self.text which is unique for each button.","title":"Base component"},{"location":"tutorial/custom_components/#handling-the-change-event","text":"As it is currently defined, Calculator does not support any useful events. We would like to add a meaningful change event to it. This event will fire when the value of the Calculator instance changes. We do this by modifying the click event handler of the buttons. The value of the Calculator instance does not change unless some button is clicked. We therefore check if the specific button click changed the value and if that is the case, we run the change event handler of the Calculator instance. This is how the result looks like: from justpy import Div , Input , Button , WebPage , justpy class Calculator ( Div ): btn_classes = 'w-1/4 text-xl font-bold p-2 m-1 border bg-gray-200 hover:bg-gray-700 shadow' layout_text = [[ '7' , '8' , '9' , '*' ], [ '4' , '5' , '6' , '-' ], [ '1' , '2' , '3' , '+' ], [ 'C' , '0' , '.' , '=' ]] def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . value = 0 self . tape = Input ( classes = 'block p-2 m-2 border text-right text-sm bg-gray-200' , a = self , readonly = True , value = ' ' , style = 'width: 90%' ) self . result = Input ( classes = 'block p-2 m-2 border text-2xl text-right' , a = self , readonly = True , value = '0' , style = 'width: 90%' ) for line in type ( self ) . layout_text : d = Div ( classes = 'flex w-auto m-2' , a = self ) for b in line : b1 = Button ( text = b , a = d , classes = type ( self ) . btn_classes , click = self . calculator_click ) b1 . calc = self @staticmethod async def calculator_click ( self , msg ): calc = self . calc try : tape_value = eval ( calc . tape . value ) except : tape_value = 0 changed = False if self . text == 'C' : calc . result . value = '0' calc . tape . value = ' ' if calc . value != 0 : calc . value = 0 changed = True elif self . text == '=' : if calc . value != tape_value : calc . value = tape_value changed = True calc . result . value = str ( tape_value ) calc . tape . value = str ( tape_value ) else : if calc . tape . value [ - 1 ] in '*+-/' or self . text in '*+-/' : calc . tape . value += ' ' + self . text else : calc . tape . value += self . text try : tape_value = eval ( calc . tape . value ) calc . result . value = str ( tape_value ) if calc . value != tape_value : calc . value = tape_value changed = True except : pass if changed : if calc . has_event_function ( 'change' ): calc_msg = msg calc_msg . event_type = 'change' calc_msg . id = calc . id calc_msg . button_text = self . text calc_msg . value = calc . value calc_msg . class_name = calc . __class__ . __name__ return await calc . run_event_function ( 'change' , calc_msg ) def calc_change ( self , msg ): print ( 'In change' ) print ( msg ) self . d . text = self . value def calculator_test (): wp = WebPage () c = Calculator ( a = wp , classes = 'm-1 border inline-block' , style = 'width: 250px' , change = calc_change ) d = Div ( classes = 'border m-2 p-1 w-64 text-xl' , text = '0' , a = wp ) c . d = d return wp justpy ( calculator_test ) Run the program above. You will see that the value of the calculator is reflected in the Div below it since that is what we defined the change event handler to do. In the click event handler we use a flag called changed that is set to True by the state machine logic if an operation that changes the value of the calculator occurs. At the end of the event handler, we check if changed is True . If it is, we check whether the instance has a change event handler. We do this by using the method has_event_function which is a basic method of all JustPy components. If there is a change event handler, we run the event handler using the run_event_function method which is also a basic method of all JustPy components. This method takes two arguments in addition to self . The first is the event type. The second, is the dictionary we want passed as the second positional argument to the event handler. This is what we usually designate as msg in our event handlers. Before calling run_event_function we modify some values in msg to make it more informative. In general, you would create the appropriate msg for how you believe the component will be used. In our case we have added the button_text key which stores the text of the last button that was clicked and that generated the change event. Note Please note that run_event_function is an async method and therefore since calculator_click awaits it, it needs to be a coroutine also and is defined using async.","title":"Handling the change event"},{"location":"tutorial/custom_components/#adding-a-model-attribute","text":"To make Calculator complete, we will also add handling of the model attribute to it. This is quite simple in our case. First, we need to remember that Calculator inherits from Div and is a derived (child) class of Div. The Div model_update method sets the Div instance's text attribute to the model. Therefore, we need to override it to do nothing so we don't see the value as text at the top of the calculator. Try removing the model_update method from the example below and see what happens. from justpy import Div , Input , Button , WebPage , justpy class Calculator ( Div ): btn_classes = 'w-1/4 text-xl font-bold p-2 m-1 border bg-gray-200 hover:bg-gray-700 shadow' layout_text = [[ '7' , '8' , '9' , '*' ], [ '4' , '5' , '6' , '-' ], [ '1' , '2' , '3' , '+' ], [ 'C' , '0' , '.' , '=' ]] def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . value = 0 self . tape = Input ( classes = 'block p-2 m-2 border text-right text-sm bg-gray-200' , a = self , readonly = True , value = ' ' , style = 'width: 90%' ) self . result = Input ( classes = 'block p-2 m-2 border text-2xl text-right' , a = self , readonly = True , value = '0' , style = 'width: 90%' ) for line in type ( self ) . layout_text : d = Div ( classes = 'flex w-auto m-2' , a = self ) for b in line : b1 = Button ( text = b , a = d , classes = type ( self ) . btn_classes , click = self . calculator_click ) b1 . calc = self @staticmethod async def calculator_click ( self , msg ): calc = self . calc try : tape_value = eval ( calc . tape . value ) except : tape_value = 0 changed = False if self . text == 'C' : calc . result . value = '0' calc . tape . value = ' ' if calc . value != 0 : calc . value = 0 changed = True elif self . text == '=' : if calc . value != tape_value : calc . value = tape_value changed = True calc . result . value = str ( tape_value ) calc . tape . value = str ( tape_value ) else : if calc . tape . value [ - 1 ] in '*+-/' or self . text in '*+-/' : calc . tape . value += ' ' + self . text else : calc . tape . value += self . text try : tape_value = eval ( calc . tape . value ) calc . result . value = str ( tape_value ) if calc . value != tape_value : calc . value = tape_value changed = True except : pass if changed : calc . set_model ( calc . value ) #******************** updates model if calc . has_event_function ( 'change' ): calc_msg = msg calc_msg . event_type = 'change' calc_msg . id = calc . id calc_msg . button_text = self . text calc_msg . value = calc . value calc_msg . class_name = calc . __class__ . __name__ return await calc . run_event_function ( 'change' , calc_msg ) def model_update ( self ): pass def calculator_test (): wp = WebPage ( data = { 'value' : 0 }) Calculator ( a = wp , classes = 'm-1 border inline-block' , style = 'width: 250px' , model = [ wp , 'value' ]) for i in range ( 5 ): Div ( classes = 'border m-2 p-1 w-64 text-xl' , text = '0' , a = wp , model = [ wp , 'value' ]) return wp justpy ( calculator_test ) Notice that we have added a call to the method set_model in the click event handler. This method checks if the component has a model attribute and if so, sets it to the method's argument. The set_model method is defined as follows: def set_model ( self , value ): if hasattr ( self , 'model' ): self . model [ 0 ] . data [ self . model [ 1 ]] = value The model attribute, as we defined it above is one directional. The component only sets model value but does not change any of its other attribute values based on changes in model .","title":"Adding a model attribute"},{"location":"tutorial/custom_components/#tab-group-component","text":"This component allows inserting content in tabs and displaying it based on the tab selected. If the animation attribute is set to True , the transition between tabs is animated. The type of animation and its speed can also be set. A tab is added by calling the add_tab method. This method accepts three arguments (in addition to self). The first is the id of the tab. When the tab is selected, its value will become the id of the tab selected. Converesely, when the value attribute is set, if a tab with a corresponding id exists, it will be shown. The second argument is the label to display for the tab's selection. The third argument is the content of the tab. Typically it would be a container element such as a Div instance that contains other elements. In this component, the method convert_object_to_dict , is overridden. This is the method that executes each time an instance of the component is rendered. It is simpler in this case than using the react method that is called by the super class convert_object_to_dict . It also allows the flexibility of overriding the react method in components that inherit from the Tabs component. Below we also define another component, TabPills, that inherits from Tabs and just changes the appearance of the tabs label line. It does so by just changing a few class variables. Tip When creating custom components, it makes sense to make the design a function of class variables. This simplifies creating new components with a different design. In the example below we use three tab components to display charts and pictures. from justpy import Div , WebPage , Ul , Li , HighCharts , A , justpy import justpy as jp class Tabs ( Div ): tab_label_classes = 'overflow-hidden cursor-pointer bg-white inline-block py-2 px-4 text-blue-500 hover:text-blue-800 font-semibold' tab_label_classes_selected = 'overflow-hidden cursor-pointer bg-white inline-block border-l border-t border-r rounded-t py-2 px-4 text-blue-700 font-semibold' item_classes = 'flex-shrink mr-1' item_classes_selected = 'flex-shrink -mb-px mr-1' wrapper_style = 'display: flex; position: absolute; width: 100%; height: 100%; align-items: center; justify-content: center; background-color: #fff;' def __init__ ( self , ** kwargs ): self . tabs = [] # list of {'id': id, 'label': label, 'content': content} self . value = None # The value of the tabs component is the id of the selected tab self . content_height = 500 self . last_rendered_value = None self . animation = False self . animation_next = 'slideInRight' self . animation_prev = 'slideOutLeft' self . animation_speed = 'faster' # '' | 'slow' | 'slower' | 'fast' | 'faster' super () . __init__ ( ** kwargs ) self . tab_list = Ul ( classes = \"flex flex-wrap border-b\" , a = self ) self . content_div = Div ( a = self ) self . delete_list = [] def __setattr__ ( self , key , value ): if key == 'value' : try : self . previous_value = self . value except : pass self . __dict__ [ key ] = value def add_tab ( self , id , label , content ): self . tabs . append ({ 'id' : id , 'label' : label , 'content' : content }) if not self . value : self . value = id def get_tab_by_id ( self , id ): for tab in self . tabs : if tab [ 'id' ] == id : return tab return None def set_content_div ( self , tab ): self . content_div . add ( tab [ 'content' ]) self . content_div . set_classes ( 'relative overflow-hidden border' ) self . content_div . style = f 'height: {self.content_height} px' def set_content_animate ( self , tab ): self . wrapper_div_classes = self . animation_speed # Component in this will be centered if self . previous_value : self . wrapper_div = Div ( classes = self . wrapper_div_classes , animation = self . animation_next , temp = True , style = f ' {self.wrapper_style} z-index: 50;' , a = self . content_div ) self . wrapper_div . add ( tab [ 'content' ]) self . wrapper_div = Div ( classes = self . wrapper_div_classes , animation = self . animation_prev , temp = True , style = f ' {self.wrapper_style} z-index: 0;' , a = self . content_div ) self . wrapper_div . add ( self . get_tab_by_id ( self . previous_value )[ 'content' ]) else : self . wrapper_div = Div ( classes = self . wrapper_div_classes , temp = True , a = self . content_div , style = self . wrapper_style ) self . wrapper_div . add ( tab [ 'content' ]) self . content_div . set_classes ( 'relative overflow-hidden border' ) self . content_div . style = f 'height: {self.content_height} px' def model_update ( self ): val = self . model [ 0 ] . data [ self . model [ 1 ]] if self . get_tab_by_id ( val ): self . value = val def delete ( self ): for c in self . delete_list : c . delete_flag = True c . delete () c . needs_deletion = False if self . delete_flag : for tab in self . tabs : tab [ 'content' ] . delete () tab [ 'content' ] = None super () . delete () @staticmethod async def tab_click ( self , msg ): if self . tabs . value != self . tab_id : previous_tab = self . tabs . value self . tabs . value = self . tab_id if hasattr ( self . tabs , 'model' ): self . tabs . model [ 0 ] . data [ self . tabs . model [ 1 ]] = self . tabs . value # Run change if it exists if self . tabs . has_event_function ( 'change' ): msg . previous_tab = previous_tab msg . new_tab = self . tabs . value msg . id = self . tabs . id msg . value = self . tabs . value msg . class_name = self . tabs . __class__ . __name__ return await self . tabs . run_event_function ( 'change' , msg ) else : return True # No need to update page def convert_object_to_dict ( self ): if hasattr ( self , 'model' ): self . model_update () self . set_classes ( 'flex flex-col' ) self . tab_list . delete_components () self . content_div . components = [] for tab in self . tabs : if tab [ 'id' ] != self . value : tab_li = Li ( a = self . tab_list , classes = self . item_classes ) li_item = A ( text = tab [ 'label' ], classes = self . tab_label_classes , a = tab_li , delete_flag = False ) self . delete_list . append ( li_item ) else : tab_li = Li ( a = self . tab_list , classes = self . item_classes_selected ) li_item = A ( text = tab [ 'label' ], classes = self . tab_label_classes_selected , a = tab_li , delete_flag = False ) self . delete_list . append ( li_item ) if self . animation and ( self . value != self . last_rendered_value ): self . set_content_animate ( tab ) else : self . set_content_div ( tab ) li_item . tab_id = tab [ 'id' ] li_item . tabs = self li_item . on ( 'click' , self . tab_click ) self . last_rendered_value = self . value d = super () . convert_object_to_dict () return d class TabsPills ( Tabs ): tab_label_classes = 'cursor-pointer inline-block border border-white rounded hover:border-gray-200 text-blue-500 hover:bg-gray-200 py-1 px-3' tab_label_classes_selected = 'cursor-pointer inline-block border border-blue-500 rounded py-1 px-3 bg-blue-500 text-white' item_classes = 'flex-shrink mr-3' item_classes_selected = 'flex-shrink -mb-px mr-3' my_chart_def = \"\"\" { chart: { type: 'bar' }, title: { text: 'Fruit Consumption' }, xAxis: { categories: ['Apples', 'Bananas', 'Oranges'] }, yAxis: { title: { text: 'Fruit eaten' } }, series: [{ name: 'Jane', data: [1, 0, 4], animation: false }, { name: 'John', data: [5, 7, 3], animation: false }] } \"\"\" # https://dog.ceo/api/breed/papillon/images/random pics_french_bulldogs = [ '5458' , '7806' , '5667' , '4860' ] pics_papillons = [ '5037' , '2556' , '7606' , '8241' ] def tab_change ( self , msg ): print ( 'in change' , msg ) def tab_comp_test (): wp = jp . WebPage ( data = { 'tab' : 'id2556' }) t = Tabs ( a = wp , classes = 'w-3/4 m-4' , style = '' , animation = True , content_height = 550 ) for chart_type in [ 'bar' , 'column' , 'line' , 'spline' ]: d = jp . Div ( style = Tabs . wrapper_style , delete_flag = True ) my_chart = jp . HighCharts ( a = d , classes = 'm-2 p-2 border' , style = 'width: 1000px;' , options = my_chart_def , use_cache = False ) my_chart . options . chart . type = chart_type my_chart . options . title . text = f 'Chart of Type {chart_type.capitalize()}' my_chart . options . subtitle . text = f 'Subtitle {chart_type.capitalize()}' t . add_tab ( f 'id {chart_type} ' , f ' {chart_type} ' , d ) d_flex = Div ( classes = 'flex' , a = wp ) # Container for the two dog pictures tabs t = Tabs ( a = d_flex , classes = ' w-1/2 m-4' , animation = True , content_height = 550 , model = [ wp , 'tab' ], change = tab_change ) for pic_id in pics_papillons : d = jp . Div ( style = Tabs . wrapper_style ) jp . Img ( src = f 'https://images.dog.ceo/breeds/papillon/n02086910_ {pic_id} .jpg' , a = d ) t . add_tab ( f 'id {pic_id} ' , f 'Pic {pic_id} ' , d ) t = TabsPills ( a = d_flex , classes = 'w-1/2 m-4' , animation = True , content_height = 550 , change = tab_change ) for pic_id in pics_french_bulldogs : d = jp . Div ( style = Tabs . wrapper_style ) jp . Img ( src = f 'https://images.dog.ceo/breeds/bulldog-french/n02108915_ {pic_id} .jpg' , a = d ) t . add_tab ( f 'id {pic_id} ' , f 'Pic {pic_id} ' , d ) input_classes = \"w-1/3 m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" in1 = jp . Input ( classes = input_classes , model = [ wp , 'tab' ], a = wp ) return wp justpy ( tab_comp_test )","title":"Tab Group Component"},{"location":"tutorial/custom_components/#table-component","text":"The AutoTable component takes a list of lists and formats it into a nice looking table. The first list is used as the headers for the table. In the example below, we read a CSV file into a pandas frame, convert it to a list of lists and add the column names as the first list and then use the component. Note You need pandas installed to run the example below. import justpy as jp import pandas as pd class AutoTable ( jp . Table ): td_classes = 'border px-4 py-2 text-center' tr_even_classes = 'bg-gray-100 ' tr_odd_classes = '' th_classes = 'px-4 py-2' def __init__ ( self , ** kwargs ): self . values = [] super () . __init__ ( ** kwargs ) def react ( self , data ): self . set_class ( 'table-auto' ) #First row of values is header if self . values : headers = self . values [ 0 ] thead = jp . Thead ( a = self ) tr = jp . Tr ( a = thead ) for item in headers : jp . Th ( text = item , classes = self . th_classes , a = tr ) tbody = jp . Tbody ( a = self ) for i , row in enumerate ( self . values [ 1 :]): if i % 2 == 1 : tr = jp . Tr ( classes = self . tr_even_classes , a = tbody ) else : tr = jp . Tr ( classes = self . tr_odd_classes , a = tbody ) for item in row : jp . Td ( text = item , classes = self . td_classes , a = tr ) wm_df = pd . read_csv ( 'https://elimintz.github.io/women_majors.csv' ) . round ( 2 ) wm_df [ 'Year' ] = wm_df [ 'Year' ] . astype ( 'str' ) headers = list ( wm_df . columns ) table_data = wm_df . to_numpy () . tolist () table_data . insert ( 0 , headers ) def table_test (): wp = jp . WebPage () d = jp . Div ( classes = 'w-7/8 m-2 p-3 border rounded-lg ' , a = wp ) AutoTable ( values = table_data , a = d , classes = 'block p-4 overflow-auto' , style = 'height: 90vh' ) return wp jp . justpy ( table_test )","title":"Table Component"},{"location":"tutorial/custom_components/#quasar-qinput-component-with-integrated-qdate-and-qtime","text":"import justpy as jp # https://quasar.dev/vue-components/date#With-QInput class QInputDateTime ( jp . QInput ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) date_slot = jp . QIcon ( name = 'event' , classes = 'cursor-pointer' ) c2 = jp . QPopupProxy ( transition_show = 'scale' , transition_hide = 'scale' , a = date_slot ) self . date = jp . QDate ( mask = 'YYYY-MM-DD HH:mm' , name = 'date' , a = c2 ) time_slot = jp . QIcon ( name = 'access_time' , classes = 'cursor-pointer' ) c2 = jp . QPopupProxy ( transition_show = 'scale' , transition_hide = 'scale' , a = time_slot ) self . time = jp . QTime ( mask = 'YYYY-MM-DD HH:mm' , format24h = True , name = 'time' , a = c2 ) self . date . parent = self self . time . parent = self self . date . value = self . value self . time . value = self . value self . prepend_slot = date_slot self . append_slot = time_slot self . date . on ( 'input' , self . date_time_change ) self . time . on ( 'input' , self . date_time_change ) self . on ( 'input' , self . input_change ) @staticmethod def date_time_change ( self , msg ): self . parent . value = self . value self . parent . date . value = self . value self . parent . time . value = self . value @staticmethod def input_change ( self , msg ): self . date . value = self . value self . time . value = self . value def input_test (): wp = jp . QuasarPage () QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '' ) QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '2020-03-01 12:44' ) QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '2021-04-01 14:44' ) QInputDateTime ( filled = True , style = 'width: 600px' , a = wp , classes = \"q-pa-md\" , value = '2022-05-01 18:44' ) return wp jp . justpy ( input_test )","title":"Quasar QInput Component with Integrated QDate and QTime"},{"location":"tutorial/custom_components/#component-to-link-chart-and-grid","text":"Please see linking charts and grids for an explanation. When you use ag-Grid's filtering and sorting options, the results are not just reflected in the grid, but also in the chart. import justpy as jp import pandas as pd class LinkedChartGrid ( jp . Div ): def __init__ ( self , df , x , y , ** kwargs ): super () . __init__ ( ** kwargs ) self . df = df self . x = x self . y = y self . kind = kwargs . get ( 'kind' , 'column' ) self . stacking = kwargs . get ( 'stacking' , '' ) self . title = kwargs . get ( 'title' , '' ) self . subtitle = kwargs . get ( 'subtitle' , '' ) self . set_classes ( 'flex flex-col' ) self . chart = df . jp . plot ( x , y , a = self , classes = 'm-2 p-2 border' , kind = self . kind , stacking = self . stacking , title = self . title , subtitle = self . subtitle ) self . grid = df . jp . ag_grid ( a = self ) self . grid . parent = self for event_name in [ 'sortChanged' , 'filterChanged' , 'columnMoved' , 'rowDragEnd' ]: self . grid . on ( event_name , self . grid_change ) @staticmethod def grid_change ( self , msg ): self . parent . df = jp . read_csv_from_string ( msg . data ) c = self . parent . df . jp . plot ( self . parent . x , self . parent . y , kind = self . parent . kind , title = self . parent . title , subtitle = self . parent . subtitle , stacking = self . parent . stacking ) self . parent . chart . options = c . options alcohol_df = pd . read_csv ( 'https://raw.githubusercontent.com/fivethirtyeight/data/master/alcohol-consumption/drinks.csv' , encoding = \"ISO-8859-1\" ) bad_drivers_df = pd . read_csv ( 'https://raw.githubusercontent.com/fivethirtyeight/data/master/bad-drivers/bad-drivers.csv' , encoding = \"ISO-8859-1\" ) def grid_test (): wp = jp . WebPage () c = LinkedChartGrid ( alcohol_df , 0 , [ 1 , 2 , 3 , 4 ], kind = 'column' , a = wp , classes = 'm-4 p-2 border' , stacking = 'normal' , title = 'Alcohol Consumption per Country' , subtitle = '538 data' ) LinkedChartGrid ( bad_drivers_df , 0 , [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ], kind = 'column' , a = wp , classes = 'm-4 p-2 border-4' , title = 'Bad Drivers per US State' , subtitle = '538 data' ) return wp jp . justpy ( grid_test )","title":"Component to Link Chart and Grid"},{"location":"tutorial/deployment/","text":"Deployment \u00b6 Simple Deployment \u00b6 Launch a Linux Virtual Machine on your preferred cloud service. If you are not a superuser, become one. Update your machine and install pip3: apt update apt install python3-pip Follow the getting started instructions. This will prepare your VM to run your JustPY program. Then, set the HOST parameter in the configuration file justpy.env to the public IP address of the VM or to '0.0.0.0' (one should work). If you want to use the default port, set the PORT parameter to 80 (otherwise port 8000 will be used). In some cloud services only port 80 is supported by default. In some cloud services, if you are not logged in as root by default, you will need to run the program with sudo. For example you may add the following two lines to justpy.env: HOST = '0.0.0.0' PORT = 80 Alternatively, you can use the host and port parameter in the justpy command. Now, point your browser to your VM using the IP address and port and you should be good to go. If your VM is assigned a domain name, you can use that. More Complex Deployment \u00b6 For more complex deployments please look at the uvicorn deployment instructions . Make sure to set the start_server keyword argument of the justpy command to False , so that uvicorn server is not started. You also need to expose the starlette app to unvicorn. If test.py is your main program file where you import justpy then you need to add the following line to it after importing justpy: import justpy as jp app = jp . app Warning The following JustPy configuration file params do not get set in this case: HOST, PORT, UVICORN_LOGGING_LEVEL, SSL_KEYFILE, SSL_CERTFILE, SSL_VERSION. You will need to specify the required configuration in the command line or in the Gunicorn configuration file if you want to use a value different than the default one uvicorn uses.","title":"Deployment"},{"location":"tutorial/deployment/#deployment","text":"","title":"Deployment"},{"location":"tutorial/deployment/#simple-deployment","text":"Launch a Linux Virtual Machine on your preferred cloud service. If you are not a superuser, become one. Update your machine and install pip3: apt update apt install python3-pip Follow the getting started instructions. This will prepare your VM to run your JustPY program. Then, set the HOST parameter in the configuration file justpy.env to the public IP address of the VM or to '0.0.0.0' (one should work). If you want to use the default port, set the PORT parameter to 80 (otherwise port 8000 will be used). In some cloud services only port 80 is supported by default. In some cloud services, if you are not logged in as root by default, you will need to run the program with sudo. For example you may add the following two lines to justpy.env: HOST = '0.0.0.0' PORT = 80 Alternatively, you can use the host and port parameter in the justpy command. Now, point your browser to your VM using the IP address and port and you should be good to go. If your VM is assigned a domain name, you can use that.","title":"Simple Deployment"},{"location":"tutorial/deployment/#more-complex-deployment","text":"For more complex deployments please look at the uvicorn deployment instructions . Make sure to set the start_server keyword argument of the justpy command to False , so that uvicorn server is not started. You also need to expose the starlette app to unvicorn. If test.py is your main program file where you import justpy then you need to add the following line to it after importing justpy: import justpy as jp app = jp . app Warning The following JustPy configuration file params do not get set in this case: HOST, PORT, UVICORN_LOGGING_LEVEL, SSL_KEYFILE, SSL_CERTFILE, SSL_VERSION. You will need to specify the required configuration in the command line or in the Gunicorn configuration file if you want to use a value different than the default one uvicorn uses.","title":"More Complex Deployment"},{"location":"tutorial/drag_and_drop/","text":"Drag and Drop \u00b6 In version 0.0.9 initial drag and drop support has been added. This feature should be considered experimental and I welcome input on how to improve it. In the example below, a image can be dragged and dropped between containers on screen. JustPy elements now support the 'dragstart', 'dragover', and 'drop' events. import justpy as jp def drag_start ( self , msg ): print ( 'in drag start' ) print ( msg ) msg . page . image . animation = False return True def drop ( self , msg ): print ( 'in drop' ) print ( msg ) wp = msg . page wp . image . animation = 'zoomIn' if self . index != wp . current_index : wp . div_list [ self . index ] . add ( wp . image ) wp . div_list [ wp . current_index ] . components = [] wp . current_index = self . index def drag_test (): wp = jp . WebPage () wp . current_index = 0 drag_options = { 'drag_classes' : 'text-white bg-red-500' } wp . image = jp . Img ( src = 'https://www.python.org/static/community_logos/python-powered-h-140x182.png' , height = 100 , width = 100 , classes = 'border faster' , drag_options = drag_options , animation = 'zoomIn' ) wp . image . on ( 'dragstart' , drag_start ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) wp . div_list = [ jp . Div ( style = 'height: 160px; width: 130px' , classes = 'm-4 border-2 flex items-center justify-center' , drop = drop , a = d , index = i ) for i in range ( 30 )] for div in wp . div_list : div . events . append ( 'dragover' ) wp . div_list [ 0 ] . add ( wp . image ) return wp jp . justpy ( drag_test )","title":"Drag and Drop"},{"location":"tutorial/drag_and_drop/#drag-and-drop","text":"In version 0.0.9 initial drag and drop support has been added. This feature should be considered experimental and I welcome input on how to improve it. In the example below, a image can be dragged and dropped between containers on screen. JustPy elements now support the 'dragstart', 'dragover', and 'drop' events. import justpy as jp def drag_start ( self , msg ): print ( 'in drag start' ) print ( msg ) msg . page . image . animation = False return True def drop ( self , msg ): print ( 'in drop' ) print ( msg ) wp = msg . page wp . image . animation = 'zoomIn' if self . index != wp . current_index : wp . div_list [ self . index ] . add ( wp . image ) wp . div_list [ wp . current_index ] . components = [] wp . current_index = self . index def drag_test (): wp = jp . WebPage () wp . current_index = 0 drag_options = { 'drag_classes' : 'text-white bg-red-500' } wp . image = jp . Img ( src = 'https://www.python.org/static/community_logos/python-powered-h-140x182.png' , height = 100 , width = 100 , classes = 'border faster' , drag_options = drag_options , animation = 'zoomIn' ) wp . image . on ( 'dragstart' , drag_start ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) wp . div_list = [ jp . Div ( style = 'height: 160px; width: 130px' , classes = 'm-4 border-2 flex items-center justify-center' , drop = drop , a = d , index = i ) for i in range ( 30 )] for div in wp . div_list : div . events . append ( 'dragover' ) wp . div_list [ 0 ] . add ( wp . image ) return wp jp . justpy ( drag_test )","title":"Drag and Drop"},{"location":"tutorial/equations/","text":"Equations \u00b6 The Equation component is a wrapper around the Katex JavaScript library. Use the options attribute to modify behavior as required. Info throwOnError option is overridden and set to false You can also add equations using the WebPage equation method import justpy as jp integral = r \"\"\" \\f\\relax {x} = \\int_{-\\infty}^\\infty \\f\\hat\\xi\\,e^{2 \\pi i \\xi x} \\,d\\xi \"\"\" f1 = r ''' a + ar + a r^2 + a r^3 + \\cdots + a r^{n-1} = \\sum_{k=0}^{n-1} ar^k = a \\left(\\frac{1-r^ {n} }{1-r}\\right) ''' f2 = r ''' \\displaystyle \\frac {1} {\\Bigl(\\sqrt{\\phi \\sqrt {5} }-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } } ''' async def button_click ( self , msg ): wp = msg . page wp . eq1 . equation += ' + \\\\ sqrt {d} + 1' def eq_test ( request ): wp = jp . WebPage () wp . btn = jp . Button ( text = 'Modify Equation' , click = button_click , a = wp , classes = jp . Styles . button_simple + ' m-2 p-2' ) wp . eq1 = jp . Equation ( equation = 'c = \\\\ pm \\\\ sqrt{a^2 + b^2 + c^2}' , classes = 'text-3xl m-2 p-2' , a = wp ) # Add a macro eq2 = jp . Equation ( equation = integral , classes = 'text-3xl m-2 p-2' , a = wp ) eq2 . options [ 'macros' ][ ' \\\\ f' ] = '#1f(#2)' jp . Equation ( equation = f1 , classes = 'text-3xl m-2 p-2' , a = wp ) jp . Equation ( equation = f2 , classes = 'text-3xl m-2 p-2' , a = wp ) # Use raw strings when convenient jp . Equation ( equation = 'c = \\\\ pm \\\\ sqrt{a^2 + b^2} \\\\ in \\\\ RR' , options = { 'macros' : { \" \\\\ RR\" : \" \\\\ mathbb {R} \" }}, classes = 'text-3xl m-2 p-2' , a = wp ) jp . Equation ( equation = r 'e = \\pm\\sqrt{c^2 + d^2}\\in\\RR' , options = { 'macros' : { \" \\\\ RR\" : \" \\\\ mathbb {R} \" }}, classes = 'text-3xl m-2 p-2' , a = wp ) # You can also add equations using the WebPage equation method wp . equation ( r 'e^{i\\pi}+1=0' ) a = wp . equation ( r 'e^{i\\pi}+1=0' ) a . classes = 'bg-blue-500 text-5xl text-white m-2 p-4 inline-block' return wp # You can also add KATEX = True to justpy.env instead of specifying below jp . justpy ( eq_test , KATEX = True )","title":"Equations"},{"location":"tutorial/equations/#equations","text":"The Equation component is a wrapper around the Katex JavaScript library. Use the options attribute to modify behavior as required. Info throwOnError option is overridden and set to false You can also add equations using the WebPage equation method import justpy as jp integral = r \"\"\" \\f\\relax {x} = \\int_{-\\infty}^\\infty \\f\\hat\\xi\\,e^{2 \\pi i \\xi x} \\,d\\xi \"\"\" f1 = r ''' a + ar + a r^2 + a r^3 + \\cdots + a r^{n-1} = \\sum_{k=0}^{n-1} ar^k = a \\left(\\frac{1-r^ {n} }{1-r}\\right) ''' f2 = r ''' \\displaystyle \\frac {1} {\\Bigl(\\sqrt{\\phi \\sqrt {5} }-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } } ''' async def button_click ( self , msg ): wp = msg . page wp . eq1 . equation += ' + \\\\ sqrt {d} + 1' def eq_test ( request ): wp = jp . WebPage () wp . btn = jp . Button ( text = 'Modify Equation' , click = button_click , a = wp , classes = jp . Styles . button_simple + ' m-2 p-2' ) wp . eq1 = jp . Equation ( equation = 'c = \\\\ pm \\\\ sqrt{a^2 + b^2 + c^2}' , classes = 'text-3xl m-2 p-2' , a = wp ) # Add a macro eq2 = jp . Equation ( equation = integral , classes = 'text-3xl m-2 p-2' , a = wp ) eq2 . options [ 'macros' ][ ' \\\\ f' ] = '#1f(#2)' jp . Equation ( equation = f1 , classes = 'text-3xl m-2 p-2' , a = wp ) jp . Equation ( equation = f2 , classes = 'text-3xl m-2 p-2' , a = wp ) # Use raw strings when convenient jp . Equation ( equation = 'c = \\\\ pm \\\\ sqrt{a^2 + b^2} \\\\ in \\\\ RR' , options = { 'macros' : { \" \\\\ RR\" : \" \\\\ mathbb {R} \" }}, classes = 'text-3xl m-2 p-2' , a = wp ) jp . Equation ( equation = r 'e = \\pm\\sqrt{c^2 + d^2}\\in\\RR' , options = { 'macros' : { \" \\\\ RR\" : \" \\\\ mathbb {R} \" }}, classes = 'text-3xl m-2 p-2' , a = wp ) # You can also add equations using the WebPage equation method wp . equation ( r 'e^{i\\pi}+1=0' ) a = wp . equation ( r 'e^{i\\pi}+1=0' ) a . classes = 'bg-blue-500 text-5xl text-white m-2 p-4 inline-block' return wp # You can also add KATEX = True to justpy.env instead of specifying below jp . justpy ( eq_test , KATEX = True )","title":"Equations"},{"location":"tutorial/form/","text":"Form Component \u00b6 The main advantage of the form tag in HTML , is that it supports an action called \"submit\" that collects the information from the input elements on the form and sends them to the server to be processed by a script that can be specified. Note It is only necessary to use the Form component with JustPy when you need to handle file uploads by using an Input with type file . In all other cases Input elements can be put on a page without the need to organize them inside a form. The submit Event \u00b6 In JustPy, forms support the \"submit\" event that allows similar functionality. The input elements of the form are put in a list and added to the second argument of the event handler under the form_data key. In the program below the submit event occurs when an Input element of type submit (a button for all practical purposes) is clicked. import justpy as jp button_classes = 'bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded m-2' input_classes = 'border m-2 p-2' session_data = {} def form_test (): wp = jp . WebPage () wp . display_url = '/fill_form' form1 = jp . Form ( a = wp , classes = 'border m-1 p-1 w-64' ) user_label = jp . Label ( text = 'User Name' , classes = 'block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2' , a = form1 ) in1 = jp . Input ( placeholder = 'User Name' , a = form1 , classes = 'form-input' ) user_label . for_component = in1 password_label = jp . Label ( classes = 'block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2 mt-2' , a = form1 ) jp . Div ( text = 'Password' , classes = 'block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2' , a = password_label ) jp . Input ( placeholder = 'Password' , a = password_label , classes = 'form-input' , type = 'password' ) check_label = jp . Label ( classes = 'text-sm block' , a = form1 ) jp . Input ( type = 'checkbox' , a = check_label , classes = 'form-checkbox text-blue-500' ) jp . Span ( text = 'Send me stuff' , a = check_label , classes = 'ml-2' ) submit_button = jp . Input ( value = 'Submit Form' , type = 'submit' , a = form1 , classes = button_classes ) def submit_form ( self , msg ): print ( msg ) msg . page . redirect = '/form_submitted' session_data [ msg . session_id ] = msg . form_data form1 . on ( 'submit' , submit_form ) return wp @jp . SetRoute ( '/form_submitted' ) def form_submitted ( request ): wp = jp . WebPage () wp . display_url = '/thanks' jp . Div ( text = 'Thank you for submitting the form' , a = wp , classes = 'text-xl m-2 p-2' ) for field in session_data [ request . session_id ]: if field . type in [ 'text' , 'password' ]: jp . Div ( text = f ' {field.placeholder} : {field.value} ' , a = wp , classes = 'text-lg m-1 p-1' ) elif field . type == 'checkbox' and field . checked : jp . Div ( text = 'We will send you stuff' , a = wp , classes = 'text-lg m-1 p-1' ) return wp jp . justpy ( form_test ) In the example above, we set the redirect attribute of the page in submit_form , the event handler for the submit event. This opens the page generated by the request handler form_submitted instead of the page with the form. We could have also modified the same page to show the information. To make the form information available to the new page, we store it in the global session_data dictionary using the session id as the key (it is always added to the request argument of the the request handlers and can be accessed as request.session_id ). The Label Component \u00b6 Notice also the use of the Label component which corresponds to the label HTML tag. The two methods of associating a Label with an Input component are used above. The first is to set the for_component attribute of the Label instance to the Input instance. The second is to add the Input instance to the Label instance.","title":"Forms"},{"location":"tutorial/form/#form-component","text":"The main advantage of the form tag in HTML , is that it supports an action called \"submit\" that collects the information from the input elements on the form and sends them to the server to be processed by a script that can be specified. Note It is only necessary to use the Form component with JustPy when you need to handle file uploads by using an Input with type file . In all other cases Input elements can be put on a page without the need to organize them inside a form.","title":"Form Component"},{"location":"tutorial/form/#the-submit-event","text":"In JustPy, forms support the \"submit\" event that allows similar functionality. The input elements of the form are put in a list and added to the second argument of the event handler under the form_data key. In the program below the submit event occurs when an Input element of type submit (a button for all practical purposes) is clicked. import justpy as jp button_classes = 'bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded m-2' input_classes = 'border m-2 p-2' session_data = {} def form_test (): wp = jp . WebPage () wp . display_url = '/fill_form' form1 = jp . Form ( a = wp , classes = 'border m-1 p-1 w-64' ) user_label = jp . Label ( text = 'User Name' , classes = 'block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2' , a = form1 ) in1 = jp . Input ( placeholder = 'User Name' , a = form1 , classes = 'form-input' ) user_label . for_component = in1 password_label = jp . Label ( classes = 'block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2 mt-2' , a = form1 ) jp . Div ( text = 'Password' , classes = 'block uppercase tracking-wide text-gray-700 text-xs font-bold mb-2' , a = password_label ) jp . Input ( placeholder = 'Password' , a = password_label , classes = 'form-input' , type = 'password' ) check_label = jp . Label ( classes = 'text-sm block' , a = form1 ) jp . Input ( type = 'checkbox' , a = check_label , classes = 'form-checkbox text-blue-500' ) jp . Span ( text = 'Send me stuff' , a = check_label , classes = 'ml-2' ) submit_button = jp . Input ( value = 'Submit Form' , type = 'submit' , a = form1 , classes = button_classes ) def submit_form ( self , msg ): print ( msg ) msg . page . redirect = '/form_submitted' session_data [ msg . session_id ] = msg . form_data form1 . on ( 'submit' , submit_form ) return wp @jp . SetRoute ( '/form_submitted' ) def form_submitted ( request ): wp = jp . WebPage () wp . display_url = '/thanks' jp . Div ( text = 'Thank you for submitting the form' , a = wp , classes = 'text-xl m-2 p-2' ) for field in session_data [ request . session_id ]: if field . type in [ 'text' , 'password' ]: jp . Div ( text = f ' {field.placeholder} : {field.value} ' , a = wp , classes = 'text-lg m-1 p-1' ) elif field . type == 'checkbox' and field . checked : jp . Div ( text = 'We will send you stuff' , a = wp , classes = 'text-lg m-1 p-1' ) return wp jp . justpy ( form_test ) In the example above, we set the redirect attribute of the page in submit_form , the event handler for the submit event. This opens the page generated by the request handler form_submitted instead of the page with the form. We could have also modified the same page to show the information. To make the form information available to the new page, we store it in the global session_data dictionary using the session id as the key (it is always added to the request argument of the the request handlers and can be accessed as request.session_id ).","title":"The submit Event"},{"location":"tutorial/form/#the-label-component","text":"Notice also the use of the Label component which corresponds to the label HTML tag. The two methods of associating a Label with an Input component are used above. The first is to set the for_component attribute of the Label instance to the Input instance. The second is to add the Input instance to the Label instance.","title":"The Label Component"},{"location":"tutorial/getting_started/","text":"Getting Started \u00b6 In order to take full advantage of this tutorial some knowledge of Python is required including an understanding of object oriented programming in Python. In addition, a basic understanding of HTML is required ( HTML - Getting Started ). Info The examples in this tutorial use Python f-strings which were added in Python 3.6 Tip If you have a question about JustPy please open an issue in the JustPy Github repository or post a question with the tag [justpy] to stack overflow . I will try to answer promptly. Installation \u00b6 First, make sure that the version of python3 you have is 3.6 or higher: $ python3 --version If not, upgrade your Python interpreter. It is probably best to run the programs in this tutorial in a virtual environment so that your system wide Python interpreter is not affected, though this is not a requirement. The following commands create a directory for this tutorial, then create a virtual environment named jp and activate it and finally install JustPy and its dependencies: $ mkdir jptutorial $ cd jptutorial $ python3 -m venv jp $ source jp/bin/activate ( jp ) $ pip install justpy On Microsoft Windows, the activation command for the virtual environment is jp\\Scripts\\activate instead of the source command above. Now, using your favorite code editor, create a file in the jptutorial directory called test.py that includes the following code: import justpy as jp def hello_world (): wp = jp . WebPage () jp . Hello ( a = wp ) return wp jp . justpy ( hello_world ) Note You can easily copy the code by hovering over it and then clicking 'Copy to clipboard' in the upper right corner Running the Program \u00b6 To run the program execute the following command: $ python3 test.py Then, direct your browser to http://127.0.0.1:8000 or http://localhost:8000/ This refers to port 8000 on the local machine and should work in most environments. You should see 'Hello!' in your browser. Click it a few times also. It should report the number of times it has been clicked. In this tutorial, when asked to \"run the program\", follow the two steps above (there is no need to name the file \"test.py\", you can use any name you like).","title":"Getting Started"},{"location":"tutorial/getting_started/#getting-started","text":"In order to take full advantage of this tutorial some knowledge of Python is required including an understanding of object oriented programming in Python. In addition, a basic understanding of HTML is required ( HTML - Getting Started ). Info The examples in this tutorial use Python f-strings which were added in Python 3.6 Tip If you have a question about JustPy please open an issue in the JustPy Github repository or post a question with the tag [justpy] to stack overflow . I will try to answer promptly.","title":"Getting Started"},{"location":"tutorial/getting_started/#installation","text":"First, make sure that the version of python3 you have is 3.6 or higher: $ python3 --version If not, upgrade your Python interpreter. It is probably best to run the programs in this tutorial in a virtual environment so that your system wide Python interpreter is not affected, though this is not a requirement. The following commands create a directory for this tutorial, then create a virtual environment named jp and activate it and finally install JustPy and its dependencies: $ mkdir jptutorial $ cd jptutorial $ python3 -m venv jp $ source jp/bin/activate ( jp ) $ pip install justpy On Microsoft Windows, the activation command for the virtual environment is jp\\Scripts\\activate instead of the source command above. Now, using your favorite code editor, create a file in the jptutorial directory called test.py that includes the following code: import justpy as jp def hello_world (): wp = jp . WebPage () jp . Hello ( a = wp ) return wp jp . justpy ( hello_world ) Note You can easily copy the code by hovering over it and then clicking 'Copy to clipboard' in the upper right corner","title":"Installation"},{"location":"tutorial/getting_started/#running-the-program","text":"To run the program execute the following command: $ python3 test.py Then, direct your browser to http://127.0.0.1:8000 or http://localhost:8000/ This refers to port 8000 on the local machine and should work in most environments. You should see 'Hello!' in your browser. Click it a few times also. It should report the number of times it has been clicked. In this tutorial, when asked to \"run the program\", follow the two steps above (there is no need to name the file \"test.py\", you can use any name you like).","title":"Running the Program"},{"location":"tutorial/handling_events/","text":"Handling Events \u00b6 In this part of the tutorial you will learn how to deal with user generated events such as a mouse click. JustPy deals with such events by binding a function to an event. When the event occurs, the function is executed. Please run the following program and click on 'Not clicked yet': import justpy as jp def my_click ( self , msg ): self . text = 'I was clicked' def event_demo (): wp = jp . WebPage () d = jp . Div ( text = 'Not clicked yet' , a = wp , classes = 'w-48 text-xl m-2 p-1 bg-blue-500 text-white' ) d . on ( 'click' , my_click ) return wp jp . justpy ( event_demo ) In event_demo , we first create a web page. Then we create a Div element named d whose content is the string \"Not clicked yet\" and add it to the page (we also add some Tailwind classes for formatting). Then, using the on method, we bind the function my_click , which we defined earlier, to the click event and return the page. When the the element on the page is clicked, JustPy runs the function my_click . Info Functions that handle events are called \"event handlers\". my_click is an example of such a function. Warning In JustPy, event handlers must have two arguments. The first (I recommend calling it self ), is the object which generated the event. It is an instance of one of the component classes. In the example above it is d , an instance of the class Div . The second parameter (I recommend calling it msg ) is a dictionary that contains information about the event. The items in this dictionary can also be accessed using attribute (dot) notation. To get the event type for example we could write either msg['event_type'] or msg.event_type . In the program below I have added some print commands to the my_click function. Run it and see what is printed to the console. import justpy as jp def my_click ( self , msg ): self . text = 'I was clicked' print ( msg . event_type ) print ( msg [ 'event_type' ]) print ( msg ) def event_demo (): wp = jp . WebPage () d = jp . P ( text = 'Not clicked yet' , a = wp , classes = 'text-xl m-2 p-2 bg-blue-500 text-white' ) d . on ( 'click' , my_click ) return wp jp . justpy ( event_demo ) Additional Event Properties \u00b6 JustPy does not pass all the JavaScript event properties by default since in most cases they are not needed. If you need additional properties from the JavasScript event, use the additional_properties attribute. In the example below, more fields are added to msg . import justpy as jp def my_click ( self , msg ): print ( msg ) self . text = 'I was clicked' def event_demo (): wp = jp . WebPage () wp . debug = True d = jp . Div ( text = 'Not clicked yet' , a = wp , classes = 'w-48 text-xl m-2 p-1 bg-blue-500 text-white' ) d . on ( 'click' , my_click ) d . additional_properties = [ 'screenX' , 'pageY' , 'altKey' , 'which' , 'movementX' , 'button' , 'buttons' ] return wp jp . justpy ( event_demo ) Multiple Events \u00b6 The same element can handle multiple events. Run the following and move the mouse in and out of the element on the page. Click the element also. import justpy as jp def my_click ( self , msg ): self . text = 'I was clicked' self . set_class ( 'bg-blue-500' ) def my_mouseenter ( self , msg ): self . text = 'Mouse entered' self . set_class ( 'bg-red-500' ) def my_mouseleave ( self , msg ): self . text = 'Mouse left' self . set_class ( 'bg-teal-500' ) def event_demo (): wp = jp . WebPage () d = jp . Div ( text = 'Not clicked yet' , a = wp , classes = 'w-64 text-2xl m-2 p-2 bg-blue-500 text-white' , click = my_click , mouseenter = my_mouseenter , mouseleave = my_mouseleave ) return wp jp . justpy ( event_demo ) In the example above, there are three event handlers, one each for the click , mouseenter and mouseleave events. All three are bound to the same element, d . Another way of binding event handlers is demonstrated here. Instead of using the on method, you can bind an event handler using a keyword argument that corresponds to the name of the event. In addition to click (or some other event name) you can also use onclick or, on_click . All three options work in the same way. The above example also introduces the set_class method. This method \"knows\" which Tailwind classes logically cannot apply together (for example, text color can't be both red and blue at the same time) and removes the appropriate classes while adding the class provided as parameter. In the case above, the background can only be one color so the set_class method removes the class bg-blue-500 and adds the class bg-red-500. Sharing Event Handlers \u00b6 Example 1 \u00b6 In many cases it is convenient to share one event handler among several elements. Please run the example below: import justpy as jp def button_click ( self , msg ): self . num_clicked += 1 self . message . text = f ' {self.text} clicked. Number of clicks: {self.num_clicked} ' self . set_class ( 'bg-red-500' ) self . set_class ( 'bg-red-700' , 'hover' ) def event_demo (): number_of_buttons = 25 wp = jp . WebPage () button_div = jp . Div ( classes = 'flex m-4 flex-wrap' , a = wp ) button_classes = 'w-32 mr-2 mb-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full' message = jp . Div ( text = 'No button clicked yet' , classes = 'text-2xl border m-4 p-2' , a = wp ) for i in range ( 1 , number_of_buttons + 1 ): b = jp . Button ( text = f 'Button {i} ' , a = button_div , classes = button_classes , click = button_click ) b . message = message b . num_clicked = 0 return wp jp . justpy ( event_demo ) This program creates 25 buttons on each page. Under the buttons is a message box that provides information about which button was clicked and how many times it was clicked (try clicking the same button several times and see the change in the message box). Let's delve into the program in more detail. The program has two functions. The function event_demo creates the page and returns it when a page is requested. The function button_click will handle the click event of all buttons. In the first line of event_demo , the number of buttons is set (try changing this number and see what happens). The second line creates a web page. The third line creates a div element (the general purpose HTML container element) named button_div . We will use it shortly to contain all the buttons. Notice that using a=wp we add button_div to the page. The fourth line defines the classes that will be used to format all the buttons. Don't worry if you don't understand what all the Tailwind classes do at this stage, it is not important. The fifth line creates the message element and adds it to the page. This element displays information about the button that is clicked. On the sixth line the loop that creates all the buttons starts. For each iteration of the loop, a button is created and added to button_div . Since button_div was previously added to the web page, the buttons will also be displayed on the page. A button in JustPy is just an instance of the Button class, and therefore we can assign additional attributes to the instance. That is what we do in the next two lines. We assign to the message attribute the message element and initialize the num_clicked attribute to 0 (these attributes will be used in the button_click function as we shall see shortly). After the loop, the web page is returned, and the framework renders it to the user's browser. It may seem that the loop is erasing previous buttons by redefining the variable b . That is not the case because each time through the loop a new button is created and is added to the component list of button_div (using the keyword argument notation: a=button_div ). At the end of the loop, button_div has 25 distinct child component instances. You can verify this by adding the following two lines just before the return statement of event_demo and re-running the program: print ( button_div ) print ( button_div . components ) The components attribute is a list that holds all the child component instances of the element in the order they will be rendered. It is named \"components\" because it holds the building blocks of the element (though strictly speaking, the list holds elements which are instances of components). Let's take a look now at button_click , the second function in our program. When any one of the buttons is clicked, this function is executed. The arguments for button_click are the same as those for all event handlers in JustPy. The first argument self , is the button. In JustPy, as previously discussed, elements on the page are represented by instances of Python classes. The buttons we created are instances of the Button class and therefore in this case self will be an instance of the Button class. In the first line of button_click we increment the instance attribute that tracks the number of times the specific button was clicked. It was initialized as 0 when we created the button in event_demo . The second line changes the text of the message box. Since we conveniently assigned the appropriate div element to the message attribute of all buttons, we know where to find it. It is right there as an attribute of self . Please skip this paragraph if you are not familiar with JavaScript: Contrast this with the JavaScript methods of getting elements by id or class or using some more complex DOM query. In most cases we don't need to query the Python representation of the DOM if we anticipate in advance which elements an event handler will require. The last two lines of button_click change the background of the button that was clicked to red and change the background of the button when it is hovered. Example 2 \u00b6 As the program is written now, once a button is clicked, its background will always be red, even if another button is clicked. If we want only the background of the last clicked button to be red, the event handler needs to set the background of all other buttons back to blue. There are many ways that this could be done but I would like to highlight a method that can be generalized to most cases. The web page itself is an instance of a Python class and therefore can have user specified attributes. We will create a list of all the buttons and assign it to the button_list attribute of the page. In the event handler we will loop over this list and change the backgrounds to blue after which we will set the background of the clicked button to red. Info We know which page's button_list we need to loop over because the page on which the event originated is always provided to the event handler in msg.page by JustPy. The result looks like this: import justpy as jp def button_click ( self , msg ): self . num_clicked += 1 self . message . text = f ' {self.text} clicked. Number of clicks: {self.num_clicked} ' for button in msg . page . button_list : button . set_class ( 'bg-blue-500' ) button . set_class ( 'bg-blue-700' , 'hover' ) self . set_class ( 'bg-red-500' ) self . set_class ( 'bg-red-700' , 'hover' ) def event_demo (): number_of_buttons = 25 wp = jp . WebPage () button_div = jp . Div ( classes = 'flex m-4 flex-wrap' , a = wp ) button_classes = 'w-32 mr-2 mb-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full' message = jp . P ( text = 'No button clicked yet' , classes = 'text-2xl border m-4 p-2' , a = wp ) button_list = [] for i in range ( 1 , number_of_buttons + 1 ): b = jp . Button ( text = f 'Button {i} ' , a = button_div , classes = button_classes , click = button_click ) b . message = message b . num_clicked = 0 button_list . append ( b ) wp . button_list = button_list # The list will now be referenced by the WebPage instance attribute return wp jp . justpy ( event_demo ) Example 3 - Event changes elements on page \u00b6 Events can also change the elements on the page itself, adding or removing them as necessary. As a concrete example let's change the program above to display a log of buttons that were clicked instead of just one line of information. import justpy as jp def button_click ( self , msg ): self . num_clicked += 1 # self.message.text = f'{self.text} clicked. Number of clicks: {self.num_clicked}' p = jp . P ( text = f ' {self.text} clicked. Number of clicks: {self.num_clicked} ' ) self . message . add_component ( p , 0 ) for button in msg . page . button_list : button . set_class ( 'bg-blue-500' ) button . set_class ( 'bg-blue-700' , 'hover' ) self . set_class ( 'bg-red-500' ) self . set_class ( 'bg-red-700' , 'hover' ) def event_demo (): number_of_buttons = 25 wp = jp . WebPage () button_div = jp . Div ( classes = 'flex m-4 flex-wrap' , a = wp ) button_classes = 'w-32 mr-2 mb-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full' message = jp . Div ( classes = 'text-lg border m-2 p-2 overflow-auto h-64' , a = wp ) message . add ( jp . P ( text = 'No button clicked yet' )) button_list = [] for i in range ( 1 , number_of_buttons + 1 ): b = jp . Button ( text = f 'Button {i} ' , a = button_div , classes = button_classes , click = button_click ) b . message = message b . num_clicked = 0 button_list . append ( b ) wp . button_list = button_list # The list will now be referenced by the WebPage instance attribute return wp jp . justpy ( event_demo ) Instead of just changing the text in message , button_click creates a p element with the text message and adds the element to message using the add_component method. It is different from add because it allows adding a component at any position. Here, we are adding the new log info at the beginning of the message div so that most recent messages show up first. Also, in event_demo we changed message to a div element and added the first message as a p element with text. Inline Event Handlers \u00b6 In a very non-Pythonic manner, JustPy supports inserting inline functions as event handlers when creating an element. I confess to using these functions sometimes for event handlers that are just one or two lines of code. The function itself is represented as a string, not a real Python function. Statements are separated by the semicolon. The function assumes that the two arguments are self and msg . The namespace is that of the JustPy package. If you want the function to have access to a variable, assign it to an attribute of self . import justpy as jp def comp_test (): wp = jp . WebPage () d = jp . Div ( text = 'hello1' , click = 'self.text=\"clicked\"' , mouseenter = 'self.text=\"entered\"; self.set_class(\"text-5xl\"); msg.page.add(Div(text=f\"{len(msg.page)} Additional Div\"))' , mouseleave = 'self.text=\"left\"; self.set_class(\"text-xl\")' , classes = 'text-2xl border p-2 m-2' , a = wp ) d = jp . Div ( text = 'hello2' , click = 'self.text=\"clicked\"' , mouseenter = 'self.text=\"entered\"' , classes = 'text-2xl border p-2 m-2' , a = wp ) d = jp . Div ( text = 'hello3' , click = 'self.text=\"clicked\"' , mouseenter = 'self.text=\"entered\"' , classes = 'text-2xl border p-2 m-2' , a = wp ) return wp jp . justpy ( comp_test ) The debounce and throttle Event Modifiers \u00b6 Sometimes you need to debounce or throttle on event. To do this, use the debounce and throttle keyword arguments of the on method. The value is the wait time in milliseconds. If you want the debounce to be leading edge, set the immediate attribute of on to True . The example below also uses the add_event method. The mousemove event is not among the events that are supported by default and needs to be added to the element's allowed events. import justpy as jp def mouse_event ( self , msg ): try : self . counter += 1 except : self . counter = 1 msg . page . info_div . add_first ( jp . Div ( text = f ' {self.counter} ) {msg.event_type} ' )) def debounce_test (): wp = jp . WebPage () d = jp . Div ( style = 'height: 100vh' , a = wp ) d . add_event ( 'mousemove' ) d . on ( 'mousemove' , mouse_event , throttle = 1000 ) d . on ( 'click' , mouse_event , debounce = 2000 , immediate = False ) wp . info_div = jp . Div ( text = 'Recent mouse events' , classes = 'm-4 text-lg' , a = d ) return wp jp . justpy ( debounce_test ) The click__out Event \u00b6 The click__out event fires when there is a click outside of an element. This is useful for example in the case of dropdown list you would like closed when there is a click outside of the dropdown element. Info Notice the TWO underline characters in click__out . import justpy as jp def click_out ( self , msg ): self . text = 'click out' self . set_classes ( 'text-blue-500' ) def click_in ( self , msg ): self . text = 'click in' self . set_classes ( 'text-red-500' ) def test_out (): wp = jp . WebPage () for i in range ( 4 ): d = jp . Div ( text = f ' {i} ) Div' , a = wp , classes = 'm-4 p-4 text-xl border w-32' ) d . on ( 'click__out' , click_out ) d . on ( 'click' , click_in ) return wp jp . justpy ( test_out ) Event Handlers Defined in Components \u00b6 This section reflects changes introduced in version 0.1.0 Note You may want to return to this section after having covered the custom components part of the tutorial In the example below we define a simple component that is a Div that includes 5 buttons and another Div with some information. If an event handler is defined as a method of a component, the self attribute passed to it will be that of the component instance and not of the child instance which originated the event. That child instance can be found in the msg.target field. import justpy as jp class ButtonDiv ( jp . Div ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) for i in range ( 1 , 6 ): b = jp . Button ( text = f 'Button {i} ' , a = self , classes = ' m-2 p-2 border text-blue text-lg' ) b . num = i b . on ( 'click' , self . button_clicked ) self . info_div = jp . Div ( text = 'info will go here' , classes = 'm-2 p-2 border' , a = self ) def button_clicked ( self , msg ): print ( self ) print ( msg . target ) self . info_div . text = f 'Button {msg.target.num} was clicked' def target_test (): wp = jp . WebPage () ButtonDiv ( a = wp ) return wp jp . justpy ( target_test )","title":"Handling Events"},{"location":"tutorial/handling_events/#handling-events","text":"In this part of the tutorial you will learn how to deal with user generated events such as a mouse click. JustPy deals with such events by binding a function to an event. When the event occurs, the function is executed. Please run the following program and click on 'Not clicked yet': import justpy as jp def my_click ( self , msg ): self . text = 'I was clicked' def event_demo (): wp = jp . WebPage () d = jp . Div ( text = 'Not clicked yet' , a = wp , classes = 'w-48 text-xl m-2 p-1 bg-blue-500 text-white' ) d . on ( 'click' , my_click ) return wp jp . justpy ( event_demo ) In event_demo , we first create a web page. Then we create a Div element named d whose content is the string \"Not clicked yet\" and add it to the page (we also add some Tailwind classes for formatting). Then, using the on method, we bind the function my_click , which we defined earlier, to the click event and return the page. When the the element on the page is clicked, JustPy runs the function my_click . Info Functions that handle events are called \"event handlers\". my_click is an example of such a function. Warning In JustPy, event handlers must have two arguments. The first (I recommend calling it self ), is the object which generated the event. It is an instance of one of the component classes. In the example above it is d , an instance of the class Div . The second parameter (I recommend calling it msg ) is a dictionary that contains information about the event. The items in this dictionary can also be accessed using attribute (dot) notation. To get the event type for example we could write either msg['event_type'] or msg.event_type . In the program below I have added some print commands to the my_click function. Run it and see what is printed to the console. import justpy as jp def my_click ( self , msg ): self . text = 'I was clicked' print ( msg . event_type ) print ( msg [ 'event_type' ]) print ( msg ) def event_demo (): wp = jp . WebPage () d = jp . P ( text = 'Not clicked yet' , a = wp , classes = 'text-xl m-2 p-2 bg-blue-500 text-white' ) d . on ( 'click' , my_click ) return wp jp . justpy ( event_demo )","title":"Handling Events"},{"location":"tutorial/handling_events/#additional-event-properties","text":"JustPy does not pass all the JavaScript event properties by default since in most cases they are not needed. If you need additional properties from the JavasScript event, use the additional_properties attribute. In the example below, more fields are added to msg . import justpy as jp def my_click ( self , msg ): print ( msg ) self . text = 'I was clicked' def event_demo (): wp = jp . WebPage () wp . debug = True d = jp . Div ( text = 'Not clicked yet' , a = wp , classes = 'w-48 text-xl m-2 p-1 bg-blue-500 text-white' ) d . on ( 'click' , my_click ) d . additional_properties = [ 'screenX' , 'pageY' , 'altKey' , 'which' , 'movementX' , 'button' , 'buttons' ] return wp jp . justpy ( event_demo )","title":"Additional Event Properties"},{"location":"tutorial/handling_events/#multiple-events","text":"The same element can handle multiple events. Run the following and move the mouse in and out of the element on the page. Click the element also. import justpy as jp def my_click ( self , msg ): self . text = 'I was clicked' self . set_class ( 'bg-blue-500' ) def my_mouseenter ( self , msg ): self . text = 'Mouse entered' self . set_class ( 'bg-red-500' ) def my_mouseleave ( self , msg ): self . text = 'Mouse left' self . set_class ( 'bg-teal-500' ) def event_demo (): wp = jp . WebPage () d = jp . Div ( text = 'Not clicked yet' , a = wp , classes = 'w-64 text-2xl m-2 p-2 bg-blue-500 text-white' , click = my_click , mouseenter = my_mouseenter , mouseleave = my_mouseleave ) return wp jp . justpy ( event_demo ) In the example above, there are three event handlers, one each for the click , mouseenter and mouseleave events. All three are bound to the same element, d . Another way of binding event handlers is demonstrated here. Instead of using the on method, you can bind an event handler using a keyword argument that corresponds to the name of the event. In addition to click (or some other event name) you can also use onclick or, on_click . All three options work in the same way. The above example also introduces the set_class method. This method \"knows\" which Tailwind classes logically cannot apply together (for example, text color can't be both red and blue at the same time) and removes the appropriate classes while adding the class provided as parameter. In the case above, the background can only be one color so the set_class method removes the class bg-blue-500 and adds the class bg-red-500.","title":"Multiple Events"},{"location":"tutorial/handling_events/#sharing-event-handlers","text":"","title":"Sharing Event Handlers"},{"location":"tutorial/handling_events/#example-1","text":"In many cases it is convenient to share one event handler among several elements. Please run the example below: import justpy as jp def button_click ( self , msg ): self . num_clicked += 1 self . message . text = f ' {self.text} clicked. Number of clicks: {self.num_clicked} ' self . set_class ( 'bg-red-500' ) self . set_class ( 'bg-red-700' , 'hover' ) def event_demo (): number_of_buttons = 25 wp = jp . WebPage () button_div = jp . Div ( classes = 'flex m-4 flex-wrap' , a = wp ) button_classes = 'w-32 mr-2 mb-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full' message = jp . Div ( text = 'No button clicked yet' , classes = 'text-2xl border m-4 p-2' , a = wp ) for i in range ( 1 , number_of_buttons + 1 ): b = jp . Button ( text = f 'Button {i} ' , a = button_div , classes = button_classes , click = button_click ) b . message = message b . num_clicked = 0 return wp jp . justpy ( event_demo ) This program creates 25 buttons on each page. Under the buttons is a message box that provides information about which button was clicked and how many times it was clicked (try clicking the same button several times and see the change in the message box). Let's delve into the program in more detail. The program has two functions. The function event_demo creates the page and returns it when a page is requested. The function button_click will handle the click event of all buttons. In the first line of event_demo , the number of buttons is set (try changing this number and see what happens). The second line creates a web page. The third line creates a div element (the general purpose HTML container element) named button_div . We will use it shortly to contain all the buttons. Notice that using a=wp we add button_div to the page. The fourth line defines the classes that will be used to format all the buttons. Don't worry if you don't understand what all the Tailwind classes do at this stage, it is not important. The fifth line creates the message element and adds it to the page. This element displays information about the button that is clicked. On the sixth line the loop that creates all the buttons starts. For each iteration of the loop, a button is created and added to button_div . Since button_div was previously added to the web page, the buttons will also be displayed on the page. A button in JustPy is just an instance of the Button class, and therefore we can assign additional attributes to the instance. That is what we do in the next two lines. We assign to the message attribute the message element and initialize the num_clicked attribute to 0 (these attributes will be used in the button_click function as we shall see shortly). After the loop, the web page is returned, and the framework renders it to the user's browser. It may seem that the loop is erasing previous buttons by redefining the variable b . That is not the case because each time through the loop a new button is created and is added to the component list of button_div (using the keyword argument notation: a=button_div ). At the end of the loop, button_div has 25 distinct child component instances. You can verify this by adding the following two lines just before the return statement of event_demo and re-running the program: print ( button_div ) print ( button_div . components ) The components attribute is a list that holds all the child component instances of the element in the order they will be rendered. It is named \"components\" because it holds the building blocks of the element (though strictly speaking, the list holds elements which are instances of components). Let's take a look now at button_click , the second function in our program. When any one of the buttons is clicked, this function is executed. The arguments for button_click are the same as those for all event handlers in JustPy. The first argument self , is the button. In JustPy, as previously discussed, elements on the page are represented by instances of Python classes. The buttons we created are instances of the Button class and therefore in this case self will be an instance of the Button class. In the first line of button_click we increment the instance attribute that tracks the number of times the specific button was clicked. It was initialized as 0 when we created the button in event_demo . The second line changes the text of the message box. Since we conveniently assigned the appropriate div element to the message attribute of all buttons, we know where to find it. It is right there as an attribute of self . Please skip this paragraph if you are not familiar with JavaScript: Contrast this with the JavaScript methods of getting elements by id or class or using some more complex DOM query. In most cases we don't need to query the Python representation of the DOM if we anticipate in advance which elements an event handler will require. The last two lines of button_click change the background of the button that was clicked to red and change the background of the button when it is hovered.","title":"Example 1"},{"location":"tutorial/handling_events/#example-2","text":"As the program is written now, once a button is clicked, its background will always be red, even if another button is clicked. If we want only the background of the last clicked button to be red, the event handler needs to set the background of all other buttons back to blue. There are many ways that this could be done but I would like to highlight a method that can be generalized to most cases. The web page itself is an instance of a Python class and therefore can have user specified attributes. We will create a list of all the buttons and assign it to the button_list attribute of the page. In the event handler we will loop over this list and change the backgrounds to blue after which we will set the background of the clicked button to red. Info We know which page's button_list we need to loop over because the page on which the event originated is always provided to the event handler in msg.page by JustPy. The result looks like this: import justpy as jp def button_click ( self , msg ): self . num_clicked += 1 self . message . text = f ' {self.text} clicked. Number of clicks: {self.num_clicked} ' for button in msg . page . button_list : button . set_class ( 'bg-blue-500' ) button . set_class ( 'bg-blue-700' , 'hover' ) self . set_class ( 'bg-red-500' ) self . set_class ( 'bg-red-700' , 'hover' ) def event_demo (): number_of_buttons = 25 wp = jp . WebPage () button_div = jp . Div ( classes = 'flex m-4 flex-wrap' , a = wp ) button_classes = 'w-32 mr-2 mb-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full' message = jp . P ( text = 'No button clicked yet' , classes = 'text-2xl border m-4 p-2' , a = wp ) button_list = [] for i in range ( 1 , number_of_buttons + 1 ): b = jp . Button ( text = f 'Button {i} ' , a = button_div , classes = button_classes , click = button_click ) b . message = message b . num_clicked = 0 button_list . append ( b ) wp . button_list = button_list # The list will now be referenced by the WebPage instance attribute return wp jp . justpy ( event_demo )","title":"Example 2"},{"location":"tutorial/handling_events/#example-3-event-changes-elements-on-page","text":"Events can also change the elements on the page itself, adding or removing them as necessary. As a concrete example let's change the program above to display a log of buttons that were clicked instead of just one line of information. import justpy as jp def button_click ( self , msg ): self . num_clicked += 1 # self.message.text = f'{self.text} clicked. Number of clicks: {self.num_clicked}' p = jp . P ( text = f ' {self.text} clicked. Number of clicks: {self.num_clicked} ' ) self . message . add_component ( p , 0 ) for button in msg . page . button_list : button . set_class ( 'bg-blue-500' ) button . set_class ( 'bg-blue-700' , 'hover' ) self . set_class ( 'bg-red-500' ) self . set_class ( 'bg-red-700' , 'hover' ) def event_demo (): number_of_buttons = 25 wp = jp . WebPage () button_div = jp . Div ( classes = 'flex m-4 flex-wrap' , a = wp ) button_classes = 'w-32 mr-2 mb-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full' message = jp . Div ( classes = 'text-lg border m-2 p-2 overflow-auto h-64' , a = wp ) message . add ( jp . P ( text = 'No button clicked yet' )) button_list = [] for i in range ( 1 , number_of_buttons + 1 ): b = jp . Button ( text = f 'Button {i} ' , a = button_div , classes = button_classes , click = button_click ) b . message = message b . num_clicked = 0 button_list . append ( b ) wp . button_list = button_list # The list will now be referenced by the WebPage instance attribute return wp jp . justpy ( event_demo ) Instead of just changing the text in message , button_click creates a p element with the text message and adds the element to message using the add_component method. It is different from add because it allows adding a component at any position. Here, we are adding the new log info at the beginning of the message div so that most recent messages show up first. Also, in event_demo we changed message to a div element and added the first message as a p element with text.","title":"Example 3 - Event changes elements on page"},{"location":"tutorial/handling_events/#inline-event-handlers","text":"In a very non-Pythonic manner, JustPy supports inserting inline functions as event handlers when creating an element. I confess to using these functions sometimes for event handlers that are just one or two lines of code. The function itself is represented as a string, not a real Python function. Statements are separated by the semicolon. The function assumes that the two arguments are self and msg . The namespace is that of the JustPy package. If you want the function to have access to a variable, assign it to an attribute of self . import justpy as jp def comp_test (): wp = jp . WebPage () d = jp . Div ( text = 'hello1' , click = 'self.text=\"clicked\"' , mouseenter = 'self.text=\"entered\"; self.set_class(\"text-5xl\"); msg.page.add(Div(text=f\"{len(msg.page)} Additional Div\"))' , mouseleave = 'self.text=\"left\"; self.set_class(\"text-xl\")' , classes = 'text-2xl border p-2 m-2' , a = wp ) d = jp . Div ( text = 'hello2' , click = 'self.text=\"clicked\"' , mouseenter = 'self.text=\"entered\"' , classes = 'text-2xl border p-2 m-2' , a = wp ) d = jp . Div ( text = 'hello3' , click = 'self.text=\"clicked\"' , mouseenter = 'self.text=\"entered\"' , classes = 'text-2xl border p-2 m-2' , a = wp ) return wp jp . justpy ( comp_test )","title":"Inline Event Handlers"},{"location":"tutorial/handling_events/#the-debounce-and-throttle-event-modifiers","text":"Sometimes you need to debounce or throttle on event. To do this, use the debounce and throttle keyword arguments of the on method. The value is the wait time in milliseconds. If you want the debounce to be leading edge, set the immediate attribute of on to True . The example below also uses the add_event method. The mousemove event is not among the events that are supported by default and needs to be added to the element's allowed events. import justpy as jp def mouse_event ( self , msg ): try : self . counter += 1 except : self . counter = 1 msg . page . info_div . add_first ( jp . Div ( text = f ' {self.counter} ) {msg.event_type} ' )) def debounce_test (): wp = jp . WebPage () d = jp . Div ( style = 'height: 100vh' , a = wp ) d . add_event ( 'mousemove' ) d . on ( 'mousemove' , mouse_event , throttle = 1000 ) d . on ( 'click' , mouse_event , debounce = 2000 , immediate = False ) wp . info_div = jp . Div ( text = 'Recent mouse events' , classes = 'm-4 text-lg' , a = d ) return wp jp . justpy ( debounce_test )","title":"The debounce and throttle Event Modifiers"},{"location":"tutorial/handling_events/#the-click__out-event","text":"The click__out event fires when there is a click outside of an element. This is useful for example in the case of dropdown list you would like closed when there is a click outside of the dropdown element. Info Notice the TWO underline characters in click__out . import justpy as jp def click_out ( self , msg ): self . text = 'click out' self . set_classes ( 'text-blue-500' ) def click_in ( self , msg ): self . text = 'click in' self . set_classes ( 'text-red-500' ) def test_out (): wp = jp . WebPage () for i in range ( 4 ): d = jp . Div ( text = f ' {i} ) Div' , a = wp , classes = 'm-4 p-4 text-xl border w-32' ) d . on ( 'click__out' , click_out ) d . on ( 'click' , click_in ) return wp jp . justpy ( test_out )","title":"The click__out Event"},{"location":"tutorial/handling_events/#event-handlers-defined-in-components","text":"This section reflects changes introduced in version 0.1.0 Note You may want to return to this section after having covered the custom components part of the tutorial In the example below we define a simple component that is a Div that includes 5 buttons and another Div with some information. If an event handler is defined as a method of a component, the self attribute passed to it will be that of the component instance and not of the child instance which originated the event. That child instance can be found in the msg.target field. import justpy as jp class ButtonDiv ( jp . Div ): def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) for i in range ( 1 , 6 ): b = jp . Button ( text = f 'Button {i} ' , a = self , classes = ' m-2 p-2 border text-blue text-lg' ) b . num = i b . on ( 'click' , self . button_clicked ) self . info_div = jp . Div ( text = 'info will go here' , classes = 'm-2 p-2 border' , a = self ) def button_clicked ( self , msg ): print ( self ) print ( msg . target ) self . info_div . text = f 'Button {msg.target.num} was clicked' def target_test (): wp = jp . WebPage () ButtonDiv ( a = wp ) return wp jp . justpy ( target_test )","title":"Event Handlers Defined in Components"},{"location":"tutorial/html_components/","text":"HTML Components \u00b6 JustPY supports components corresponding to HTML and SVG tags. The name of the component is the same as the name of the HTML tag with the first letter capitalized. For example, we already saw the Div and P components that correspond to the the div and p HTML tags. JustPy supports all tags that put elements on the page and are not deprecated in HTML 5. Here is a simple example with three HTML components. import justpy as jp def html_comps (): wp = jp . WebPage () jp . I ( text = 'Text in Italic' , a = wp ) jp . Br ( a = wp ) jp . Strong ( text = 'Text in the Strong element' , a = wp ) return wp jp . justpy ( html_comps ) The i HTML tag displays text typically in italics. The br HTML tag produces a line break. The strong HTML tag is typically rendered in bold type. The JustPy function get_tag , creates an instance of a component based on the HTML tag. Its first argument is a string with the tag and the rest of the arguments are the identical optional keyword arguments for the class __init__ method. The program below is equivalent to the one above: import justpy as jp def html_comps (): wp = jp . WebPage () jp . get_tag ( 'i' , text = 'Text in Italic' , a = wp ) jp . get_tag ( 'br' , a = wp ) jp . get_tag ( 'br' , a = wp ) jp . get_tag ( 'br' , a = wp ) jp . get_tag ( 'br' , a = wp ) jp . get_tag ( 'strong' , text = 'Text in the Strong element' , a = wp ) return wp jp . justpy ( html_comps ) It is also possible to get the same formatting using the the Div component with the appropriate Tailwind classes: import justpy as jp def html_comps (): wp = jp . WebPage () jp . Div ( text = 'Text in italic' , a = wp , classes = 'italic' ) jp . Div ( text = 'Text in bold' , a = wp , classes = 'font-bold' ) return wp jp . justpy ( html_comps ) If you do not need the semantic information the specialized tags provide, it is more convenient to use Div , P , or Span with the appropriate Tailwind classes or style attribute. Container Elements \u00b6 Many HTML elements can have children elements. In JustPy parlance, an element can contain other elements. import justpy as jp def html_comps (): wp = jp . WebPage () for i in range ( 10 ): d = jp . Div ( a = wp , classes = 'm-2' ) for j in range ( 10 ): jp . Span ( text = f 'Span #{j+1} in Div #{i+1}' , a = d , classes = 'text-white bg-blue-700 hover:bg-blue-200 ml-1 p-1' ) return wp jp . justpy ( html_comps ) In the program above, in each iteration of the outer loop a new Div element is created and in the inner loop, ten Span elements are added to it. This is done using the a=d keyword argument. Change the element created in the inner loop from a Span to a Div , P , or I and see what happens. Common Attributes \u00b6 HTML components have common attributes as well as specific ones. JustPy components support the following global attributes for all HTML components: contenteditable , dir , tabindex , title , accesskey , draggable , lang , hidden In this example we use the contenteditable , dir , and lang attributes: import justpy as jp def html_comps (): wp = jp . WebPage () for j in range ( 10 ): p = jp . P ( text = f '\u05d0\u05e0\u05d9 \u05d0\u05d5\u05d4\u05d1 \u05dc\u05ea\u05db\u05e0\u05ea \u05d1\u05e4\u05d9\u05d9\u05ea\u05d5\u05df' , a = wp , contenteditable = True , classes = 'text-white bg-blue-500 hover:bg-blue-700 ml-1 p-1 w-1/2' ) p . dir = 'rtl' p . lang = 'he' return wp jp . justpy ( html_comps ) The text in each P element is made editable by setting contenteditable to True (using a keyword argument). We set dir to \"rtl\" (right-to-left) and lang to \"he\" (the language code for Hebrew). We do so by setting the attribute directly though we could have used a keyword argument. Run the program and try editing some text. You will see also that the Hebrew text is rendered right to left. Specific Attributes \u00b6 Some components have specific attributes. For example, the img HTML tag has the src attribute that specifies the URL for the image. Run the following program: import justpy as jp def html_comps (): wp = jp . WebPage () for degree in range ( 0 , 361 , 10 ): image = jp . Img ( src = 'https://www.python.org/static/community_logos/python-powered-h-140x182.png' , a = wp ) image . classes = 'm-4 p-4 inline-block' image . style = f 'transform: rotate( {degree} deg)' image . height = 100 image . width = 100 image . degree = degree def straighten ( self , msg ): self . style = f 'transform: rotate(0deg)' def rotate_back ( self , msg ): self . style = f 'transform: rotate( {self.degree} deg)' def no_rotate ( self , msg ): self . degree = 0 self . set_class ( 'bg-red-200' ) image . on ( 'mouseenter' , straighten ) image . on ( 'mouseleave' , rotate_back ) image . on ( 'click' , no_rotate ) return wp jp . justpy ( html_comps ) The program renders on the page a progression of images of the Python Powered logo each rotated 10 degrees relative to the former image. When the mouse enters an image, it \"straightens\" and when it leaves, it returns to its original rotation. If you click on an image, it does not rotate anymore. The images are added inside a loop. In each iteration of the loop, an image is added to the page. The src attribute designates where to fetch the image from, in our case the python.org website. As you see in this example, you can combine Tailwind classes (or any CSS classes) with setting the style attribute. Here, the style is set to rotate the image based on the loop variable. We also set the height and width attributes of the image to 100. The program then sets the degree attribute of the image to the loop variable. It will be used in the event handlers that define the interaction with the mouse. Note degree is a different kind of attribute than src , height , and width . It is a user defined attribute that is not part of the HTML specification. In the JustPy component definitions, attributes that are part of the HTML specification are explicitly identified and handled accordingly. The mouse event handlers change the style and class attributes of the element as needed using the degree attribute of the image if required. For clarity, the event handlers are defined inside the loop, but they could be defined just once outside the loop or outside the request handler. We could also set the attributes as keyword arguments and the result is the following: import justpy as jp def straighten ( self , msg ): self . style = f 'transform: rotate(0deg)' def rotate_back ( self , msg ): self . style = f 'transform: rotate( {self.degree} deg)' def no_rotate ( self , msg ): self . degree = 0 self . set_class ( 'bg-red-200' ) def html_comps (): wp = jp . WebPage () for degree in range ( 0 , 361 , 10 ): jp . Img ( src = 'https://www.python.org/static/community_logos/python-powered-h-140x182.png' , a = wp , classes = 'm-4 p-4 inline-block' , style = f 'transform: rotate( {degree} deg)' , height = 100 , width = 100 , degree = degree , mouseenter = straighten , mouseleave = rotate_back , click = no_rotate ) return wp jp . justpy ( html_comps ) HTML Links \u00b6 In JustPy you create hyperlinks using the A component which corresponds to the a HTML tag . The A component is also named Link (in case you want to use a more descriptive name). import justpy as jp def link_demo (): wp = jp . WebPage () jp . A ( text = 'Python Org' , href = 'https://python.org' , a = wp , classes = 'm-2 p-2 text-xl text-white bg-blue-500 hover:bg-blue-700' ) return wp jp . justpy ( link_demo ) The link above goes to the Python.org web page. If you want the link to open in a new window, set the target attribute of the A component instance to '_blank' If you want to link to an element on the page, use the bookmark attribute and assign to it the element you want to link to. If you want to scroll to the element, instead of jumping instantly, set the scroll attribute to True . import justpy as jp def link_demo (): wp = jp . WebPage () link = jp . A ( text = 'Scroll to target' , a = wp , classes = 'inline-block m-2 p-2 text-xl text-white bg-blue-500 hover:bg-blue-700' ) # jp.Br(a=wp) for i in range ( 50 ): jp . P ( text = f '{i+1} Not a target' , classes = 'm-1 p-1 text-white bg-blue-300' , a = wp ) target = jp . A ( text = f 'This is the target - it is linked to first link, click to jump there' , classes = 'inline-block m-1 p-1 text-white bg-red-500' , a = wp ) link . bookmark = target link . scroll = True target . bookmark = link for i in range ( 50 ): jp . P ( text = f '{i+50} Not a target' , classes = 'm-1 p-1 text-white bg-blue-300' , a = wp ) return wp jp . justpy ( link_demo ) Lists \u00b6 The ul tag together with the li tag can be used to create lists. The corresponding JustPy components are Ul and Li . import justpy as jp def list_demo (): wp = jp . WebPage () my_list = jp . Ul ( a = wp , classes = 'm-2 p-2' ) for i in range ( 1 , 11 ): jp . Li ( text = f 'List one item {i} ' , a = my_list ) my_list = jp . Ul ( a = wp , classes = 'm-2 p-2 list-disc list-inside' ) for i in range ( 1 , 11 ): jp . Li ( text = f 'List two item {i} ' , a = my_list , classes = 'hover:bg-gray-200' ) my_list = jp . Ul ( a = wp , classes = 'm-2 p-2 list-decimal list-inside' ) for i in range ( 1 , 11 ): jp . Li ( text = f 'List three item {i} ' , a = my_list ) return wp jp . justpy ( list_demo ) The program above creates three lists. Use the list-disc and list-decimal Tailwind classes to get bulleted or numeric lists. The list-inside class controls the positions of the markers of the list. If you choose to put them outside, make sure there is enough room to render them. Showing and Hiding Elements \u00b6 All JustPy components use the show boolean attribute to determine whether an element should be rendered on the page. If show is False , the element will not be on the page at all. If you want the element to be on the page, but be invisible, use the visible and invisible Tailwind classes (or appropriate style values). When an element is invisible, the page structure stays the same. Run the following program and see the difference by clicking both buttons. import justpy as jp button_classes = 'm-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded' def show_demo (): wp = jp . WebPage () b = jp . Button ( text = 'Click to toggle show' , a = wp , classes = button_classes ) d = jp . Div ( text = 'Toggled by show' , classes = 'm-2 p-2 text-2xl border w-48' , a = wp ) b . d = d jp . Div ( text = 'Will always show' , classes = 'm-2' , a = wp ) def toggle_show ( self , msg ): self . d . show = not self . d . show b . on ( 'click' , toggle_show ) b = jp . Button ( text = 'Click to toggle visibility' , a = wp , classes = button_classes ) d = jp . Div ( text = 'Toggled by visible' , classes = 'm-2 p-2 text-2xl border w-48' , a = wp ) d . visibility_state = 'visible' b . d = d jp . Div ( text = 'Will always show' , classes = 'm-2' , a = wp ) def toggle_visible ( self , msg ): if self . d . visibility_state == 'visible' : self . d . set_class ( 'invisible' ) self . d . visibility_state = 'invisible' else : self . d . set_class ( 'visible' ) self . d . visibility_state = 'visible' b . on ( 'click' , toggle_visible ) return wp jp . justpy ( show_demo )","title":"HTML Components"},{"location":"tutorial/html_components/#html-components","text":"JustPY supports components corresponding to HTML and SVG tags. The name of the component is the same as the name of the HTML tag with the first letter capitalized. For example, we already saw the Div and P components that correspond to the the div and p HTML tags. JustPy supports all tags that put elements on the page and are not deprecated in HTML 5. Here is a simple example with three HTML components. import justpy as jp def html_comps (): wp = jp . WebPage () jp . I ( text = 'Text in Italic' , a = wp ) jp . Br ( a = wp ) jp . Strong ( text = 'Text in the Strong element' , a = wp ) return wp jp . justpy ( html_comps ) The i HTML tag displays text typically in italics. The br HTML tag produces a line break. The strong HTML tag is typically rendered in bold type. The JustPy function get_tag , creates an instance of a component based on the HTML tag. Its first argument is a string with the tag and the rest of the arguments are the identical optional keyword arguments for the class __init__ method. The program below is equivalent to the one above: import justpy as jp def html_comps (): wp = jp . WebPage () jp . get_tag ( 'i' , text = 'Text in Italic' , a = wp ) jp . get_tag ( 'br' , a = wp ) jp . get_tag ( 'br' , a = wp ) jp . get_tag ( 'br' , a = wp ) jp . get_tag ( 'br' , a = wp ) jp . get_tag ( 'strong' , text = 'Text in the Strong element' , a = wp ) return wp jp . justpy ( html_comps ) It is also possible to get the same formatting using the the Div component with the appropriate Tailwind classes: import justpy as jp def html_comps (): wp = jp . WebPage () jp . Div ( text = 'Text in italic' , a = wp , classes = 'italic' ) jp . Div ( text = 'Text in bold' , a = wp , classes = 'font-bold' ) return wp jp . justpy ( html_comps ) If you do not need the semantic information the specialized tags provide, it is more convenient to use Div , P , or Span with the appropriate Tailwind classes or style attribute.","title":"HTML Components"},{"location":"tutorial/html_components/#container-elements","text":"Many HTML elements can have children elements. In JustPy parlance, an element can contain other elements. import justpy as jp def html_comps (): wp = jp . WebPage () for i in range ( 10 ): d = jp . Div ( a = wp , classes = 'm-2' ) for j in range ( 10 ): jp . Span ( text = f 'Span #{j+1} in Div #{i+1}' , a = d , classes = 'text-white bg-blue-700 hover:bg-blue-200 ml-1 p-1' ) return wp jp . justpy ( html_comps ) In the program above, in each iteration of the outer loop a new Div element is created and in the inner loop, ten Span elements are added to it. This is done using the a=d keyword argument. Change the element created in the inner loop from a Span to a Div , P , or I and see what happens.","title":"Container Elements"},{"location":"tutorial/html_components/#common-attributes","text":"HTML components have common attributes as well as specific ones. JustPy components support the following global attributes for all HTML components: contenteditable , dir , tabindex , title , accesskey , draggable , lang , hidden In this example we use the contenteditable , dir , and lang attributes: import justpy as jp def html_comps (): wp = jp . WebPage () for j in range ( 10 ): p = jp . P ( text = f '\u05d0\u05e0\u05d9 \u05d0\u05d5\u05d4\u05d1 \u05dc\u05ea\u05db\u05e0\u05ea \u05d1\u05e4\u05d9\u05d9\u05ea\u05d5\u05df' , a = wp , contenteditable = True , classes = 'text-white bg-blue-500 hover:bg-blue-700 ml-1 p-1 w-1/2' ) p . dir = 'rtl' p . lang = 'he' return wp jp . justpy ( html_comps ) The text in each P element is made editable by setting contenteditable to True (using a keyword argument). We set dir to \"rtl\" (right-to-left) and lang to \"he\" (the language code for Hebrew). We do so by setting the attribute directly though we could have used a keyword argument. Run the program and try editing some text. You will see also that the Hebrew text is rendered right to left.","title":"Common Attributes"},{"location":"tutorial/html_components/#specific-attributes","text":"Some components have specific attributes. For example, the img HTML tag has the src attribute that specifies the URL for the image. Run the following program: import justpy as jp def html_comps (): wp = jp . WebPage () for degree in range ( 0 , 361 , 10 ): image = jp . Img ( src = 'https://www.python.org/static/community_logos/python-powered-h-140x182.png' , a = wp ) image . classes = 'm-4 p-4 inline-block' image . style = f 'transform: rotate( {degree} deg)' image . height = 100 image . width = 100 image . degree = degree def straighten ( self , msg ): self . style = f 'transform: rotate(0deg)' def rotate_back ( self , msg ): self . style = f 'transform: rotate( {self.degree} deg)' def no_rotate ( self , msg ): self . degree = 0 self . set_class ( 'bg-red-200' ) image . on ( 'mouseenter' , straighten ) image . on ( 'mouseleave' , rotate_back ) image . on ( 'click' , no_rotate ) return wp jp . justpy ( html_comps ) The program renders on the page a progression of images of the Python Powered logo each rotated 10 degrees relative to the former image. When the mouse enters an image, it \"straightens\" and when it leaves, it returns to its original rotation. If you click on an image, it does not rotate anymore. The images are added inside a loop. In each iteration of the loop, an image is added to the page. The src attribute designates where to fetch the image from, in our case the python.org website. As you see in this example, you can combine Tailwind classes (or any CSS classes) with setting the style attribute. Here, the style is set to rotate the image based on the loop variable. We also set the height and width attributes of the image to 100. The program then sets the degree attribute of the image to the loop variable. It will be used in the event handlers that define the interaction with the mouse. Note degree is a different kind of attribute than src , height , and width . It is a user defined attribute that is not part of the HTML specification. In the JustPy component definitions, attributes that are part of the HTML specification are explicitly identified and handled accordingly. The mouse event handlers change the style and class attributes of the element as needed using the degree attribute of the image if required. For clarity, the event handlers are defined inside the loop, but they could be defined just once outside the loop or outside the request handler. We could also set the attributes as keyword arguments and the result is the following: import justpy as jp def straighten ( self , msg ): self . style = f 'transform: rotate(0deg)' def rotate_back ( self , msg ): self . style = f 'transform: rotate( {self.degree} deg)' def no_rotate ( self , msg ): self . degree = 0 self . set_class ( 'bg-red-200' ) def html_comps (): wp = jp . WebPage () for degree in range ( 0 , 361 , 10 ): jp . Img ( src = 'https://www.python.org/static/community_logos/python-powered-h-140x182.png' , a = wp , classes = 'm-4 p-4 inline-block' , style = f 'transform: rotate( {degree} deg)' , height = 100 , width = 100 , degree = degree , mouseenter = straighten , mouseleave = rotate_back , click = no_rotate ) return wp jp . justpy ( html_comps )","title":"Specific Attributes"},{"location":"tutorial/html_components/#html-links","text":"In JustPy you create hyperlinks using the A component which corresponds to the a HTML tag . The A component is also named Link (in case you want to use a more descriptive name). import justpy as jp def link_demo (): wp = jp . WebPage () jp . A ( text = 'Python Org' , href = 'https://python.org' , a = wp , classes = 'm-2 p-2 text-xl text-white bg-blue-500 hover:bg-blue-700' ) return wp jp . justpy ( link_demo ) The link above goes to the Python.org web page. If you want the link to open in a new window, set the target attribute of the A component instance to '_blank' If you want to link to an element on the page, use the bookmark attribute and assign to it the element you want to link to. If you want to scroll to the element, instead of jumping instantly, set the scroll attribute to True . import justpy as jp def link_demo (): wp = jp . WebPage () link = jp . A ( text = 'Scroll to target' , a = wp , classes = 'inline-block m-2 p-2 text-xl text-white bg-blue-500 hover:bg-blue-700' ) # jp.Br(a=wp) for i in range ( 50 ): jp . P ( text = f '{i+1} Not a target' , classes = 'm-1 p-1 text-white bg-blue-300' , a = wp ) target = jp . A ( text = f 'This is the target - it is linked to first link, click to jump there' , classes = 'inline-block m-1 p-1 text-white bg-red-500' , a = wp ) link . bookmark = target link . scroll = True target . bookmark = link for i in range ( 50 ): jp . P ( text = f '{i+50} Not a target' , classes = 'm-1 p-1 text-white bg-blue-300' , a = wp ) return wp jp . justpy ( link_demo )","title":"HTML Links"},{"location":"tutorial/html_components/#lists","text":"The ul tag together with the li tag can be used to create lists. The corresponding JustPy components are Ul and Li . import justpy as jp def list_demo (): wp = jp . WebPage () my_list = jp . Ul ( a = wp , classes = 'm-2 p-2' ) for i in range ( 1 , 11 ): jp . Li ( text = f 'List one item {i} ' , a = my_list ) my_list = jp . Ul ( a = wp , classes = 'm-2 p-2 list-disc list-inside' ) for i in range ( 1 , 11 ): jp . Li ( text = f 'List two item {i} ' , a = my_list , classes = 'hover:bg-gray-200' ) my_list = jp . Ul ( a = wp , classes = 'm-2 p-2 list-decimal list-inside' ) for i in range ( 1 , 11 ): jp . Li ( text = f 'List three item {i} ' , a = my_list ) return wp jp . justpy ( list_demo ) The program above creates three lists. Use the list-disc and list-decimal Tailwind classes to get bulleted or numeric lists. The list-inside class controls the positions of the markers of the list. If you choose to put them outside, make sure there is enough room to render them.","title":"Lists"},{"location":"tutorial/html_components/#showing-and-hiding-elements","text":"All JustPy components use the show boolean attribute to determine whether an element should be rendered on the page. If show is False , the element will not be on the page at all. If you want the element to be on the page, but be invisible, use the visible and invisible Tailwind classes (or appropriate style values). When an element is invisible, the page structure stays the same. Run the following program and see the difference by clicking both buttons. import justpy as jp button_classes = 'm-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded' def show_demo (): wp = jp . WebPage () b = jp . Button ( text = 'Click to toggle show' , a = wp , classes = button_classes ) d = jp . Div ( text = 'Toggled by show' , classes = 'm-2 p-2 text-2xl border w-48' , a = wp ) b . d = d jp . Div ( text = 'Will always show' , classes = 'm-2' , a = wp ) def toggle_show ( self , msg ): self . d . show = not self . d . show b . on ( 'click' , toggle_show ) b = jp . Button ( text = 'Click to toggle visibility' , a = wp , classes = button_classes ) d = jp . Div ( text = 'Toggled by visible' , classes = 'm-2 p-2 text-2xl border w-48' , a = wp ) d . visibility_state = 'visible' b . d = d jp . Div ( text = 'Will always show' , classes = 'm-2' , a = wp ) def toggle_visible ( self , msg ): if self . d . visibility_state == 'visible' : self . d . set_class ( 'invisible' ) self . d . visibility_state = 'invisible' else : self . d . set_class ( 'visible' ) self . d . visibility_state = 'visible' b . on ( 'click' , toggle_visible ) return wp jp . justpy ( show_demo )","title":"Showing and Hiding Elements"},{"location":"tutorial/input/","text":"Input Component \u00b6 Basic Use \u00b6 Many web applications require users to fill forms. HTML forms are based on the input HTML tag . The corresponding JustPy component is Input . The following program adds a text input field to a page: import justpy as jp input_classes = \"m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" async def input_demo ( request ): wp = jp . WebPage () in1 = jp . Input ( a = wp , classes = input_classes , placeholder = 'Please type here' ) return wp jp . justpy ( input_demo ) The input Event \u00b6 The program above is quite boring, it does nothing except allow you to type text into the input field. To make it more interesting, let's have what we type reflected in a paragraph on the page. For this, we need to introduce the input event. When you type, each character typed into the input field generates an input event (yes, the tag and the event are called the same name). Run the following program: import justpy as jp input_classes = \"m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" p_classes = 'm-2 p-2 h-32 text-xl border-2' async def my_input ( self , msg ): self . div . text = self . value async def input_demo ( request ): wp = jp . WebPage () in1 = jp . Input ( a = wp , classes = input_classes , placeholder = 'Please type here' ) in1 . div = jp . Div ( text = 'What you type will show up here' , classes = p_classes , a = wp ) in1 . on ( 'input' , my_input ) return wp jp . justpy ( input_demo ) The function input_demo creates a web page and adds an input element called in1 to it (ignore the classes, they are there just to make the input element look nicer and do not affect the functionality of the program). Notice the placeholder attribute of in1 . Before any text is typed into the input field or when it is emptied, the placeholder text is displayed in the field. We then define a div element that is added to the page (using the a keyword argument) and assigned to an attribute of in1 . We saw this technique before. It simplifies event handling as we shall see in a second. Next, we bind the input event of in1 to the function my_input (we could have omitted this line by adding input=my_input as a keyword argument when we created in1 ). my_input is now the input event handler for in1 . The input event occurs each and every time a character is typed into an input element. After every keystroke this function is run (if the debounce period has expired - see below), and it changes the text of the div to the value of the input field. By assigning the div to an in1 attribute, we have access to all the variables we need in the event handler. You may have noticed that there is a delay in the updating of the Div. That is because the component by default sets the debounce attribute of the input event to 200ms. This means an input event is generated only after a key has not been pressed for 200ms. Try holding the a key down and have it repeated. Only when you lift your finger will the Div update. You can set the debounce attribute to the value you prefer in ms, just make sure to take into account the typing speed of your users and the latency of the connection. In general, a higher debounce value means the server will have to handle less communications and that may be an advantage for applications that need to scale. The change Event and the InputOnlyChange Component \u00b6 The regular Input component generates an event each time a character is typed into the field. In some case this is not necessary and may put unwanted burden on the server. If you are not implementing a look ahead or validating the field as the user is typing, it is preferable to use InputOnlyChange instead of Input. InputOnlyChange does not generate the input event, only the change event. The change event is generated when the field loses focus or the user presses the Enter button. It is not generated when the user types a character. The example below is the same as the one above except that InputOnlyChange is used instead of Input. import justpy as jp input_classes = \"m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" p_classes = 'm-2 p-2 h-32 text-xl border-2' def my_input(self, msg): self.div.text = self.value def input_demo(request): wp = jp.WebPage() in1 = jp.InputChangeOnly(a=wp, classes=input_classes, placeholder='Please type here') in1.div = jp.Div(text='What you type will show up here only when Input element loses focus or you press Enter', classes=p_classes, a=wp) in1.on('input', my_input) in1.on('change', my_input) return wp jp.justpy(input_demo) The Type Attribute \u00b6 Number Example \u00b6 The input component can be of different types such as 'number' or 'password'. import justpy as jp input_classes = \"m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" p_classes = 'm-2 p-2 h-32 text-xl border-2' async def my_input ( self , msg ): self . div . text = self . value async def input_demo ( request ): wp = jp . WebPage () in1 = jp . Input ( type = 'number' , a = wp , classes = input_classes , placeholder = 'Please type here' ) in1 . div = jp . Div ( text = 'What you type will show up here' , classes = p_classes , a = wp ) in1 . on ( 'input' , my_input ) return wp jp . justpy ( input_demo ) In the example above the type of in1 is set to 'number'. Run the program and verify that only numbers can be input into the element. Color Example \u00b6 The Input component also allows you to choose colors. import justpy as jp def color_demo ( request ): wp = jp . WebPage () in1 = jp . Input ( type = 'color' , a = wp , classes = 'm-2 p-2' , style = 'width: 100px; height: 100px' , input = color_change , debounce = 30 ) in1 . d = jp . Div ( text = 'Click box above to change color of this text' , a = wp , classes = 'border m-2 p-2 text-2xl font-bold' ) return wp def color_change ( self , msg ): self . d . style = f 'color: {self.value} ' self . d . text = f 'The color of this text is: {self.value} ' jp . justpy ( color_demo ) Radio Button Example \u00b6 In the example below we create two sets of radio buttons . Later in the tutorial we will see how to create a component for radio buttons which is a more intuitive way to use them. Tip If you plan to use Quasar with JustPy, checkout the QOptionGroup component import justpy as jp def radio_test (): wp = jp . WebPage () genders = [ 'male' , 'female' , 'other' ] ages = [( 0 , 30 ), ( 31 , 60 ), ( 61 , 100 )] outer_div = jp . Div ( classes = 'border m-2 p-2 w-64' , a = wp ) jp . P ( a = outer_div , text = 'Please select your gender:' ) for gender in genders : label = jp . Label ( classes = 'inline-block mb-1 p-1' , a = outer_div ) radio_btn = jp . Input ( type = 'radio' , name = 'gender' , value = gender , a = label ) jp . Span ( classes = 'ml-1' , a = label , text = gender . capitalize ()) jp . Div ( a = outer_div , classes = 'm-2' ) # Add spacing and line break jp . P ( a = outer_div , text = 'Please select your age:' ) for age in ages : label = jp . Label ( classes = 'inline-block mb-1 p-1' , a = outer_div ) radio_btn = jp . Input ( type = 'radio' , name = 'age' , value = age [ 0 ], a = label ) jp . Span ( classes = 'ml-1' , a = label , text = f ' {age[0]} - {age[1]} ' ) jp . Br ( a = outer_div ) return wp jp . justpy ( radio_test ) Radio buttons generate the 'change' event on all browsers. They generate the 'input' event just on some. When one is checked the 'change' event is generated. When one radio button is checked, JustPy automatically un-checks the other radio buttons in the group. Radio buttons are grouped according to their name attribute and the value of their form attribute if one is assigned. Buttons with the same name on different assigned forms, will be in different groups. All radio buttons not in any form but with the same name, will be in one group. Note You explicitly need to specify the form the buttons are on using the form attribute if you want to give button groups in different forms the same name. This is because JustPy does not know which form the button will be added to or has been added to. Alternatively, just have a unique name for each button group on the page. In the example below, the results of clicking a radio button are shown using the event handler radio_changed . Notice that the value of the radio button is always the same. What changes is its checked property. The value of a group of radio buttons is the value of the radio button in the group that is checked. To make all the radio buttons in the group available to the event handler, when we create them, we also create a list that holds all the radio buttons in the group. We assign this list to an attribute of each radio button element (in our case btn_list ). In the event handler we iterate over this list to report which radio button is pressed. import justpy as jp def radio_changed ( self , msg ): self . result_div . text = '' d = jp . Div ( a = self . result_div , classes = 'm-2 p-2 border' ) for btn in self . btn_list : if btn . checked : jp . Span ( text = f ' {btn.value} is checked' , a = d , classes = 'text-green-500 mr-6' ) else : jp . Span ( text = f ' {btn.value} is NOT checked' , a = d , classes = 'text-red-500 mr-6' ) def radio_test (): wp = jp . WebPage () genders = [ 'male' , 'female' , 'other' ] ages = [( 0 , 30 ), ( 31 , 60 ), ( 61 , 100 )] outer_div = jp . Div ( classes = 'border m-2 p-2 w-64' , a = wp ) # Create div to show radio button selection but don't add yet to page. It will be added at the end # It is created here so that it could be assigned to the radio button attribute result_div result_div = jp . Div ( text = 'Click radio buttons to see results here' , classes = 'm-2 p-2 text-xl' ) jp . P ( a = outer_div , text = 'Please select your gender:' ) gender_list = [] for gender in genders : label = jp . Label ( classes = 'inline-block mb-1 p-1' , a = outer_div ) radio_btn = jp . Input ( type = 'radio' , name = 'gender' , value = gender , a = label , btn_list = gender_list , result_div = result_div , change = radio_changed ) gender_list . append ( radio_btn ) jp . Span ( classes = 'ml-1' , a = label , text = gender . capitalize ()) jp . Div ( a = outer_div , classes = 'm-2' ) # Add spacing and line break jp . P ( a = outer_div , text = 'Please select your age:' ) age_list = [] for age in ages : label = jp . Label ( classes = 'inline-block mb-1 p-1' , a = outer_div ) radio_btn = jp . Input ( type = 'radio' , name = 'age' , value = age [ 0 ], a = label , btn_list = age_list , result_div = result_div , change = radio_changed ) age_list . append ( radio_btn ) jp . Span ( classes = 'ml-1' , a = label , text = f ' {age[0]} - {age[1]} ' ) jp . Br ( a = outer_div ) wp . add ( result_div ) return wp jp . justpy ( radio_test ) Checkbox Example \u00b6 Below is an example of a checkbox and a textbox connected using the model attribute (you may skip this for now and return to this example after completing the chapter describing the model attribute in this tutorial). import justpy as jp def check_test (): wp = jp . WebPage ( data = { 'checked' : True }) label = jp . Label ( a = wp , classes = 'm-2 p-2 inline-block' ) c = jp . Input ( type = 'checkbox' , classes = 'm-2 p-2 form-checkbox' , a = label , model = [ wp , 'checked' ]) caption = jp . Span ( text = 'Click to get stuff' , a = label ) in1 = jp . Input ( model = [ wp , 'checked' ], a = wp , classes = 'border block m-2 p-2' ) return wp jp . justpy ( check_test ) See what happens when you clear the text input element. Changing Focus using Keyboard Events \u00b6 In the example below, Input elements respond to the Esc and Enter keys. When Esc is pressed, the field value is set to the empty string. When Enter is pressed, focus moves to the next field down unless it is the last field in which case focus is moved to the first. To make the example work, an event handler for the 'blur' event is required. When one of the input elements loses focus, the blur event occurs and the focus field of the element is set to false so that the correct element will have focus. By setting the set_focus attribute of an element to True , you transfer the focus to it. If the attribute is True for multiple elements on the page, the results are unpredictable and therefore the blur event handler is required to make sure the attribute is True for only one element. import justpy as jp def my_blur ( self , msg ): self . set_focus = False def key_down ( self , msg ): # print(msg.key_data) key = msg . key_data . key if key == 'Escape' : self . value = '' return if key == 'Enter' : self . set_focus = False try : next_to_focus = self . input_list [ self . num + 1 ] except : next_to_focus = self . input_list [ 0 ] next_to_focus . set_focus = True return return True # Don't update the page def focus_test (): wp = jp . WebPage () d = jp . Div ( classes = 'flex flex-col m-2' , a = wp , style = 'width: 600 px' ) input_list = [] number_of_fields = 5 for i in range ( 1 , number_of_fields + 1 ): label = jp . Label ( a = d , classes = 'm-2 p-2' ) jp . Span ( text = f 'Field {i} ' , a = label ) in1 = jp . Input ( classes = jp . Styles . input_classes , placeholder = f ' {i} Type here' , a = label , keydown = key_down , spellcheck = \"false\" ) in1 . on ( 'blur' , my_blur ) in1 . input_list = input_list in1 . num = i - 1 input_list . append ( in1 ) return wp jp . justpy ( focus_test ) As a rule of thumb, try to limit the usage of keyboard events to a minimum since they don't work well for mobile users. Using Select \u00b6 The select tag needs to be used together with the option tag. In JustPy these correspond to Select and Option elements. The program below creates a select element whose value changes the background color of a Div. import justpy as jp def change_color ( self , msg ): self . color_div . set_class ( f 'bg- {self.value} -600' ) def comp_test (): wp = jp . WebPage () colors = [ 'red' , 'green' , 'blue' , 'pink' , 'yellow' , 'teal' , 'purple' ] select = jp . Select ( classes = 'w-32 text-xl m-4 p-2 bg-white border rounded' , a = wp , value = 'red' , change = change_color ) for color in colors : select . add ( jp . Option ( value = color , text = color , classes = f 'bg- {color} -600' )) select . color_div = jp . Div ( classes = 'bg-red-600 w-32 h-16 m-4' , a = wp ) return wp jp . justpy ( comp_test ) Your First Component \u00b6 JustPy allows building your own reusable components. We will have a lot more to say about this later, but just to start easing into the subject, let's suppose we want to encapsulate the functionality of an Input coupled to a Div into one component (like in one of the first examples above). The program would look like this: import justpy as jp class InputWithDiv ( jp . Div ): input_classes = \"m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" @staticmethod def input_handler ( self , msg ): self . div . text = self . value def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . in1 = jp . Input ( a = self , classes = self . input_classes , placeholder = 'Please type here' , input = self . input_handler ) self . in1 . div = jp . Div ( text = 'What you type will show up here' , classes = 'm-2 p-2 h-32 text-xl border-2' , a = self ) def input_demo ( request ): wp = jp . WebPage () for i in range ( 10 ): InputWithDiv ( a = wp ) return wp jp . justpy ( input_demo ) Try running the program. It will put on the page 10 pairs of input and div elements. If you type into the respective input field, the text will show up in the respective div. JustPy components are Python classes that inherit from JustPy classes. In the example above, we define the class InputWithDiv which inherits from the JustPy class Div . In the __init__ method an input element and another div is added to the basic div, with the appropriate functionality. Now, we have a component, InputWithDiv , that we can reuse as we please in any project. If you don't completely understand what is going on, don't worry. We will revisit this in much more detail later. The take home message at this stage is that the way you build complex applications in JustPy is by building components with isolated functionality. Hopefully, if JustPy gains popularity, there will be many components that the community will develop and share.","title":"Input Component"},{"location":"tutorial/input/#input-component","text":"","title":"Input Component"},{"location":"tutorial/input/#basic-use","text":"Many web applications require users to fill forms. HTML forms are based on the input HTML tag . The corresponding JustPy component is Input . The following program adds a text input field to a page: import justpy as jp input_classes = \"m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" async def input_demo ( request ): wp = jp . WebPage () in1 = jp . Input ( a = wp , classes = input_classes , placeholder = 'Please type here' ) return wp jp . justpy ( input_demo )","title":"Basic Use"},{"location":"tutorial/input/#the-input-event","text":"The program above is quite boring, it does nothing except allow you to type text into the input field. To make it more interesting, let's have what we type reflected in a paragraph on the page. For this, we need to introduce the input event. When you type, each character typed into the input field generates an input event (yes, the tag and the event are called the same name). Run the following program: import justpy as jp input_classes = \"m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" p_classes = 'm-2 p-2 h-32 text-xl border-2' async def my_input ( self , msg ): self . div . text = self . value async def input_demo ( request ): wp = jp . WebPage () in1 = jp . Input ( a = wp , classes = input_classes , placeholder = 'Please type here' ) in1 . div = jp . Div ( text = 'What you type will show up here' , classes = p_classes , a = wp ) in1 . on ( 'input' , my_input ) return wp jp . justpy ( input_demo ) The function input_demo creates a web page and adds an input element called in1 to it (ignore the classes, they are there just to make the input element look nicer and do not affect the functionality of the program). Notice the placeholder attribute of in1 . Before any text is typed into the input field or when it is emptied, the placeholder text is displayed in the field. We then define a div element that is added to the page (using the a keyword argument) and assigned to an attribute of in1 . We saw this technique before. It simplifies event handling as we shall see in a second. Next, we bind the input event of in1 to the function my_input (we could have omitted this line by adding input=my_input as a keyword argument when we created in1 ). my_input is now the input event handler for in1 . The input event occurs each and every time a character is typed into an input element. After every keystroke this function is run (if the debounce period has expired - see below), and it changes the text of the div to the value of the input field. By assigning the div to an in1 attribute, we have access to all the variables we need in the event handler. You may have noticed that there is a delay in the updating of the Div. That is because the component by default sets the debounce attribute of the input event to 200ms. This means an input event is generated only after a key has not been pressed for 200ms. Try holding the a key down and have it repeated. Only when you lift your finger will the Div update. You can set the debounce attribute to the value you prefer in ms, just make sure to take into account the typing speed of your users and the latency of the connection. In general, a higher debounce value means the server will have to handle less communications and that may be an advantage for applications that need to scale.","title":"The input Event"},{"location":"tutorial/input/#the-change-event-and-the-inputonlychange-component","text":"The regular Input component generates an event each time a character is typed into the field. In some case this is not necessary and may put unwanted burden on the server. If you are not implementing a look ahead or validating the field as the user is typing, it is preferable to use InputOnlyChange instead of Input. InputOnlyChange does not generate the input event, only the change event. The change event is generated when the field loses focus or the user presses the Enter button. It is not generated when the user types a character. The example below is the same as the one above except that InputOnlyChange is used instead of Input. import justpy as jp input_classes = \"m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" p_classes = 'm-2 p-2 h-32 text-xl border-2' def my_input(self, msg): self.div.text = self.value def input_demo(request): wp = jp.WebPage() in1 = jp.InputChangeOnly(a=wp, classes=input_classes, placeholder='Please type here') in1.div = jp.Div(text='What you type will show up here only when Input element loses focus or you press Enter', classes=p_classes, a=wp) in1.on('input', my_input) in1.on('change', my_input) return wp jp.justpy(input_demo)","title":"The change Event and the InputOnlyChange Component"},{"location":"tutorial/input/#the-type-attribute","text":"","title":"The Type Attribute"},{"location":"tutorial/input/#number-example","text":"The input component can be of different types such as 'number' or 'password'. import justpy as jp input_classes = \"m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" p_classes = 'm-2 p-2 h-32 text-xl border-2' async def my_input ( self , msg ): self . div . text = self . value async def input_demo ( request ): wp = jp . WebPage () in1 = jp . Input ( type = 'number' , a = wp , classes = input_classes , placeholder = 'Please type here' ) in1 . div = jp . Div ( text = 'What you type will show up here' , classes = p_classes , a = wp ) in1 . on ( 'input' , my_input ) return wp jp . justpy ( input_demo ) In the example above the type of in1 is set to 'number'. Run the program and verify that only numbers can be input into the element.","title":"Number Example"},{"location":"tutorial/input/#color-example","text":"The Input component also allows you to choose colors. import justpy as jp def color_demo ( request ): wp = jp . WebPage () in1 = jp . Input ( type = 'color' , a = wp , classes = 'm-2 p-2' , style = 'width: 100px; height: 100px' , input = color_change , debounce = 30 ) in1 . d = jp . Div ( text = 'Click box above to change color of this text' , a = wp , classes = 'border m-2 p-2 text-2xl font-bold' ) return wp def color_change ( self , msg ): self . d . style = f 'color: {self.value} ' self . d . text = f 'The color of this text is: {self.value} ' jp . justpy ( color_demo )","title":"Color Example"},{"location":"tutorial/input/#radio-button-example","text":"In the example below we create two sets of radio buttons . Later in the tutorial we will see how to create a component for radio buttons which is a more intuitive way to use them. Tip If you plan to use Quasar with JustPy, checkout the QOptionGroup component import justpy as jp def radio_test (): wp = jp . WebPage () genders = [ 'male' , 'female' , 'other' ] ages = [( 0 , 30 ), ( 31 , 60 ), ( 61 , 100 )] outer_div = jp . Div ( classes = 'border m-2 p-2 w-64' , a = wp ) jp . P ( a = outer_div , text = 'Please select your gender:' ) for gender in genders : label = jp . Label ( classes = 'inline-block mb-1 p-1' , a = outer_div ) radio_btn = jp . Input ( type = 'radio' , name = 'gender' , value = gender , a = label ) jp . Span ( classes = 'ml-1' , a = label , text = gender . capitalize ()) jp . Div ( a = outer_div , classes = 'm-2' ) # Add spacing and line break jp . P ( a = outer_div , text = 'Please select your age:' ) for age in ages : label = jp . Label ( classes = 'inline-block mb-1 p-1' , a = outer_div ) radio_btn = jp . Input ( type = 'radio' , name = 'age' , value = age [ 0 ], a = label ) jp . Span ( classes = 'ml-1' , a = label , text = f ' {age[0]} - {age[1]} ' ) jp . Br ( a = outer_div ) return wp jp . justpy ( radio_test ) Radio buttons generate the 'change' event on all browsers. They generate the 'input' event just on some. When one is checked the 'change' event is generated. When one radio button is checked, JustPy automatically un-checks the other radio buttons in the group. Radio buttons are grouped according to their name attribute and the value of their form attribute if one is assigned. Buttons with the same name on different assigned forms, will be in different groups. All radio buttons not in any form but with the same name, will be in one group. Note You explicitly need to specify the form the buttons are on using the form attribute if you want to give button groups in different forms the same name. This is because JustPy does not know which form the button will be added to or has been added to. Alternatively, just have a unique name for each button group on the page. In the example below, the results of clicking a radio button are shown using the event handler radio_changed . Notice that the value of the radio button is always the same. What changes is its checked property. The value of a group of radio buttons is the value of the radio button in the group that is checked. To make all the radio buttons in the group available to the event handler, when we create them, we also create a list that holds all the radio buttons in the group. We assign this list to an attribute of each radio button element (in our case btn_list ). In the event handler we iterate over this list to report which radio button is pressed. import justpy as jp def radio_changed ( self , msg ): self . result_div . text = '' d = jp . Div ( a = self . result_div , classes = 'm-2 p-2 border' ) for btn in self . btn_list : if btn . checked : jp . Span ( text = f ' {btn.value} is checked' , a = d , classes = 'text-green-500 mr-6' ) else : jp . Span ( text = f ' {btn.value} is NOT checked' , a = d , classes = 'text-red-500 mr-6' ) def radio_test (): wp = jp . WebPage () genders = [ 'male' , 'female' , 'other' ] ages = [( 0 , 30 ), ( 31 , 60 ), ( 61 , 100 )] outer_div = jp . Div ( classes = 'border m-2 p-2 w-64' , a = wp ) # Create div to show radio button selection but don't add yet to page. It will be added at the end # It is created here so that it could be assigned to the radio button attribute result_div result_div = jp . Div ( text = 'Click radio buttons to see results here' , classes = 'm-2 p-2 text-xl' ) jp . P ( a = outer_div , text = 'Please select your gender:' ) gender_list = [] for gender in genders : label = jp . Label ( classes = 'inline-block mb-1 p-1' , a = outer_div ) radio_btn = jp . Input ( type = 'radio' , name = 'gender' , value = gender , a = label , btn_list = gender_list , result_div = result_div , change = radio_changed ) gender_list . append ( radio_btn ) jp . Span ( classes = 'ml-1' , a = label , text = gender . capitalize ()) jp . Div ( a = outer_div , classes = 'm-2' ) # Add spacing and line break jp . P ( a = outer_div , text = 'Please select your age:' ) age_list = [] for age in ages : label = jp . Label ( classes = 'inline-block mb-1 p-1' , a = outer_div ) radio_btn = jp . Input ( type = 'radio' , name = 'age' , value = age [ 0 ], a = label , btn_list = age_list , result_div = result_div , change = radio_changed ) age_list . append ( radio_btn ) jp . Span ( classes = 'ml-1' , a = label , text = f ' {age[0]} - {age[1]} ' ) jp . Br ( a = outer_div ) wp . add ( result_div ) return wp jp . justpy ( radio_test )","title":"Radio Button Example"},{"location":"tutorial/input/#checkbox-example","text":"Below is an example of a checkbox and a textbox connected using the model attribute (you may skip this for now and return to this example after completing the chapter describing the model attribute in this tutorial). import justpy as jp def check_test (): wp = jp . WebPage ( data = { 'checked' : True }) label = jp . Label ( a = wp , classes = 'm-2 p-2 inline-block' ) c = jp . Input ( type = 'checkbox' , classes = 'm-2 p-2 form-checkbox' , a = label , model = [ wp , 'checked' ]) caption = jp . Span ( text = 'Click to get stuff' , a = label ) in1 = jp . Input ( model = [ wp , 'checked' ], a = wp , classes = 'border block m-2 p-2' ) return wp jp . justpy ( check_test ) See what happens when you clear the text input element.","title":"Checkbox Example"},{"location":"tutorial/input/#changing-focus-using-keyboard-events","text":"In the example below, Input elements respond to the Esc and Enter keys. When Esc is pressed, the field value is set to the empty string. When Enter is pressed, focus moves to the next field down unless it is the last field in which case focus is moved to the first. To make the example work, an event handler for the 'blur' event is required. When one of the input elements loses focus, the blur event occurs and the focus field of the element is set to false so that the correct element will have focus. By setting the set_focus attribute of an element to True , you transfer the focus to it. If the attribute is True for multiple elements on the page, the results are unpredictable and therefore the blur event handler is required to make sure the attribute is True for only one element. import justpy as jp def my_blur ( self , msg ): self . set_focus = False def key_down ( self , msg ): # print(msg.key_data) key = msg . key_data . key if key == 'Escape' : self . value = '' return if key == 'Enter' : self . set_focus = False try : next_to_focus = self . input_list [ self . num + 1 ] except : next_to_focus = self . input_list [ 0 ] next_to_focus . set_focus = True return return True # Don't update the page def focus_test (): wp = jp . WebPage () d = jp . Div ( classes = 'flex flex-col m-2' , a = wp , style = 'width: 600 px' ) input_list = [] number_of_fields = 5 for i in range ( 1 , number_of_fields + 1 ): label = jp . Label ( a = d , classes = 'm-2 p-2' ) jp . Span ( text = f 'Field {i} ' , a = label ) in1 = jp . Input ( classes = jp . Styles . input_classes , placeholder = f ' {i} Type here' , a = label , keydown = key_down , spellcheck = \"false\" ) in1 . on ( 'blur' , my_blur ) in1 . input_list = input_list in1 . num = i - 1 input_list . append ( in1 ) return wp jp . justpy ( focus_test ) As a rule of thumb, try to limit the usage of keyboard events to a minimum since they don't work well for mobile users.","title":"Changing Focus using Keyboard Events"},{"location":"tutorial/input/#using-select","text":"The select tag needs to be used together with the option tag. In JustPy these correspond to Select and Option elements. The program below creates a select element whose value changes the background color of a Div. import justpy as jp def change_color ( self , msg ): self . color_div . set_class ( f 'bg- {self.value} -600' ) def comp_test (): wp = jp . WebPage () colors = [ 'red' , 'green' , 'blue' , 'pink' , 'yellow' , 'teal' , 'purple' ] select = jp . Select ( classes = 'w-32 text-xl m-4 p-2 bg-white border rounded' , a = wp , value = 'red' , change = change_color ) for color in colors : select . add ( jp . Option ( value = color , text = color , classes = f 'bg- {color} -600' )) select . color_div = jp . Div ( classes = 'bg-red-600 w-32 h-16 m-4' , a = wp ) return wp jp . justpy ( comp_test )","title":"Using Select"},{"location":"tutorial/input/#your-first-component","text":"JustPy allows building your own reusable components. We will have a lot more to say about this later, but just to start easing into the subject, let's suppose we want to encapsulate the functionality of an Input coupled to a Div into one component (like in one of the first examples above). The program would look like this: import justpy as jp class InputWithDiv ( jp . Div ): input_classes = \"m-2 bg-gray-200 border-2 border-gray-200 rounded w-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" @staticmethod def input_handler ( self , msg ): self . div . text = self . value def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . in1 = jp . Input ( a = self , classes = self . input_classes , placeholder = 'Please type here' , input = self . input_handler ) self . in1 . div = jp . Div ( text = 'What you type will show up here' , classes = 'm-2 p-2 h-32 text-xl border-2' , a = self ) def input_demo ( request ): wp = jp . WebPage () for i in range ( 10 ): InputWithDiv ( a = wp ) return wp jp . justpy ( input_demo ) Try running the program. It will put on the page 10 pairs of input and div elements. If you type into the respective input field, the text will show up in the respective div. JustPy components are Python classes that inherit from JustPy classes. In the example above, we define the class InputWithDiv which inherits from the JustPy class Div . In the __init__ method an input element and another div is added to the basic div, with the appropriate functionality. Now, we have a component, InputWithDiv , that we can reuse as we please in any project. If you don't completely understand what is going on, don't worry. We will revisit this in much more detail later. The take home message at this stage is that the way you build complex applications in JustPy is by building components with isolated functionality. Hopefully, if JustPy gains popularity, there will be many components that the community will develop and share.","title":"Your First Component"},{"location":"tutorial/markdown/","text":"Using Markdown \u00b6 The Markdown component allows adding markdown formatted text to a web page. The component uses Python-Markdown and is only available if Python-Markdown is installed . The component has three attributes: markdown - The markdown annotated text extensions - A list of extensions to use all_extensions - A boolean value that defaults to True in which case all extensions included with Python-Markdown are used. If extensions is not empty, its value is used instead of all extensions WebPage write Method \u00b6 You can use the write method to put markdown directly on a page. The method accepts one argument, a markdown formatted string. The method returns the component that is added to the page. import justpy as jp def add_item_to_list ( self , msg ): wp = msg . page wp . list_item_num += 1 wp . md . markdown = f ' {wp.md.markdown} \\n * *Item* ** {wp.list_item_num} **' def md_test (): wp = jp . WebPage () jp . Button ( text = 'Add Item to List' , classes = jp . Styles . button_bordered + ' m-4 p-2' , click = add_item_to_list , a = wp ) wp . md = jp . Markdown ( markdown = '# My List' , a = wp , classes = 'm-2' ) wp . list_item_num = 0 return wp @jp . SetRoute ( '/hello' ) def md_write_test (): wp = jp . WebPage () wp . write ( '# Hello world!' ) return wp jp . justpy ( md_test )","title":"Markdown"},{"location":"tutorial/markdown/#using-markdown","text":"The Markdown component allows adding markdown formatted text to a web page. The component uses Python-Markdown and is only available if Python-Markdown is installed . The component has three attributes: markdown - The markdown annotated text extensions - A list of extensions to use all_extensions - A boolean value that defaults to True in which case all extensions included with Python-Markdown are used. If extensions is not empty, its value is used instead of all extensions","title":"Using Markdown"},{"location":"tutorial/markdown/#webpage-write-method","text":"You can use the write method to put markdown directly on a page. The method accepts one argument, a markdown formatted string. The method returns the component that is added to the page. import justpy as jp def add_item_to_list ( self , msg ): wp = msg . page wp . list_item_num += 1 wp . md . markdown = f ' {wp.md.markdown} \\n * *Item* ** {wp.list_item_num} **' def md_test (): wp = jp . WebPage () jp . Button ( text = 'Add Item to List' , classes = jp . Styles . button_bordered + ' m-4 p-2' , click = add_item_to_list , a = wp ) wp . md = jp . Markdown ( markdown = '# My List' , a = wp , classes = 'm-2' ) wp . list_item_num = 0 return wp @jp . SetRoute ( '/hello' ) def md_write_test (): wp = jp . WebPage () wp . write ( '# Hello world!' ) return wp jp . justpy ( md_test )","title":"WebPage write Method"},{"location":"tutorial/matplotlib/","text":"Creating matplotlib Charts \u00b6 The most popular Python plotting library is matplotlib . Chances are that if you are interested in visualization, you have already used it. JustPy includes in its standard component library the component Matplotlib that makes it simple to include matplotlib charts in a web page without having to change any matplotlib command. The Matplotlib component \u00b6 Run the following example that uses the Matplotlib component: import justpy as jp import matplotlib.pyplot as plt def plot_test (): wp = jp . WebPage () plt . plot ([ 0 , 1 , 4 , 9 ], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'Matplotlib Example' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) jp . Matplotlib ( a = wp ) # If memory may be an issue, don't forget to close figures not in use anymore plt . close () return wp jp . justpy ( plot_test ) The line jp.Matplotlib(a=wp) creates a Matplotlib instance and adds it to wp . Tip If you call Matplotlib where you would normally call plt.show() the chart instance is created reflecting all the matplotlib commands issued so far. The Matplotlib component is a modified Div component whose inner_html attribute is set to the SVG representation of a matplotlib figure . If a matplotlib figure is not specified explicitly when a Matplotlib instance is created (like in the example above), Matplotlib uses the current figure. If you want to put some other figure on the page use the figure keyword when creating the instance or use the set_figure(figure) method of the component after creation. Tip Don't forget to close matplotlib figures that are not in use. This will not affect any JustPy Matplotlib instances as the SVG representation that was created from the figure is distinct from the figure and will not be deleted. In the example below, the first chart created is displayed second and the second chart created is displayed first. import justpy as jp import matplotlib.pyplot as plt def plot_test (): wp = jp . WebPage () first_figure = plt . figure () plt . plot ([ 0 , 1 , 4 , 9 ], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'First Figure Showing Second' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) second_figure = plt . figure () plt . plot ([ 0 , 1 , 4 , 9 ], marker = '+' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'Second Figure Showing First' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) # Keyword method of setting figure jp . Matplotlib ( figure = second_figure , a = wp ) # Using method after creation c = jp . Matplotlib ( a = wp ) c . set_figure ( first_figure ) # If memory may be an issue, don't forget to close figures not in use anymore plt . close ( first_figure ) plt . close ( second_figure ) return wp jp . justpy ( plot_test ) Updating charts following events \u00b6 In the example below, each time the button is clicked, another point is added to the chart. This is done by creating a new figure in the event handler and setting the figure of the component to this new figure. In effect, the inner_html attribute of the element is set to the SVG of the new figure. import justpy as jp import matplotlib.pyplot as plt def plot_test (): wp = jp . WebPage () f = plt . figure () plt . plot ([ 0 , 1 , 4 , 9 ], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'Matplotlib Example' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) chart = jp . Matplotlib ( a = wp ) chart . num_points = 4 plt . close ( f ) b = jp . Button ( text = 'Add Point' , a = wp , classes = 'm-2 bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded' ) b . chart = chart def add_point ( self , msg ): self . chart . num_points += 1 np = self . chart . num_points f = plt . figure () plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) self . chart . set_figure ( f ) plt . close ( f ) b . on ( 'click' , add_point ) return wp jp . justpy ( plot_test ) The chart component itself is a JustPy component so it responds also to events. In the example below, clicking the button adds a point to the chart while clicking the chart subtracts a point. import justpy as jp import matplotlib.pyplot as plt def plot_test (): wp = jp . WebPage () print ( f 'start {plt.get_fignums()}' ) f = plt . figure () plt . plot ([ 0 , 1 , 4 , 9 ], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'Matplotlib Example' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) chart = jp . Matplotlib ( a = wp ) chart . num_points = 4 plt . close ( f ) b = jp . Button ( text = 'Add Point' , a = wp , classes = 'm-2 bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded' ) b . chart = chart def add_point ( self , msg ): self . chart . num_points += 1 np = self . chart . num_points f = plt . figure () plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) self . chart . set_figure ( f ) plt . close ( f ) b . on ( 'click' , add_point ) def subtract_point ( self , msg ): self . num_points -= 1 np = self . num_points f = plt . figure () plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) self . set_figure ( f ) plt . close ( f ) chart . on ( 'click' , subtract_point ) return wp jp . justpy ( plot_test ) Multiple charts on a page \u00b6 The program below is very similar to the example above except that it puts the same chart element several times on the page. Since it is the same element, the event handlers modify all the charts. import justpy as jp import matplotlib.pyplot as plt def plot_test (): wp = jp . WebPage () print ( f 'start {plt.get_fignums()}' ) f = plt . figure ( figsize = ( 2 , 2 )) plt . plot ([ 0 , 1 , 4 , 9 ], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'Matplotlib Example' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) chart = jp . Matplotlib ( classes = 'm-1 p-2' ) for i in range ( 5 ): d . add ( chart ) chart . num_points = 4 plt . close ( f ) b = jp . Button ( text = 'Add Point' , a = wp , classes = 'm-2 bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded' ) b . chart = chart def add_point ( self , msg ): self . chart . num_points += 1 np = self . chart . num_points f = plt . figure ( figsize = ( 2 , 2 )) plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) self . chart . set_figure ( f ) plt . close ( f ) b . on ( 'click' , add_point ) def subtract_point ( self , msg ): self . num_points -= 1 np = self . num_points f = plt . figure ( figsize = ( 2 , 2 )) plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) self . set_figure ( f ) plt . close ( f ) chart . on ( 'click' , subtract_point ) return wp jp . justpy ( plot_test ) If we want to treat each chart separately in the event handlers we need to modify the program. In the program below clicking the button adds a point to all charts while clicking each chart subtracts a point only from the chart clicked. import justpy as jp import matplotlib.pyplot as plt def add_point ( self , msg ): for chart in self . chart_list : chart . num_points += 1 np = chart . num_points f = plt . figure ( figsize = ( 2 , 2 )) plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) chart . set_figure ( f ) plt . close ( f ) def subtract_point ( self , msg ): self . num_points -= 1 np = self . num_points f = plt . figure ( figsize = ( 2 , 2 )) plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) self . set_figure ( f ) plt . close ( f ) def plot_test (): wp = jp . WebPage () f = plt . figure ( figsize = ( 2 , 2 )) plt . plot ([ 0 , 1 , 4 , 9 ], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'Matplotlib Example' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) chart_list = [] for i in range ( 5 ): chart = jp . Matplotlib ( a = d , classes = 'm-1 p-2' ) chart . num_points = 4 chart_list . append ( chart ) chart . on ( 'click' , subtract_point ) plt . close ( f ) b = jp . Button ( text = 'Add Point' , a = wp , classes = 'm-2 bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded' ) b . chart_list = chart_list b . on ( 'click' , add_point ) return wp jp . justpy ( plot_test ) In order to handle each chart separately, we create 20 distinct chart elements and assign to the button the list of the chart elements we created and then iterate over the charts in the button's click event handler. Creating matplotlib charts with pandas \u00b6 Pandas provides a visualization layer over matplotlib. Since pandas creates matplotlib plots, the Matplotlib component works in this case as well. Simply call Matplotlib when in your code you would normally call plt.show() . Tip If you create matplotlib charts within request handlers, don't forget to close the matplotlib figures associated with them in order to conserve memory and make your application scalable. Note The example below takes about 15 seconds to load a request, it is not hanging import justpy as jp import pandas as pd import numpy as np import matplotlib.pyplot as plt # All examples from https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html def plot_test (): wp = jp . WebPage () jp . Div ( text = 'Series Plot' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) ts = pd . Series ( np . random . randn ( 1000 ), index = pd . date_range ( '1/1/2000' , periods = 1000 )) ts = ts . cumsum () ts . plot () jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Frame Plot' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df = pd . DataFrame ( np . random . randn ( 1000 , 4 ), index = ts . index , columns = list ( 'ABCD' )) df = df . cumsum () df . plot () jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Histogram' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df4 = pd . DataFrame ({ 'a' : np . random . randn ( 1000 ) + 1 , 'b' : np . random . randn ( 1000 ), 'c' : np . random . randn ( 1000 ) - 1 }, columns = [ 'a' , 'b' , 'c' ]) df4 . plot . hist ( alpha = 0.5 ) jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Multiple Subplots' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df . diff () . hist ( color = 'k' , alpha = 0.5 , bins = 50 ) jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Multiple Pie Charts' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df_pie = pd . DataFrame ( 3 * np . random . rand ( 4 , 2 ), index = [ 'a' , 'b' , 'c' , 'd' ], columns = [ 'x' , 'y' ]) df_pie . plot . pie ( subplots = True , figsize = ( 8 , 4 )) jp . Matplotlib ( a = wp ) plt . close () # The following example takes some time (about 15 seconds) to generate, so the page loads slowly jp . Div ( text = 'Plotting Tools, Scatter Matrix' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df_scatter = pd . DataFrame ( np . random . randn ( 1000 , 4 ), columns = [ 'a' , 'b' , 'c' , 'd' ]) pd . plotting . scatter_matrix ( df_scatter , alpha = 0.2 , figsize = ( 10 , 10 ), diagonal = 'kde' ) jp . Matplotlib ( a = wp ) plt . close () return wp jp . justpy ( plot_test ) If you don't need to customize the chart for each request, you can speed up your website's response time by generating the charts once and serving the same chart elements with each request. Here is the program above modified in this fashion: import justpy as jp import pandas as pd import numpy as np import matplotlib.pyplot as plt # All examples from https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html def create_page (): wp = jp . WebPage ( delete_flag = False ) jp . Div ( text = 'Series Plot' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) ts = pd . Series ( np . random . randn ( 1000 ), index = pd . date_range ( '1/1/2000' , periods = 1000 )) ts = ts . cumsum () ts . plot () jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Frame Plot' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df = pd . DataFrame ( np . random . randn ( 1000 , 4 ), index = ts . index , columns = list ( 'ABCD' )) df = df . cumsum () df . plot () jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Histogram' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df4 = pd . DataFrame ({ 'a' : np . random . randn ( 1000 ) + 1 , 'b' : np . random . randn ( 1000 ), 'c' : np . random . randn ( 1000 ) - 1 }, columns = [ 'a' , 'b' , 'c' ]) df4 . plot . hist ( alpha = 0.5 ) jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Multiple Subplots' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df . diff () . hist ( color = 'k' , alpha = 0.5 , bins = 50 ) jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Multiple Pie Charts' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df_pie = pd . DataFrame ( 3 * np . random . rand ( 4 , 2 ), index = [ 'a' , 'b' , 'c' , 'd' ], columns = [ 'x' , 'y' ]) df_pie . plot . pie ( subplots = True , figsize = ( 8 , 4 )) jp . Matplotlib ( a = wp ) plt . close () # The following example takes some time (about 10 seconds) to generate. jp . Div ( text = 'Plotting Tools, Scatter Matrix' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df_scatter = pd . DataFrame ( np . random . randn ( 1000 , 4 ), columns = [ 'a' , 'b' , 'c' , 'd' ]) pd . plotting . scatter_matrix ( df_scatter , alpha = 0.2 , figsize = ( 10 , 10 ), diagonal = 'kde' ) jp . Matplotlib ( a = wp ) plt . close () return wp wp = create_page () def plot_test (): return wp jp . justpy ( plot_test ) Creating charts with seaborn \u00b6 Seaborn is a Python data visualization library based on matplotlib. It provides a high-level interface for drawing attractive and informative statistical graphics. Seaborn allows you to create beautiful visualizations with few lines of code. Again, since seaborn, like pandas' visualization, is based on matplotlib, Matplotlib (the JustPy component) works well also with seaborn. Following are a few examples taken from the seaborn introduction : import justpy as jp import seaborn as sns # All examples from https://seaborn.pydata.org/introduction.html def create_page (): wp = jp . WebPage ( delete_flag = False ) chart_classes = 'm-2' jp . Div ( text = 'Tips Dataset' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) sns . set () tips = sns . load_dataset ( \"tips\" ) sns . relplot ( x = \"total_bill\" , y = \"tip\" , col = \"time\" , hue = \"smoker\" , style = \"smoker\" , size = \"size\" , data = tips ) jp . Matplotlib ( a = wp , classes = chart_classes ) sns . lmplot ( x = \"total_bill\" , y = \"tip\" , col = \"time\" , hue = \"smoker\" , data = tips ) jp . Matplotlib ( a = wp , classes = chart_classes ) sns . catplot ( x = \"day\" , y = \"total_bill\" , hue = \"smoker\" , kind = \"swarm\" , data = tips ) jp . Matplotlib ( a = wp , classes = chart_classes ) sns . catplot ( x = \"day\" , y = \"total_bill\" , hue = \"smoker\" , kind = \"violin\" , split = True , data = tips ) jp . Matplotlib ( a = wp , classes = chart_classes ) jp . Div ( text = 'Dots Dataset' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) dots = sns . load_dataset ( \"dots\" ) sns . relplot ( x = \"time\" , y = \"firing_rate\" , col = \"align\" , hue = \"choice\" , size = \"coherence\" , style = \"choice\" , facet_kws = dict ( sharex = False ), kind = \"line\" , legend = \"full\" , data = dots ) jp . Matplotlib ( a = wp , classes = chart_classes ) jp . Div ( text = 'FMRI Dataset' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) fmri = sns . load_dataset ( \"fmri\" ) sns . relplot ( x = \"timepoint\" , y = \"signal\" , col = \"region\" , hue = \"event\" , style = \"event\" , kind = \"line\" , data = fmri ) jp . Matplotlib ( a = wp , classes = chart_classes ) jp . Div ( text = 'Iris Dataset' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) iris = sns . load_dataset ( \"iris\" ) sns . jointplot ( x = \"sepal_length\" , y = \"petal_length\" , data = iris ) jp . Matplotlib ( a = wp , classes = chart_classes ) sns . pairplot ( data = iris , hue = \"species\" ) jp . Matplotlib ( a = wp , classes = chart_classes ) return wp wp = create_page () def plot_test (): return wp jp . justpy ( plot_test )","title":"Matplotlib Charting"},{"location":"tutorial/matplotlib/#creating-matplotlib-charts","text":"The most popular Python plotting library is matplotlib . Chances are that if you are interested in visualization, you have already used it. JustPy includes in its standard component library the component Matplotlib that makes it simple to include matplotlib charts in a web page without having to change any matplotlib command.","title":"Creating matplotlib Charts"},{"location":"tutorial/matplotlib/#the-matplotlib-component","text":"Run the following example that uses the Matplotlib component: import justpy as jp import matplotlib.pyplot as plt def plot_test (): wp = jp . WebPage () plt . plot ([ 0 , 1 , 4 , 9 ], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'Matplotlib Example' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) jp . Matplotlib ( a = wp ) # If memory may be an issue, don't forget to close figures not in use anymore plt . close () return wp jp . justpy ( plot_test ) The line jp.Matplotlib(a=wp) creates a Matplotlib instance and adds it to wp . Tip If you call Matplotlib where you would normally call plt.show() the chart instance is created reflecting all the matplotlib commands issued so far. The Matplotlib component is a modified Div component whose inner_html attribute is set to the SVG representation of a matplotlib figure . If a matplotlib figure is not specified explicitly when a Matplotlib instance is created (like in the example above), Matplotlib uses the current figure. If you want to put some other figure on the page use the figure keyword when creating the instance or use the set_figure(figure) method of the component after creation. Tip Don't forget to close matplotlib figures that are not in use. This will not affect any JustPy Matplotlib instances as the SVG representation that was created from the figure is distinct from the figure and will not be deleted. In the example below, the first chart created is displayed second and the second chart created is displayed first. import justpy as jp import matplotlib.pyplot as plt def plot_test (): wp = jp . WebPage () first_figure = plt . figure () plt . plot ([ 0 , 1 , 4 , 9 ], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'First Figure Showing Second' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) second_figure = plt . figure () plt . plot ([ 0 , 1 , 4 , 9 ], marker = '+' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'Second Figure Showing First' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) # Keyword method of setting figure jp . Matplotlib ( figure = second_figure , a = wp ) # Using method after creation c = jp . Matplotlib ( a = wp ) c . set_figure ( first_figure ) # If memory may be an issue, don't forget to close figures not in use anymore plt . close ( first_figure ) plt . close ( second_figure ) return wp jp . justpy ( plot_test )","title":"The Matplotlib component"},{"location":"tutorial/matplotlib/#updating-charts-following-events","text":"In the example below, each time the button is clicked, another point is added to the chart. This is done by creating a new figure in the event handler and setting the figure of the component to this new figure. In effect, the inner_html attribute of the element is set to the SVG of the new figure. import justpy as jp import matplotlib.pyplot as plt def plot_test (): wp = jp . WebPage () f = plt . figure () plt . plot ([ 0 , 1 , 4 , 9 ], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'Matplotlib Example' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) chart = jp . Matplotlib ( a = wp ) chart . num_points = 4 plt . close ( f ) b = jp . Button ( text = 'Add Point' , a = wp , classes = 'm-2 bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded' ) b . chart = chart def add_point ( self , msg ): self . chart . num_points += 1 np = self . chart . num_points f = plt . figure () plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) self . chart . set_figure ( f ) plt . close ( f ) b . on ( 'click' , add_point ) return wp jp . justpy ( plot_test ) The chart component itself is a JustPy component so it responds also to events. In the example below, clicking the button adds a point to the chart while clicking the chart subtracts a point. import justpy as jp import matplotlib.pyplot as plt def plot_test (): wp = jp . WebPage () print ( f 'start {plt.get_fignums()}' ) f = plt . figure () plt . plot ([ 0 , 1 , 4 , 9 ], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'Matplotlib Example' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) chart = jp . Matplotlib ( a = wp ) chart . num_points = 4 plt . close ( f ) b = jp . Button ( text = 'Add Point' , a = wp , classes = 'm-2 bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded' ) b . chart = chart def add_point ( self , msg ): self . chart . num_points += 1 np = self . chart . num_points f = plt . figure () plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) self . chart . set_figure ( f ) plt . close ( f ) b . on ( 'click' , add_point ) def subtract_point ( self , msg ): self . num_points -= 1 np = self . num_points f = plt . figure () plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) self . set_figure ( f ) plt . close ( f ) chart . on ( 'click' , subtract_point ) return wp jp . justpy ( plot_test )","title":"Updating charts following events"},{"location":"tutorial/matplotlib/#multiple-charts-on-a-page","text":"The program below is very similar to the example above except that it puts the same chart element several times on the page. Since it is the same element, the event handlers modify all the charts. import justpy as jp import matplotlib.pyplot as plt def plot_test (): wp = jp . WebPage () print ( f 'start {plt.get_fignums()}' ) f = plt . figure ( figsize = ( 2 , 2 )) plt . plot ([ 0 , 1 , 4 , 9 ], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'Matplotlib Example' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) chart = jp . Matplotlib ( classes = 'm-1 p-2' ) for i in range ( 5 ): d . add ( chart ) chart . num_points = 4 plt . close ( f ) b = jp . Button ( text = 'Add Point' , a = wp , classes = 'm-2 bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded' ) b . chart = chart def add_point ( self , msg ): self . chart . num_points += 1 np = self . chart . num_points f = plt . figure ( figsize = ( 2 , 2 )) plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) self . chart . set_figure ( f ) plt . close ( f ) b . on ( 'click' , add_point ) def subtract_point ( self , msg ): self . num_points -= 1 np = self . num_points f = plt . figure ( figsize = ( 2 , 2 )) plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) self . set_figure ( f ) plt . close ( f ) chart . on ( 'click' , subtract_point ) return wp jp . justpy ( plot_test ) If we want to treat each chart separately in the event handlers we need to modify the program. In the program below clicking the button adds a point to all charts while clicking each chart subtracts a point only from the chart clicked. import justpy as jp import matplotlib.pyplot as plt def add_point ( self , msg ): for chart in self . chart_list : chart . num_points += 1 np = chart . num_points f = plt . figure ( figsize = ( 2 , 2 )) plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) chart . set_figure ( f ) plt . close ( f ) def subtract_point ( self , msg ): self . num_points -= 1 np = self . num_points f = plt . figure ( figsize = ( 2 , 2 )) plt . plot ([ i * i for i in range ( np )], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( f 'This chart has {np} points' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) self . set_figure ( f ) plt . close ( f ) def plot_test (): wp = jp . WebPage () f = plt . figure ( figsize = ( 2 , 2 )) plt . plot ([ 0 , 1 , 4 , 9 ], marker = '*' , markersize = 20 , markeredgecolor = 'red' ) plt . title ( 'Matplotlib Example' ) plt . xlabel ( 'x data' ) plt . ylabel ( 'y data' ) d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) chart_list = [] for i in range ( 5 ): chart = jp . Matplotlib ( a = d , classes = 'm-1 p-2' ) chart . num_points = 4 chart_list . append ( chart ) chart . on ( 'click' , subtract_point ) plt . close ( f ) b = jp . Button ( text = 'Add Point' , a = wp , classes = 'm-2 bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded' ) b . chart_list = chart_list b . on ( 'click' , add_point ) return wp jp . justpy ( plot_test ) In order to handle each chart separately, we create 20 distinct chart elements and assign to the button the list of the chart elements we created and then iterate over the charts in the button's click event handler.","title":"Multiple charts on a page"},{"location":"tutorial/matplotlib/#creating-matplotlib-charts-with-pandas","text":"Pandas provides a visualization layer over matplotlib. Since pandas creates matplotlib plots, the Matplotlib component works in this case as well. Simply call Matplotlib when in your code you would normally call plt.show() . Tip If you create matplotlib charts within request handlers, don't forget to close the matplotlib figures associated with them in order to conserve memory and make your application scalable. Note The example below takes about 15 seconds to load a request, it is not hanging import justpy as jp import pandas as pd import numpy as np import matplotlib.pyplot as plt # All examples from https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html def plot_test (): wp = jp . WebPage () jp . Div ( text = 'Series Plot' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) ts = pd . Series ( np . random . randn ( 1000 ), index = pd . date_range ( '1/1/2000' , periods = 1000 )) ts = ts . cumsum () ts . plot () jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Frame Plot' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df = pd . DataFrame ( np . random . randn ( 1000 , 4 ), index = ts . index , columns = list ( 'ABCD' )) df = df . cumsum () df . plot () jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Histogram' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df4 = pd . DataFrame ({ 'a' : np . random . randn ( 1000 ) + 1 , 'b' : np . random . randn ( 1000 ), 'c' : np . random . randn ( 1000 ) - 1 }, columns = [ 'a' , 'b' , 'c' ]) df4 . plot . hist ( alpha = 0.5 ) jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Multiple Subplots' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df . diff () . hist ( color = 'k' , alpha = 0.5 , bins = 50 ) jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Multiple Pie Charts' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df_pie = pd . DataFrame ( 3 * np . random . rand ( 4 , 2 ), index = [ 'a' , 'b' , 'c' , 'd' ], columns = [ 'x' , 'y' ]) df_pie . plot . pie ( subplots = True , figsize = ( 8 , 4 )) jp . Matplotlib ( a = wp ) plt . close () # The following example takes some time (about 15 seconds) to generate, so the page loads slowly jp . Div ( text = 'Plotting Tools, Scatter Matrix' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df_scatter = pd . DataFrame ( np . random . randn ( 1000 , 4 ), columns = [ 'a' , 'b' , 'c' , 'd' ]) pd . plotting . scatter_matrix ( df_scatter , alpha = 0.2 , figsize = ( 10 , 10 ), diagonal = 'kde' ) jp . Matplotlib ( a = wp ) plt . close () return wp jp . justpy ( plot_test ) If you don't need to customize the chart for each request, you can speed up your website's response time by generating the charts once and serving the same chart elements with each request. Here is the program above modified in this fashion: import justpy as jp import pandas as pd import numpy as np import matplotlib.pyplot as plt # All examples from https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html def create_page (): wp = jp . WebPage ( delete_flag = False ) jp . Div ( text = 'Series Plot' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) ts = pd . Series ( np . random . randn ( 1000 ), index = pd . date_range ( '1/1/2000' , periods = 1000 )) ts = ts . cumsum () ts . plot () jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Frame Plot' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df = pd . DataFrame ( np . random . randn ( 1000 , 4 ), index = ts . index , columns = list ( 'ABCD' )) df = df . cumsum () df . plot () jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Histogram' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df4 = pd . DataFrame ({ 'a' : np . random . randn ( 1000 ) + 1 , 'b' : np . random . randn ( 1000 ), 'c' : np . random . randn ( 1000 ) - 1 }, columns = [ 'a' , 'b' , 'c' ]) df4 . plot . hist ( alpha = 0.5 ) jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Multiple Subplots' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df . diff () . hist ( color = 'k' , alpha = 0.5 , bins = 50 ) jp . Matplotlib ( a = wp ) plt . close () jp . Div ( text = 'Multiple Pie Charts' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df_pie = pd . DataFrame ( 3 * np . random . rand ( 4 , 2 ), index = [ 'a' , 'b' , 'c' , 'd' ], columns = [ 'x' , 'y' ]) df_pie . plot . pie ( subplots = True , figsize = ( 8 , 4 )) jp . Matplotlib ( a = wp ) plt . close () # The following example takes some time (about 10 seconds) to generate. jp . Div ( text = 'Plotting Tools, Scatter Matrix' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) df_scatter = pd . DataFrame ( np . random . randn ( 1000 , 4 ), columns = [ 'a' , 'b' , 'c' , 'd' ]) pd . plotting . scatter_matrix ( df_scatter , alpha = 0.2 , figsize = ( 10 , 10 ), diagonal = 'kde' ) jp . Matplotlib ( a = wp ) plt . close () return wp wp = create_page () def plot_test (): return wp jp . justpy ( plot_test )","title":"Creating matplotlib charts with pandas"},{"location":"tutorial/matplotlib/#creating-charts-with-seaborn","text":"Seaborn is a Python data visualization library based on matplotlib. It provides a high-level interface for drawing attractive and informative statistical graphics. Seaborn allows you to create beautiful visualizations with few lines of code. Again, since seaborn, like pandas' visualization, is based on matplotlib, Matplotlib (the JustPy component) works well also with seaborn. Following are a few examples taken from the seaborn introduction : import justpy as jp import seaborn as sns # All examples from https://seaborn.pydata.org/introduction.html def create_page (): wp = jp . WebPage ( delete_flag = False ) chart_classes = 'm-2' jp . Div ( text = 'Tips Dataset' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) sns . set () tips = sns . load_dataset ( \"tips\" ) sns . relplot ( x = \"total_bill\" , y = \"tip\" , col = \"time\" , hue = \"smoker\" , style = \"smoker\" , size = \"size\" , data = tips ) jp . Matplotlib ( a = wp , classes = chart_classes ) sns . lmplot ( x = \"total_bill\" , y = \"tip\" , col = \"time\" , hue = \"smoker\" , data = tips ) jp . Matplotlib ( a = wp , classes = chart_classes ) sns . catplot ( x = \"day\" , y = \"total_bill\" , hue = \"smoker\" , kind = \"swarm\" , data = tips ) jp . Matplotlib ( a = wp , classes = chart_classes ) sns . catplot ( x = \"day\" , y = \"total_bill\" , hue = \"smoker\" , kind = \"violin\" , split = True , data = tips ) jp . Matplotlib ( a = wp , classes = chart_classes ) jp . Div ( text = 'Dots Dataset' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) dots = sns . load_dataset ( \"dots\" ) sns . relplot ( x = \"time\" , y = \"firing_rate\" , col = \"align\" , hue = \"choice\" , size = \"coherence\" , style = \"choice\" , facet_kws = dict ( sharex = False ), kind = \"line\" , legend = \"full\" , data = dots ) jp . Matplotlib ( a = wp , classes = chart_classes ) jp . Div ( text = 'FMRI Dataset' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) fmri = sns . load_dataset ( \"fmri\" ) sns . relplot ( x = \"timepoint\" , y = \"signal\" , col = \"region\" , hue = \"event\" , style = \"event\" , kind = \"line\" , data = fmri ) jp . Matplotlib ( a = wp , classes = chart_classes ) jp . Div ( text = 'Iris Dataset' , a = wp , classes = 'text-white bg-blue-500 text-center text-xl' ) iris = sns . load_dataset ( \"iris\" ) sns . jointplot ( x = \"sepal_length\" , y = \"petal_length\" , data = iris ) jp . Matplotlib ( a = wp , classes = chart_classes ) sns . pairplot ( data = iris , hue = \"species\" ) jp . Matplotlib ( a = wp , classes = chart_classes ) return wp wp = create_page () def plot_test (): return wp jp . justpy ( plot_test )","title":"Creating charts with seaborn"},{"location":"tutorial/model_and_data/","text":"The model and data Attributes \u00b6 Introduction and Examples \u00b6 The model attribute is a special one in JustPy. You don't need to use it, but if you do, it may make your code more concise and readable. It is an elegant and simple way to share data between independent components (it was inspired by the v-model directive in Vue.js and works in a similar manner). Try running the following program and typing into the input field in the browser: import justpy as jp async def input_demo ( request ): wp = jp . WebPage ( data = { 'text' : 'Initial text' }) input_classes = \"m-2 bg-gray-200 appearance-none border-2 border-gray-200 rounded xtw-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" jp . Input ( a = wp , classes = input_classes , placeholder = 'Please type here' , model = [ wp , 'text' ]) jp . Div ( model = [ wp , 'text' ], classes = 'm-2 p-2 h-32 text-xl border-2 overflow-auto' , a = wp ) return wp jp . justpy ( input_demo ) Text entered in an input field is reflected in a div on the page. The connection between the input and the div is made using the model and data attributes. Notice that when we create the web page, we initialize a data attribute. The data attribute must be a Python dictionary. In our case it is a dictionary with one entry. The key is 'text' and the value is 'Initial text'. When we create the Input element, we add the following to its keyword arguments: model=[wp, 'text'] This tells the Input instance that it will model itself based on the value under the 'text' key in wp 's data. For an Input element this means that when rendered it will take its value from wp.data['text'] AND when its value is changed due to an input event, it will set wp.data['text'] to its new value. Note It is important to understand that in the case of Input, model has a two way influence. It gets its value from the appropriate data attribute and when an input event occurs it changes the appropriate data attribute. In the case of a Div element the relation is only one way. Its text attribute is rendered according to the model attribute but it does not change the data dictionary. If an element has an input event, the model attribute works in two directions, otherwise just in one. For two directional elements the attribute changed is value while for one directional ones the attribute changed is text. How is this useful? Let's put three divs on the page instead of just one: import justpy as jp async def input_demo ( request ): wp = jp . WebPage ( data = { 'text' : 'Initial text' }) input_classes = \"m-2 bg-gray-200 appearance-none border-2 border-gray-200 rounded xtw-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" jp . Input ( a = wp , classes = input_classes , placeholder = 'Please type here' , model = [ wp , 'text' ]) for i in range ( 3 ): jp . Div ( model = [ wp , 'text' ], classes = 'm-2 p-2 h-32 text-xl border-2 overflow-auto' , a = wp ) return wp jp . justpy ( input_demo ) Since all Div instances have the same model, they change when we type. Without the model attribute, implementing this would be more verbose. Now let's duplicate the Inputs. Let's have five Inputs instead of one: import justpy as jp async def input_demo ( request ): wp = jp . WebPage ( data = { 'text' : 'Initial text' }) input_classes = \"m-2 bg-gray-200 appearance-none border-2 border-gray-200 rounded xtw-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" for _ in range ( 5 ): jp . Input ( a = wp , classes = input_classes , placeholder = 'Please type here' , model = [ wp , 'text' ]) for _ in range ( 3 ): jp . Div ( model = [ wp , 'text' ], classes = 'm-2 p-2 h-32 text-xl border-2 overflow-auto' , a = wp ) return wp jp . justpy ( input_demo ) Type into any one of the five Input fields and see what happens. Since all elements share the same model, they all change in tandem. We didn't need to write any event handler. Let's make a small modification to the program and add a reset button that will clear all the elements on the page: import justpy as jp def reset_all ( self , msg ): msg . page . data [ 'text' ] = '' async def input_demo ( request ): wp = jp . WebPage ( data = { 'text' : 'Initial text' }) button_classes = 'w-32 m-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded' b = jp . Button ( text = 'Reset' , click = reset_all , a = wp , classes = button_classes ) jp . Hr ( a = wp ) # Add horizontal like to page input_classes = \"m-2 bg-gray-200 appearance-none border-2 border-gray-200 rounded xtw-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" for i in range ( 5 ): jp . Input ( a = wp , classes = input_classes , placeholder = 'Please type here' , model = [ wp , 'text' ]) for i in range ( 3 ): jp . Div ( model = [ wp , 'text' ], classes = 'm-2 p-2 h-32 text-xl border-2 overflow-auto' , a = wp ) return wp jp . justpy ( input_demo ) When the button is clicked, the following command in reset_all is executed: msg.page.data['text'] = '' Since all the Inputs and Divs are modeled after this dictionary entry, they are all reset to the empty string when the button is clicked. Note Any element, a Div for example, may have a data attribute and be used in a model attribute, not just a WebPage. With the model and data attributes you can easily propagate a change in one element to others. Advanced use of the model attribute \u00b6 Tip This part of the tutorial will use custom components. I recommend skipping this section initially and returning to it after having completed the first few sections of the Creating Custom Components part of the tutorial The following program is the base one we will expand on. It uses model in the same way as examples above. import justpy as jp corner_classes = 'p-3 absolute bg-gray-200 ' def model_demo (): wp = jp . WebPage () d = jp . Div ( classes = 'relative h-screen bg-gray-600' , a = wp , data = { 'text' : '' }) for v_pos in [ 'top' , 'bottom' ]: for h_pos in [ 'left' , 'right' ]: corner_div = jp . Div ( classes = corner_classes + f ' {v_pos} -0 {h_pos} -0' , a = d ) jp . Div ( text = f ' {v_pos} {h_pos} ' , a = corner_div ) jp . Div ( text = f 'typing will go here' , a = corner_div , model = [ d , 'text' ]) middle_input = jp . Input ( text = 'middle' , classes = 'absolute text-xl border-2 border-red-600' , placeholder = 'Type here' , style = 'top: 50%; left: 40%' , model = [ d , 'text' ], a = d ) return wp jp . justpy ( model_demo ) When you type text into middle_input it shows up in the four corners of the window. In each corner there is a Div that contains two other Divs. The second Div has the model property and the text in it changes when the user types into middle_input '`. If we want the corners to show the text \"Nothing typed yet\" when middle_input is empty, the best way to implement this, is by creating a new component with a more sophisticated model handling method. The program would look like this: import justpy as jp corner_classes = 'p-3 absolute bg-gray-200 ' class MyDiv ( jp . Div ): def model_update ( self ): # model has the form [wp, 'text'] for example if self . model [ 0 ] . data [ self . model [ 1 ]]: self . text = str ( self . model [ 0 ] . data [ self . model [ 1 ]]) else : self . text = \"Nothing typed yet\" def model_demo (): wp = jp . WebPage () d = jp . Div ( classes = 'relative h-screen bg-gray-600' , a = wp , data = { 'text' : '' }) for v_pos in [ 'top' , 'bottom' ]: for h_pos in [ 'left' , 'right' ]: corner_div = jp . Div ( classes = corner_classes + f ' {v_pos} -0 {h_pos} -0' , a = d ) jp . Div ( text = f ' {v_pos} {h_pos} ' , a = corner_div ) MyDiv ( text = f 'typing will go here' , a = corner_div , model = [ d , 'text' ]) middle_input = jp . Input ( text = 'middle' , classes = 'absolute text-xl border-2 border-red-600' , placeholder = 'Type here' , style = 'top: 50%; left: 40%' , model = [ d , 'text' ], a = d ) return wp jp . justpy ( model_demo ) We define a new component, MyDiv that inherits from Div and is identical except for the model_update method. The standard model_update method Div comes with is: def model_update ( self ): # [wp, 'text-data'] for example self . text = str ( self . model [ 0 ] . data [ self . model [ 1 ]]) In MyDiv 's model_update we check first if the value to set the text attribute is the empty string, and if so, assign to it the string \"Nothing typed yet\". It creates the functionality we were looking for. More complex model_update methods \u00b6 We can put more functionality into the the model_update function. import justpy as jp corner_classes = 'p-3 absolute bg-gray-200 ' class MyDiv ( jp . Div ): def model_update ( self ): # [wp, 'text-data'] for example if self . model [ 0 ] . data [ self . model [ 1 ]]: self . text = ( str ( self . model [ 0 ] . data [ self . model [ 1 ]]) + ' ' ) * self . repeat else : self . text = self . initial_text def model_demo (): wp = jp . WebPage () d = jp . Div ( classes = 'relative h-screen bg-gray-600' , a = wp , data = { 'text' : '' }) repeat = 1 for v_pos in [ 'top' , 'bottom' ]: for h_pos in [ 'left' , 'right' ]: corner_div = jp . Div ( classes = corner_classes + f ' {v_pos} -0 {h_pos} -0' , a = d ) jp . Div ( text = f ' {v_pos} {h_pos} ' , a = corner_div ) MyDiv ( text = f 'typing will go here' , a = corner_div , model = [ d , 'text' ], repeat = repeat , initial_text = 'Yada Yada' ) repeat += 1 middle_input = jp . Input ( text = 'middle' , classes = 'absolute text-xl border-2 border-red-600' , placeholder = 'Type here' , style = 'top: 50%; left: 40%' , model = [ d , 'text' ], a = d ) return wp jp . justpy ( model_demo ) We add the two attributes repeat and initial_text to MyDiv . The first, repeat determines how many time the model value will be repeated in the text. We give each corner a different value.","title":"The <b>model</b> and <b>data</b> Attributes"},{"location":"tutorial/model_and_data/#the-model-and-data-attributes","text":"","title":"The model and data Attributes"},{"location":"tutorial/model_and_data/#introduction-and-examples","text":"The model attribute is a special one in JustPy. You don't need to use it, but if you do, it may make your code more concise and readable. It is an elegant and simple way to share data between independent components (it was inspired by the v-model directive in Vue.js and works in a similar manner). Try running the following program and typing into the input field in the browser: import justpy as jp async def input_demo ( request ): wp = jp . WebPage ( data = { 'text' : 'Initial text' }) input_classes = \"m-2 bg-gray-200 appearance-none border-2 border-gray-200 rounded xtw-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" jp . Input ( a = wp , classes = input_classes , placeholder = 'Please type here' , model = [ wp , 'text' ]) jp . Div ( model = [ wp , 'text' ], classes = 'm-2 p-2 h-32 text-xl border-2 overflow-auto' , a = wp ) return wp jp . justpy ( input_demo ) Text entered in an input field is reflected in a div on the page. The connection between the input and the div is made using the model and data attributes. Notice that when we create the web page, we initialize a data attribute. The data attribute must be a Python dictionary. In our case it is a dictionary with one entry. The key is 'text' and the value is 'Initial text'. When we create the Input element, we add the following to its keyword arguments: model=[wp, 'text'] This tells the Input instance that it will model itself based on the value under the 'text' key in wp 's data. For an Input element this means that when rendered it will take its value from wp.data['text'] AND when its value is changed due to an input event, it will set wp.data['text'] to its new value. Note It is important to understand that in the case of Input, model has a two way influence. It gets its value from the appropriate data attribute and when an input event occurs it changes the appropriate data attribute. In the case of a Div element the relation is only one way. Its text attribute is rendered according to the model attribute but it does not change the data dictionary. If an element has an input event, the model attribute works in two directions, otherwise just in one. For two directional elements the attribute changed is value while for one directional ones the attribute changed is text. How is this useful? Let's put three divs on the page instead of just one: import justpy as jp async def input_demo ( request ): wp = jp . WebPage ( data = { 'text' : 'Initial text' }) input_classes = \"m-2 bg-gray-200 appearance-none border-2 border-gray-200 rounded xtw-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" jp . Input ( a = wp , classes = input_classes , placeholder = 'Please type here' , model = [ wp , 'text' ]) for i in range ( 3 ): jp . Div ( model = [ wp , 'text' ], classes = 'm-2 p-2 h-32 text-xl border-2 overflow-auto' , a = wp ) return wp jp . justpy ( input_demo ) Since all Div instances have the same model, they change when we type. Without the model attribute, implementing this would be more verbose. Now let's duplicate the Inputs. Let's have five Inputs instead of one: import justpy as jp async def input_demo ( request ): wp = jp . WebPage ( data = { 'text' : 'Initial text' }) input_classes = \"m-2 bg-gray-200 appearance-none border-2 border-gray-200 rounded xtw-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" for _ in range ( 5 ): jp . Input ( a = wp , classes = input_classes , placeholder = 'Please type here' , model = [ wp , 'text' ]) for _ in range ( 3 ): jp . Div ( model = [ wp , 'text' ], classes = 'm-2 p-2 h-32 text-xl border-2 overflow-auto' , a = wp ) return wp jp . justpy ( input_demo ) Type into any one of the five Input fields and see what happens. Since all elements share the same model, they all change in tandem. We didn't need to write any event handler. Let's make a small modification to the program and add a reset button that will clear all the elements on the page: import justpy as jp def reset_all ( self , msg ): msg . page . data [ 'text' ] = '' async def input_demo ( request ): wp = jp . WebPage ( data = { 'text' : 'Initial text' }) button_classes = 'w-32 m-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded' b = jp . Button ( text = 'Reset' , click = reset_all , a = wp , classes = button_classes ) jp . Hr ( a = wp ) # Add horizontal like to page input_classes = \"m-2 bg-gray-200 appearance-none border-2 border-gray-200 rounded xtw-64 py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-purple-500\" for i in range ( 5 ): jp . Input ( a = wp , classes = input_classes , placeholder = 'Please type here' , model = [ wp , 'text' ]) for i in range ( 3 ): jp . Div ( model = [ wp , 'text' ], classes = 'm-2 p-2 h-32 text-xl border-2 overflow-auto' , a = wp ) return wp jp . justpy ( input_demo ) When the button is clicked, the following command in reset_all is executed: msg.page.data['text'] = '' Since all the Inputs and Divs are modeled after this dictionary entry, they are all reset to the empty string when the button is clicked. Note Any element, a Div for example, may have a data attribute and be used in a model attribute, not just a WebPage. With the model and data attributes you can easily propagate a change in one element to others.","title":"Introduction and Examples"},{"location":"tutorial/model_and_data/#advanced-use-of-the-model-attribute","text":"Tip This part of the tutorial will use custom components. I recommend skipping this section initially and returning to it after having completed the first few sections of the Creating Custom Components part of the tutorial The following program is the base one we will expand on. It uses model in the same way as examples above. import justpy as jp corner_classes = 'p-3 absolute bg-gray-200 ' def model_demo (): wp = jp . WebPage () d = jp . Div ( classes = 'relative h-screen bg-gray-600' , a = wp , data = { 'text' : '' }) for v_pos in [ 'top' , 'bottom' ]: for h_pos in [ 'left' , 'right' ]: corner_div = jp . Div ( classes = corner_classes + f ' {v_pos} -0 {h_pos} -0' , a = d ) jp . Div ( text = f ' {v_pos} {h_pos} ' , a = corner_div ) jp . Div ( text = f 'typing will go here' , a = corner_div , model = [ d , 'text' ]) middle_input = jp . Input ( text = 'middle' , classes = 'absolute text-xl border-2 border-red-600' , placeholder = 'Type here' , style = 'top: 50%; left: 40%' , model = [ d , 'text' ], a = d ) return wp jp . justpy ( model_demo ) When you type text into middle_input it shows up in the four corners of the window. In each corner there is a Div that contains two other Divs. The second Div has the model property and the text in it changes when the user types into middle_input '`. If we want the corners to show the text \"Nothing typed yet\" when middle_input is empty, the best way to implement this, is by creating a new component with a more sophisticated model handling method. The program would look like this: import justpy as jp corner_classes = 'p-3 absolute bg-gray-200 ' class MyDiv ( jp . Div ): def model_update ( self ): # model has the form [wp, 'text'] for example if self . model [ 0 ] . data [ self . model [ 1 ]]: self . text = str ( self . model [ 0 ] . data [ self . model [ 1 ]]) else : self . text = \"Nothing typed yet\" def model_demo (): wp = jp . WebPage () d = jp . Div ( classes = 'relative h-screen bg-gray-600' , a = wp , data = { 'text' : '' }) for v_pos in [ 'top' , 'bottom' ]: for h_pos in [ 'left' , 'right' ]: corner_div = jp . Div ( classes = corner_classes + f ' {v_pos} -0 {h_pos} -0' , a = d ) jp . Div ( text = f ' {v_pos} {h_pos} ' , a = corner_div ) MyDiv ( text = f 'typing will go here' , a = corner_div , model = [ d , 'text' ]) middle_input = jp . Input ( text = 'middle' , classes = 'absolute text-xl border-2 border-red-600' , placeholder = 'Type here' , style = 'top: 50%; left: 40%' , model = [ d , 'text' ], a = d ) return wp jp . justpy ( model_demo ) We define a new component, MyDiv that inherits from Div and is identical except for the model_update method. The standard model_update method Div comes with is: def model_update ( self ): # [wp, 'text-data'] for example self . text = str ( self . model [ 0 ] . data [ self . model [ 1 ]]) In MyDiv 's model_update we check first if the value to set the text attribute is the empty string, and if so, assign to it the string \"Nothing typed yet\". It creates the functionality we were looking for.","title":"Advanced use of the model attribute"},{"location":"tutorial/model_and_data/#more-complex-model_update-methods","text":"We can put more functionality into the the model_update function. import justpy as jp corner_classes = 'p-3 absolute bg-gray-200 ' class MyDiv ( jp . Div ): def model_update ( self ): # [wp, 'text-data'] for example if self . model [ 0 ] . data [ self . model [ 1 ]]: self . text = ( str ( self . model [ 0 ] . data [ self . model [ 1 ]]) + ' ' ) * self . repeat else : self . text = self . initial_text def model_demo (): wp = jp . WebPage () d = jp . Div ( classes = 'relative h-screen bg-gray-600' , a = wp , data = { 'text' : '' }) repeat = 1 for v_pos in [ 'top' , 'bottom' ]: for h_pos in [ 'left' , 'right' ]: corner_div = jp . Div ( classes = corner_classes + f ' {v_pos} -0 {h_pos} -0' , a = d ) jp . Div ( text = f ' {v_pos} {h_pos} ' , a = corner_div ) MyDiv ( text = f 'typing will go here' , a = corner_div , model = [ d , 'text' ], repeat = repeat , initial_text = 'Yada Yada' ) repeat += 1 middle_input = jp . Input ( text = 'middle' , classes = 'absolute text-xl border-2 border-red-600' , placeholder = 'Type here' , style = 'top: 50%; left: 40%' , model = [ d , 'text' ], a = d ) return wp jp . justpy ( model_demo ) We add the two attributes repeat and initial_text to MyDiv . The first, repeat determines how many time the model value will be repeated in the text. We give each corner a different value.","title":"More complex model_update methods"},{"location":"tutorial/page_events/","text":"Page Events \u00b6 As of version 0.1.2 pages support three events: click - fires when page is clicked visibilitychange - fires when the page gains or loses visibility page_ready - fires after a page is ready with an established websocket connection Added in version 0.1.3: result_ready: fires when a result from the run_javascript method is available. In the first example below, page_ready is used to load a page with 3,000 Div elements in a staggered manner in order to improve the user experience. Try the '/stagger' route and see how it compares to the default. import justpy as jp import asyncio async def page_ready_div ( self , msg ): for i in range ( 1 , 3001 ): jp . Div ( text = f 'Div {i} ' , a = self . d , classes = 'border m-2 p-2 text-xs' ) if i % 100 == 0 : await self . update () await asyncio . sleep ( 0.25 ) @jp . SetRoute ( '/stagger' ) def loading_page_stagger_test (): wp = jp . WebPage () wp . on ( 'page_ready' , page_ready_div ) wp . d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) return wp def loading_page_no_stagger (): wp = jp . WebPage () wp . d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for i in range ( 1 , 3001 ): jp . Div ( text = f 'Div {i} ' , a = wp . d , classes = 'border m-2 p-2 text-xs' ) return wp jp . justpy ( loading_page_no_stagger ) In the following example the result of running JavaScript in the browser is obtained: import justpy as jp js_string = \"\"\" a = 3; b = 5; c = a * b; d = {r: c, appName: navigator.appName, appVersion: navigator.appVersion} \"\"\" async def page_ready ( self , msg ): jp . run_task ( self . run_javascript ( js_string )) async def result_ready ( self , msg ): msg . page . result_div . text = f 'The result is: {msg.result} ' def result_test (): wp = jp . WebPage () wp . on ( 'page_ready' , page_ready ) wp . on ( 'result_ready' , result_ready ) wp . result_div = jp . Div ( text = 'Result will go here' , classes = 'm-4 p-2 text-xl' , a = wp ) jp . Pre ( text = js_string , a = wp , classes = 'm-2 p-2 border' ) return wp jp . justpy ( result_test )","title":"Page Events"},{"location":"tutorial/page_events/#page-events","text":"As of version 0.1.2 pages support three events: click - fires when page is clicked visibilitychange - fires when the page gains or loses visibility page_ready - fires after a page is ready with an established websocket connection Added in version 0.1.3: result_ready: fires when a result from the run_javascript method is available. In the first example below, page_ready is used to load a page with 3,000 Div elements in a staggered manner in order to improve the user experience. Try the '/stagger' route and see how it compares to the default. import justpy as jp import asyncio async def page_ready_div ( self , msg ): for i in range ( 1 , 3001 ): jp . Div ( text = f 'Div {i} ' , a = self . d , classes = 'border m-2 p-2 text-xs' ) if i % 100 == 0 : await self . update () await asyncio . sleep ( 0.25 ) @jp . SetRoute ( '/stagger' ) def loading_page_stagger_test (): wp = jp . WebPage () wp . on ( 'page_ready' , page_ready_div ) wp . d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) return wp def loading_page_no_stagger (): wp = jp . WebPage () wp . d = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for i in range ( 1 , 3001 ): jp . Div ( text = f 'Div {i} ' , a = wp . d , classes = 'border m-2 p-2 text-xs' ) return wp jp . justpy ( loading_page_no_stagger ) In the following example the result of running JavaScript in the browser is obtained: import justpy as jp js_string = \"\"\" a = 3; b = 5; c = a * b; d = {r: c, appName: navigator.appName, appVersion: navigator.appVersion} \"\"\" async def page_ready ( self , msg ): jp . run_task ( self . run_javascript ( js_string )) async def result_ready ( self , msg ): msg . page . result_div . text = f 'The result is: {msg.result} ' def result_test (): wp = jp . WebPage () wp . on ( 'page_ready' , page_ready ) wp . on ( 'result_ready' , result_ready ) wp . result_div = jp . Div ( text = 'Result will go here' , classes = 'm-4 p-2 text-xl' , a = wp ) jp . Pre ( text = js_string , a = wp , classes = 'm-2 p-2 border' ) return wp jp . justpy ( result_test )","title":"Page Events"},{"location":"tutorial/plotly/","text":"Plotly Charts \u00b6 Plotly charts are supported by JustPy using the PlotlyChart component. Assign a plotly.graph_objects.Figure object to the chart attribute of a PlotlyChart instance or alternatively, assign a dict describing the chart to the chart_dict attribute. In the example below, a histogram is generated from random data and regenerated when with new random data when the users clicks a button. import justpy as jp import plotly.figure_factory as ff import numpy as np def create_chart ( numpoints ): x1 = np . random . randn ( numpoints ) - 2 x2 = np . random . randn ( numpoints ) x3 = np . random . randn ( numpoints ) + 2 # Group data together hist_data = [ x1 , x2 , x3 ] group_labels = [ 'Group 1' , 'Group 2' , 'Group 3' ] # Create display with custom bin_size fig = ff . create_distplot ( hist_data , group_labels , bin_size = [ . 1 , . 25 , . 5 ]) fig . update_layout ( width = 500 , height = 600 ) return fig def generate_data ( self , msg ): wp = msg . page wp . c . chart = create_chart ( wp . numpoints ) def plotly_test ( request ): wp = jp . WebPage () wp . numpoints = 500 jp . Button ( text = 'Generate New Data' , click = generate_data , a = wp , classes = jp . Styles . button_simple + ' m-2 p-2' ) wp . c = jp . PlotlyChart ( chart = create_chart ( wp . numpoints ), a = wp , classes = 'border m-2 p-6' , style = 'width: 600px' ) return wp jp . justpy ( plotly_test , PLOTLY = True )","title":"Plotly Charting"},{"location":"tutorial/plotly/#plotly-charts","text":"Plotly charts are supported by JustPy using the PlotlyChart component. Assign a plotly.graph_objects.Figure object to the chart attribute of a PlotlyChart instance or alternatively, assign a dict describing the chart to the chart_dict attribute. In the example below, a histogram is generated from random data and regenerated when with new random data when the users clicks a button. import justpy as jp import plotly.figure_factory as ff import numpy as np def create_chart ( numpoints ): x1 = np . random . randn ( numpoints ) - 2 x2 = np . random . randn ( numpoints ) x3 = np . random . randn ( numpoints ) + 2 # Group data together hist_data = [ x1 , x2 , x3 ] group_labels = [ 'Group 1' , 'Group 2' , 'Group 3' ] # Create display with custom bin_size fig = ff . create_distplot ( hist_data , group_labels , bin_size = [ . 1 , . 25 , . 5 ]) fig . update_layout ( width = 500 , height = 600 ) return fig def generate_data ( self , msg ): wp = msg . page wp . c . chart = create_chart ( wp . numpoints ) def plotly_test ( request ): wp = jp . WebPage () wp . numpoints = 500 jp . Button ( text = 'Generate New Data' , click = generate_data , a = wp , classes = jp . Styles . button_simple + ' m-2 p-2' ) wp . c = jp . PlotlyChart ( chart = create_chart ( wp . numpoints ), a = wp , classes = 'border m-2 p-6' , style = 'width: 600px' ) return wp jp . justpy ( plotly_test , PLOTLY = True )","title":"Plotly Charts"},{"location":"tutorial/pushing_data/","text":"Pushing Data to Web Pages \u00b6 The WebSocket API is an advanced technology that makes it possible to open a two-way interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply. - Mozilla.org JustPy uses this technology in order allow the server to \"push\" data to web pages. Here is an example of a program that implements a clock. Every second, the server pushes the updated time to all open web pages. Clock \u00b6 import justpy as jp import time import asyncio wp = jp . WebPage ( delete_flag = False ) clock_div = jp . Span ( text = 'Loading...' , classes = 'text-5xl m-1 p-1 bg-gray-300 font-mono' , a = wp ) async def clock_counter (): while True : clock_div . text = time . strftime ( \" %a , %d %b %Y, %H:%M:%S\" , time . localtime ()) jp . run_task ( wp . update ()) await asyncio . sleep ( 1 ) async def clock_init (): jp . run_task ( clock_counter ()) async def clock_test (): return wp jp . justpy ( clock_test , startup = clock_init ) The program first creates a WebPage instance called wp and Span instance called clock_div which is added to wp . Then we define a function called clock_counter . This function implements an infinite loop that changes the text of clock_div to the current time, updates wp and sleeps (in a non-blocking way) for one second. Every second, this loop is repeated. The WebPage instance wp is updated using the method update() . In order to understand what is happening, we need to make several distinctions. wp is an instance of the Python class WebPage wp can be the WebPage instance returned by several different requests, and in fact in our case, wp is always returned. All users get sent the same wp . This makes sense since the time is the same for everybody locally and we want to update it for everyone. However, each user has their own browser tab open. Also, the same user may have several browser tabs and windows open. There is therefore a one to many relation between wp and browser tabs and windows. wp may be rendered in many different tabs and windows (this is true for any instance of the class WebPage ). Each time an instance of WebPage is rendered in a browser tab, JustPy creates a websocket connection (channel) between the tab and the sever. Therefore, an instance of WebPage , such as wp , may have many different websockets associated with it, one for every open tab that has wp rendered in it. JustPy keeps track of all open websockets The update() method when applied to the page, retrieves all open websockets associated with the specific WebPage instance and uses them to change the specific browser tab they connect with. wp.update() updates all browser tabs that were rendered using wp . In JustPy, all the above is done by the framework without any need for developer intervention. What you need to remember is simply this: If requests from any number of users were returned the same instance of WebPage , any update to this instance will change the content for all these users. In our case, calling wp.update() will update all users since all requests result in wp being rendered (the function clock_test always returns wp ). It is important to remember that the update method is a coroutine and must run in the asyncio loop that the server runs on and therefore user functions that await this method must also be coroutines and defined using async. Once justpy has been called, the loop the server is running on can be accessed via JustPy.loop in case you need to do something more complex. Also asyncio.get_event_loop() will work if you haven\u2019t initiated other loops. If the previous paragraph reads like gibberish to you, I apologize. Explaining Python's asyncio is beyond the scope of this tutorial. If you don't need to develop applications that scale, don't worry about it. Just use the examples as templates. Let's review the program in detail. First, we create wp and clock_div as global variables. Then we define the coroutine clock_counter . It runs an infinite loop. The first line of the loop sets the text attribute of clock_div to be the current time and date (formatted to look a little nicer). The second line uses the JustPy helper utility run_task to run the coroutine update (it in fact schedules the coroutine to run as soon as possible). The third line causes clock_counter to suspend running for 1 second in a non-blocking way (all other coroutines can run while clock_counter sleeps). Next, we define the coroutine clock_init (it could be just a regular function since it does not await any coroutine in this specific case). We will see in a second how this function will be used. All it does is run clock_counter once the server loop is up and running. The last coroutine we define is clock_test . This is the function that handles all web requests. It just returns wp (it doesn\u2019t need to be a coroutine in this case, it would work as a regular function since it does not await any coroutines). The last line is the call to justpy . The keyword parameter startup allows us to designate a function to run once the server loop has been initiated. We cannot designate clock_counter as the startup function because the server is locked until the startup function terminates and clock_counter never terminates. Note When a JustPy event handler finishes running and returns None , JustPy calls the update method of the WebPage instance in which the event occurred. That is the reason that content in browser tabs gets updated after events automatically. If you don't want the page to update, return True or anything except for None . Collaborative Editor \u00b6 Run the following program: import justpy as jp wp = jp . QuasarPage ( delete_flag = False ) editor = jp . QEditor ( a = wp , kitchen_sink = True , height = '94vh' ) def joint_edit (): return wp jp . justpy ( joint_edit ) This program allows joint editing of a document. Open several browser tabs or different browsers on your local machine and start editing the document. Any change you make in one browser tab, is reflected immediately in all others. The program uses the component QEditor. This JustPy component was built using the Quasar QEditor Component (Quasar based JustPy components are described here ). Since the program renders wp , the same WebPage instance to all pages, they all share the same QEditor instance. QEditor supports the input event and therefore the keys pressed are sent to the server which in turn sets the value of the QEditor instance ( editor in our case) and then updates wp using the update method. Since wp is rendered in all browser tabs, they are all updated by JustPy. Simple Message Board \u00b6 JustPy allows updating just specific elements on the page and not the whole page. Here is an implementation of a simple message board in which just the Div with the messages is shared and updated. Load pages in different browser tabs and see the functionality (a message sent from one tab will show up in all the others). import justpy as jp from datetime import datetime input_classes = 'm-2 bg-gray-200 font-mono appearance-none border-2 border-gray-200 rounded py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-red-500' button_classes = 'm-2 p-2 text-red-700 bg-white hover:bg-red-200 hover:text-red-500 border focus:border-red-500 focus:outline-none' message_classes = 'ml-4 p-2 text-lg bg-red-500 text-white overflow-auto font-mono rounded-lg' shared_div = jp . Div ( classes = 'm-2 h-1/2 border overflow-auto' , delete_flag = False ) header = jp . Div ( text = 'Simple Message Board' , classes = 'bg-red-100 border-l-4 border-red-500 text-red-700 p-4 text-3xl' , delete_flag = False ) button_icon = jp . Icon ( icon = 'paper-plane' , classes = 'text-2xl' , delete_flag = False ) button_text = jp . Div ( text = 'Send' , classes = 'text-sm' , delete_flag = False ) message_icon = jp . Icon ( icon = 'comments' , classes = 'text-2xl text-green-600' , delete_flag = False ) def message_initialize (): # Called once on startup d = jp . Div ( a = shared_div , classes = 'flex m-2 border' ) time_stamp = jp . P ( text = datetime . now () . strftime ( '%Y-%m- %d %H:%M:%S' ), classes = 'text-xs ml-2 flex-shrink-0' ) p = jp . Pre ( text = 'Welcome to the simple message board!' , classes = message_classes ) d . add ( message_icon , time_stamp , p ) async def send_message ( self , msg ): if self . message . value : d = jp . Div ( classes = 'flex m-2 border' ) time_stamp = jp . P ( text = datetime . now () . strftime ( '%Y-%m- %d %H:%M:%S' ), classes = 'text-xs ml-2 flex-shrink-0' ) p = jp . Pre ( text = self . message . value , classes = message_classes ) d . add ( message_icon , time_stamp , p ) shared_div . add_component ( d , 0 ) self . message . value = '' # Clear message box after message is sent await shared_div . update () def message_demo (): wp = jp . WebPage () outer_div = jp . Div ( classes = 'flex flex-col h-screen' , a = wp ) outer_div . add ( header ) d = jp . Div ( classes = 'flex' , a = outer_div ) message = jp . Textarea ( placeholder = 'Enter message here' , a = d , classes = input_classes , debounce = 500 ) send_button = jp . Button ( a = d , click = send_message , classes = button_classes ) send_button . add ( button_icon , button_text ) outer_div . add ( shared_div ) shared_div . add_page ( wp ) send_button . message = message return wp jp . justpy ( message_demo , startup = message_initialize ) At the top of the program we define combinations of Tailwind classes to make our UI a little nicer. This technique, of defining classes in a global manner can be used to create templates for JustPy applications. Next, we create global components that will be shared by all web pages. We introduce the Icon component which is used to display icons from the free Fontawesome collection. Take a look at message_demo , the third function we define. All requests will be handled by this function. Each time it is called, it creates a new WebPage instance, wp . It adds a Div to it ( outer_div ). To this Div we add the predefined header Div and another Div which holds the message box and the button used to send messages. The button itself has two child components, the plane icon and the Div with the 'Send' text. We then add the shared message div to outer_div . The next line, shared_div.add_page(wp) , is important. We need to add wp to the dictionary of pages shared_div is on. When we call the update method of shared_div , it will use this dictionary to update the appropriate browser tabs. Note JustPy does not keep track automatically of which page an element is on. This would have introduced a lot of overhead since often, as in our case also, an element is indirectly added to a page by being added to an element that has been or will be added to a page. Let's take a closer look at send_message , the event handler that gets called when send_button is clicked. If the message box is not empty, the function creates a Div to which it adds an icon, a time stamp and the text of the message. It then adds the Div as the first element in shared_div . It clears the message box and then awaits the update method of shared_div . Only shared_div will be updated in all the WebPages it is on. All the other elements on the page will not be updated. Notice the send_message is a coroutine defined using the async keyword. This is the case because we need to await update from within send_message . The Final Countdown \u00b6 It is often required to call update several times within one event handler. For example, you may want to display a loading method while information is being retrieved from a database. Here is an exaggerated example: import justpy as jp import asyncio button_classes = 'm-2 p-2 text-red-700 bg-white hover:bg-red-200 hover:text-red-500 border focus:border-red-500 focus:outline-none' async def count_down ( self , msg ): self . show = False if hasattr ( msg . page , 'd' ): msg . page . remove ( msg . page . d ) bomb_icon = jp . Icon ( icon = 'bomb' , classes = 'inline-block text-5xl ml-1 mt-1' , a = msg . page ) d = jp . Div ( classes = 'text-center m-4 p-4 text-6xl text-red-600 bg-blue-500 faster' , a = msg . page , animation = self . count_animation ) msg . page . d = d for i in range ( self . start_num , 0 , - 1 ): d . text = str ( i ) await msg . page . update () await asyncio . sleep ( 1 ) d . text = 'Boom!' d . animation = 'zoomIn' d . set_classes ( 'text-red-500 bg-white' ) bomb_icon . set_class ( 'text-red-700' ) self . show = True def count_test ( request ): start_num = int ( request . query_params . get ( 'num' , 10 )) animation = request . query_params . get ( 'animation' , 'flip' ) wp = jp . WebPage () count_button = jp . Button ( text = 'Start Countdown' , classes = button_classes , a = wp , click = count_down ) count_button . start_num = start_num count_button . count_animation = animation return wp jp . justpy ( count_test ) When you press the countdown button, a countdown begins and the page is updated every second. Every JustPy component has a show attribute. If it is set to False , the component is not rendered. The first line in the count_down event handler sets the button's show attribute to False and it is not rendered during the countdown (in this way the user cannot accidentally initiate another countdown while one is going on). Then we remove from the page the Div with the current countdown (we check if the Div is stored on the page to handle the first countdown ). We create the Div and add it to the page and also store a reference to it under the d attribute of the page so we can later have easy access to it for removal. Then we loop from the countdown start number down to zero. In each loop iteration we set the text of d , update the page, and sleep 1 second using the asyncio library so as not to block countdowns on other pages. You can verify this by loading the page in different tabs or browsers. After the countdown loop has ended, we set the text of d to 'Boom!', change some of d 's classes and make the button visible again. Remember, that if an event handler returns None as in our case (the default in Python when no return statement is encountered), the framework updates the page. Therefore when count_down terminates the page is updated again and that is why we see the button and 'Boom!'. JustPy supports animation using the animate.css library. Just set the animation attribute of any component to a valid animation name. The default animation we use above is 'flip'. Try http://127.0.0.1:8000/?animation=bounceIn for example. You can test different animations using query parameters. You can set the animation speed by adding one of the classes slow, slower, fast, faster to the classes of the component. In this case we used 'faster' so that the animation takes less than 1 second.","title":"Pushing Data to Web Pages"},{"location":"tutorial/pushing_data/#pushing-data-to-web-pages","text":"The WebSocket API is an advanced technology that makes it possible to open a two-way interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply. - Mozilla.org JustPy uses this technology in order allow the server to \"push\" data to web pages. Here is an example of a program that implements a clock. Every second, the server pushes the updated time to all open web pages.","title":"Pushing Data to Web Pages"},{"location":"tutorial/pushing_data/#clock","text":"import justpy as jp import time import asyncio wp = jp . WebPage ( delete_flag = False ) clock_div = jp . Span ( text = 'Loading...' , classes = 'text-5xl m-1 p-1 bg-gray-300 font-mono' , a = wp ) async def clock_counter (): while True : clock_div . text = time . strftime ( \" %a , %d %b %Y, %H:%M:%S\" , time . localtime ()) jp . run_task ( wp . update ()) await asyncio . sleep ( 1 ) async def clock_init (): jp . run_task ( clock_counter ()) async def clock_test (): return wp jp . justpy ( clock_test , startup = clock_init ) The program first creates a WebPage instance called wp and Span instance called clock_div which is added to wp . Then we define a function called clock_counter . This function implements an infinite loop that changes the text of clock_div to the current time, updates wp and sleeps (in a non-blocking way) for one second. Every second, this loop is repeated. The WebPage instance wp is updated using the method update() . In order to understand what is happening, we need to make several distinctions. wp is an instance of the Python class WebPage wp can be the WebPage instance returned by several different requests, and in fact in our case, wp is always returned. All users get sent the same wp . This makes sense since the time is the same for everybody locally and we want to update it for everyone. However, each user has their own browser tab open. Also, the same user may have several browser tabs and windows open. There is therefore a one to many relation between wp and browser tabs and windows. wp may be rendered in many different tabs and windows (this is true for any instance of the class WebPage ). Each time an instance of WebPage is rendered in a browser tab, JustPy creates a websocket connection (channel) between the tab and the sever. Therefore, an instance of WebPage , such as wp , may have many different websockets associated with it, one for every open tab that has wp rendered in it. JustPy keeps track of all open websockets The update() method when applied to the page, retrieves all open websockets associated with the specific WebPage instance and uses them to change the specific browser tab they connect with. wp.update() updates all browser tabs that were rendered using wp . In JustPy, all the above is done by the framework without any need for developer intervention. What you need to remember is simply this: If requests from any number of users were returned the same instance of WebPage , any update to this instance will change the content for all these users. In our case, calling wp.update() will update all users since all requests result in wp being rendered (the function clock_test always returns wp ). It is important to remember that the update method is a coroutine and must run in the asyncio loop that the server runs on and therefore user functions that await this method must also be coroutines and defined using async. Once justpy has been called, the loop the server is running on can be accessed via JustPy.loop in case you need to do something more complex. Also asyncio.get_event_loop() will work if you haven\u2019t initiated other loops. If the previous paragraph reads like gibberish to you, I apologize. Explaining Python's asyncio is beyond the scope of this tutorial. If you don't need to develop applications that scale, don't worry about it. Just use the examples as templates. Let's review the program in detail. First, we create wp and clock_div as global variables. Then we define the coroutine clock_counter . It runs an infinite loop. The first line of the loop sets the text attribute of clock_div to be the current time and date (formatted to look a little nicer). The second line uses the JustPy helper utility run_task to run the coroutine update (it in fact schedules the coroutine to run as soon as possible). The third line causes clock_counter to suspend running for 1 second in a non-blocking way (all other coroutines can run while clock_counter sleeps). Next, we define the coroutine clock_init (it could be just a regular function since it does not await any coroutine in this specific case). We will see in a second how this function will be used. All it does is run clock_counter once the server loop is up and running. The last coroutine we define is clock_test . This is the function that handles all web requests. It just returns wp (it doesn\u2019t need to be a coroutine in this case, it would work as a regular function since it does not await any coroutines). The last line is the call to justpy . The keyword parameter startup allows us to designate a function to run once the server loop has been initiated. We cannot designate clock_counter as the startup function because the server is locked until the startup function terminates and clock_counter never terminates. Note When a JustPy event handler finishes running and returns None , JustPy calls the update method of the WebPage instance in which the event occurred. That is the reason that content in browser tabs gets updated after events automatically. If you don't want the page to update, return True or anything except for None .","title":"Clock"},{"location":"tutorial/pushing_data/#collaborative-editor","text":"Run the following program: import justpy as jp wp = jp . QuasarPage ( delete_flag = False ) editor = jp . QEditor ( a = wp , kitchen_sink = True , height = '94vh' ) def joint_edit (): return wp jp . justpy ( joint_edit ) This program allows joint editing of a document. Open several browser tabs or different browsers on your local machine and start editing the document. Any change you make in one browser tab, is reflected immediately in all others. The program uses the component QEditor. This JustPy component was built using the Quasar QEditor Component (Quasar based JustPy components are described here ). Since the program renders wp , the same WebPage instance to all pages, they all share the same QEditor instance. QEditor supports the input event and therefore the keys pressed are sent to the server which in turn sets the value of the QEditor instance ( editor in our case) and then updates wp using the update method. Since wp is rendered in all browser tabs, they are all updated by JustPy.","title":"Collaborative Editor"},{"location":"tutorial/pushing_data/#simple-message-board","text":"JustPy allows updating just specific elements on the page and not the whole page. Here is an implementation of a simple message board in which just the Div with the messages is shared and updated. Load pages in different browser tabs and see the functionality (a message sent from one tab will show up in all the others). import justpy as jp from datetime import datetime input_classes = 'm-2 bg-gray-200 font-mono appearance-none border-2 border-gray-200 rounded py-2 px-4 text-gray-700 focus:outline-none focus:bg-white focus:border-red-500' button_classes = 'm-2 p-2 text-red-700 bg-white hover:bg-red-200 hover:text-red-500 border focus:border-red-500 focus:outline-none' message_classes = 'ml-4 p-2 text-lg bg-red-500 text-white overflow-auto font-mono rounded-lg' shared_div = jp . Div ( classes = 'm-2 h-1/2 border overflow-auto' , delete_flag = False ) header = jp . Div ( text = 'Simple Message Board' , classes = 'bg-red-100 border-l-4 border-red-500 text-red-700 p-4 text-3xl' , delete_flag = False ) button_icon = jp . Icon ( icon = 'paper-plane' , classes = 'text-2xl' , delete_flag = False ) button_text = jp . Div ( text = 'Send' , classes = 'text-sm' , delete_flag = False ) message_icon = jp . Icon ( icon = 'comments' , classes = 'text-2xl text-green-600' , delete_flag = False ) def message_initialize (): # Called once on startup d = jp . Div ( a = shared_div , classes = 'flex m-2 border' ) time_stamp = jp . P ( text = datetime . now () . strftime ( '%Y-%m- %d %H:%M:%S' ), classes = 'text-xs ml-2 flex-shrink-0' ) p = jp . Pre ( text = 'Welcome to the simple message board!' , classes = message_classes ) d . add ( message_icon , time_stamp , p ) async def send_message ( self , msg ): if self . message . value : d = jp . Div ( classes = 'flex m-2 border' ) time_stamp = jp . P ( text = datetime . now () . strftime ( '%Y-%m- %d %H:%M:%S' ), classes = 'text-xs ml-2 flex-shrink-0' ) p = jp . Pre ( text = self . message . value , classes = message_classes ) d . add ( message_icon , time_stamp , p ) shared_div . add_component ( d , 0 ) self . message . value = '' # Clear message box after message is sent await shared_div . update () def message_demo (): wp = jp . WebPage () outer_div = jp . Div ( classes = 'flex flex-col h-screen' , a = wp ) outer_div . add ( header ) d = jp . Div ( classes = 'flex' , a = outer_div ) message = jp . Textarea ( placeholder = 'Enter message here' , a = d , classes = input_classes , debounce = 500 ) send_button = jp . Button ( a = d , click = send_message , classes = button_classes ) send_button . add ( button_icon , button_text ) outer_div . add ( shared_div ) shared_div . add_page ( wp ) send_button . message = message return wp jp . justpy ( message_demo , startup = message_initialize ) At the top of the program we define combinations of Tailwind classes to make our UI a little nicer. This technique, of defining classes in a global manner can be used to create templates for JustPy applications. Next, we create global components that will be shared by all web pages. We introduce the Icon component which is used to display icons from the free Fontawesome collection. Take a look at message_demo , the third function we define. All requests will be handled by this function. Each time it is called, it creates a new WebPage instance, wp . It adds a Div to it ( outer_div ). To this Div we add the predefined header Div and another Div which holds the message box and the button used to send messages. The button itself has two child components, the plane icon and the Div with the 'Send' text. We then add the shared message div to outer_div . The next line, shared_div.add_page(wp) , is important. We need to add wp to the dictionary of pages shared_div is on. When we call the update method of shared_div , it will use this dictionary to update the appropriate browser tabs. Note JustPy does not keep track automatically of which page an element is on. This would have introduced a lot of overhead since often, as in our case also, an element is indirectly added to a page by being added to an element that has been or will be added to a page. Let's take a closer look at send_message , the event handler that gets called when send_button is clicked. If the message box is not empty, the function creates a Div to which it adds an icon, a time stamp and the text of the message. It then adds the Div as the first element in shared_div . It clears the message box and then awaits the update method of shared_div . Only shared_div will be updated in all the WebPages it is on. All the other elements on the page will not be updated. Notice the send_message is a coroutine defined using the async keyword. This is the case because we need to await update from within send_message .","title":"Simple Message Board"},{"location":"tutorial/pushing_data/#the-final-countdown","text":"It is often required to call update several times within one event handler. For example, you may want to display a loading method while information is being retrieved from a database. Here is an exaggerated example: import justpy as jp import asyncio button_classes = 'm-2 p-2 text-red-700 bg-white hover:bg-red-200 hover:text-red-500 border focus:border-red-500 focus:outline-none' async def count_down ( self , msg ): self . show = False if hasattr ( msg . page , 'd' ): msg . page . remove ( msg . page . d ) bomb_icon = jp . Icon ( icon = 'bomb' , classes = 'inline-block text-5xl ml-1 mt-1' , a = msg . page ) d = jp . Div ( classes = 'text-center m-4 p-4 text-6xl text-red-600 bg-blue-500 faster' , a = msg . page , animation = self . count_animation ) msg . page . d = d for i in range ( self . start_num , 0 , - 1 ): d . text = str ( i ) await msg . page . update () await asyncio . sleep ( 1 ) d . text = 'Boom!' d . animation = 'zoomIn' d . set_classes ( 'text-red-500 bg-white' ) bomb_icon . set_class ( 'text-red-700' ) self . show = True def count_test ( request ): start_num = int ( request . query_params . get ( 'num' , 10 )) animation = request . query_params . get ( 'animation' , 'flip' ) wp = jp . WebPage () count_button = jp . Button ( text = 'Start Countdown' , classes = button_classes , a = wp , click = count_down ) count_button . start_num = start_num count_button . count_animation = animation return wp jp . justpy ( count_test ) When you press the countdown button, a countdown begins and the page is updated every second. Every JustPy component has a show attribute. If it is set to False , the component is not rendered. The first line in the count_down event handler sets the button's show attribute to False and it is not rendered during the countdown (in this way the user cannot accidentally initiate another countdown while one is going on). Then we remove from the page the Div with the current countdown (we check if the Div is stored on the page to handle the first countdown ). We create the Div and add it to the page and also store a reference to it under the d attribute of the page so we can later have easy access to it for removal. Then we loop from the countdown start number down to zero. In each loop iteration we set the text of d , update the page, and sleep 1 second using the asyncio library so as not to block countdowns on other pages. You can verify this by loading the page in different tabs or browsers. After the countdown loop has ended, we set the text of d to 'Boom!', change some of d 's classes and make the button visible again. Remember, that if an event handler returns None as in our case (the default in Python when no return statement is encountered), the framework updates the page. Therefore when count_down terminates the page is updated again and that is why we see the button and 'Boom!'. JustPy supports animation using the animate.css library. Just set the animation attribute of any component to a valid animation name. The default animation we use above is 'flip'. Try http://127.0.0.1:8000/?animation=bounceIn for example. You can test different animations using query parameters. You can set the animation speed by adding one of the classes slow, slower, fast, faster to the classes of the component. In this case we used 'faster' so that the animation takes less than 1 second.","title":"The Final Countdown"},{"location":"tutorial/pydeck/","text":"Pydeck Visualizations \u00b6 Pydeck visualizations are supported by JustPy using the PyDeckFrame component. Set the deck attribute of the PyDeckFrame instance to a pydeck deck As its name implies, the component inserts a HTML frame in the page which includes the HTML produced by the to_html() method of Deck . The component also supports a transition_duration attribute. When a visualization changes, this attribute determines the time length of the transition between the old frame and the new frame. The time is designated in seconds and the default is 0.1 seconds. The example below is based on a streamlit demo app Warning You need to obtain a mapbox api token to have the data render on map tiles # This example is based on a streamlit app: https://github.com/streamlit/demo-uber-nyc-pickups import justpy as jp import pandas as pd import numpy as np import pydeck as pdk try : import altair as alt _has_altair = True except : _has_altair = False DATE_TIME = \"date/time\" DATA_URL = ( \"http://s3-us-west-2.amazonaws.com/streamlit-demo-data/uber-raw-data-sep14.csv.gz\" ) def load_data ( nrows ): data = pd . read_csv ( DATA_URL , nrows = nrows ) lowercase = lambda x : str ( x ) . lower () data . rename ( lowercase , axis = \"columns\" , inplace = True ) data [ DATE_TIME ] = pd . to_datetime ( data [ DATE_TIME ]) return data data = load_data ( 100000 ) lowercase = lambda x : str ( x ) . lower () data . rename ( lowercase , axis = \"columns\" , inplace = True ) data [ DATE_TIME ] = pd . to_datetime ( data [ DATE_TIME ]) def map_deck ( data , lat , lon , zoom ): deck = ( pdk . Deck ( # https://docs.mapbox.com/help/getting-started/access-tokens/ api_keys = { 'mapbox' : 'Insert your mapbox api token here' }, map_provider = 'mapbox' , map_style = \"light\" , initial_view_state = { \"latitude\" : lat , \"longitude\" : lon , \"zoom\" : zoom , \"pitch\" : 50 , }, layers = [ pdk . Layer ( \"HexagonLayer\" , data = data , get_position = [ \"lon\" , \"lat\" ], radius = 100 , elevation_scale = 4 , elevation_range = [ 0 , 1000 ], pickable = True , extruded = True , ), ] )) return deck airports = { 'La Guardia' : [ 40.7900 , - 73.8700 ], 'JFK' : [ 40.6650 , - 73.7821 ], 'Newark' : [ 40.7090 , - 74.1805 ] } zoom_level_airports = 12 zoom_level_main = 11 midpoint = ( np . average ( data [ \"lat\" ]), np . average ( data [ \"lon\" ])) def create_histogram ( hour_selected ): filtered = data [ ( data [ DATE_TIME ] . dt . hour >= hour_selected ) & ( data [ DATE_TIME ] . dt . hour < ( hour_selected + 1 )) ] hist = np . histogram ( filtered [ DATE_TIME ] . dt . minute , bins = 60 , range = ( 0 , 60 ))[ 0 ] chart_data = pd . DataFrame ({ \"minute\" : range ( 60 ), \"pickups\" : hist }) chart = alt . Chart ( chart_data ) . mark_area ( interpolate = 'step-after' , ) . encode ( x = alt . X ( \"minute:Q\" , scale = alt . Scale ( nice = False )), y = alt . Y ( \"pickups:Q\" ), tooltip = [ 'minute' , 'pickups' ] ) . configure_mark ( opacity = 0.5 , color = 'red' ) . properties ( width = 'container' , height = 200 ) return chart async def slider_change ( self , msg ): wp = msg . page hour = int ( self . value ) wp . all_caption . text = f 'All New York City from {hour} :00 to {hour+1}:00' hour_data = data [ data [ DATE_TIME ] . dt . hour == hour ] wp . decks [ 'main' ] . deck = map_deck ( hour_data , midpoint [ 0 ], midpoint [ 1 ], zoom_level_main ) for airport , coords in airports . items (): wp . decks [ airport ] . deck = map_deck ( hour_data , coords [ 0 ], coords [ 1 ], zoom_level_airports ) if _has_altair : wp . histogram . chart = create_histogram ( self . value ) wp . histogram_caption . text = f 'Breakdown of rides per minute between {hour} :00 and {hour+1}:00' def pydeck_demo ( request ): wp = jp . QuasarPage ( tailwind = True , title = 'Uber NYC Pickups' ) wp . decks = {} slider_div = jp . Div ( a = wp , classes = 'flex ml-4' , style = 'width: 50%; margin-top: 20px' ) jp . Div ( text = 'Select hour of pickup:' , a = slider_div , classes = 'pt-3 text-xl font-bold ' ) s1 = jp . Span ( classes = 'ml-6 mt-1' , style = 'width: 50%' , a = slider_div ) jp . QSlider ( classes = 'w-64' , min = 0 , max = 23 , a = s1 , label = True , label_always = True , markers = True , step = 1 , snap = True , color = 'red' , change = slider_change ) deck_div = jp . Div ( classes = 'flex ml-2' , a = wp ) hour_data = data [ data [ DATE_TIME ] . dt . hour == int ( 0 )] deck = map_deck ( hour_data , midpoint [ 0 ], midpoint [ 1 ], zoom_level_main ) all_div = jp . Div ( a = deck_div ) wp . all_caption = jp . Div ( text = 'All New York City from 0:00 to 1:00' , a = all_div , style = 'margin: 10px;' , classes = 'text-xl font-bold' ) wp . decks [ 'main' ] = jp . PyDeckFrame ( a = all_div , deck = deck , style = 'margin: 10px; height: 400px; width: 450px' , transition_duration = 0.5 ) for airport , coords in airports . items (): airport_deck = map_deck ( hour_data , coords [ 0 ], coords [ 1 ], zoom_level_airports ) airport_div = jp . Div ( a = deck_div ) jp . Div ( text = f ' {airport} Airport' , a = airport_div , style = 'margin: 10px;' , classes = 'text-xl font-bold' ) wp . decks [ airport ] = jp . PyDeckFrame ( a = airport_div , deck = airport_deck , style = 'margin: 10px; height: 400px; width: 250px' , transition_duration = 0.5 ) if _has_altair : chart = create_histogram ( 0 ) wp . histogram_caption = jp . Div ( text = 'Breakdown of rides per minute between 0:00 and 1:00' , a = wp , style = 'margin-left: 30px;' , classes = 'text-xl font-bold' ) wp . histogram = jp . AltairChart ( chart = chart , a = wp , style = 'padding: 10px; width: 100%;' ) return wp jp . justpy ( pydeck_demo , VEGA = True )","title":"Pydeck Visualizations"},{"location":"tutorial/pydeck/#pydeck-visualizations","text":"Pydeck visualizations are supported by JustPy using the PyDeckFrame component. Set the deck attribute of the PyDeckFrame instance to a pydeck deck As its name implies, the component inserts a HTML frame in the page which includes the HTML produced by the to_html() method of Deck . The component also supports a transition_duration attribute. When a visualization changes, this attribute determines the time length of the transition between the old frame and the new frame. The time is designated in seconds and the default is 0.1 seconds. The example below is based on a streamlit demo app Warning You need to obtain a mapbox api token to have the data render on map tiles # This example is based on a streamlit app: https://github.com/streamlit/demo-uber-nyc-pickups import justpy as jp import pandas as pd import numpy as np import pydeck as pdk try : import altair as alt _has_altair = True except : _has_altair = False DATE_TIME = \"date/time\" DATA_URL = ( \"http://s3-us-west-2.amazonaws.com/streamlit-demo-data/uber-raw-data-sep14.csv.gz\" ) def load_data ( nrows ): data = pd . read_csv ( DATA_URL , nrows = nrows ) lowercase = lambda x : str ( x ) . lower () data . rename ( lowercase , axis = \"columns\" , inplace = True ) data [ DATE_TIME ] = pd . to_datetime ( data [ DATE_TIME ]) return data data = load_data ( 100000 ) lowercase = lambda x : str ( x ) . lower () data . rename ( lowercase , axis = \"columns\" , inplace = True ) data [ DATE_TIME ] = pd . to_datetime ( data [ DATE_TIME ]) def map_deck ( data , lat , lon , zoom ): deck = ( pdk . Deck ( # https://docs.mapbox.com/help/getting-started/access-tokens/ api_keys = { 'mapbox' : 'Insert your mapbox api token here' }, map_provider = 'mapbox' , map_style = \"light\" , initial_view_state = { \"latitude\" : lat , \"longitude\" : lon , \"zoom\" : zoom , \"pitch\" : 50 , }, layers = [ pdk . Layer ( \"HexagonLayer\" , data = data , get_position = [ \"lon\" , \"lat\" ], radius = 100 , elevation_scale = 4 , elevation_range = [ 0 , 1000 ], pickable = True , extruded = True , ), ] )) return deck airports = { 'La Guardia' : [ 40.7900 , - 73.8700 ], 'JFK' : [ 40.6650 , - 73.7821 ], 'Newark' : [ 40.7090 , - 74.1805 ] } zoom_level_airports = 12 zoom_level_main = 11 midpoint = ( np . average ( data [ \"lat\" ]), np . average ( data [ \"lon\" ])) def create_histogram ( hour_selected ): filtered = data [ ( data [ DATE_TIME ] . dt . hour >= hour_selected ) & ( data [ DATE_TIME ] . dt . hour < ( hour_selected + 1 )) ] hist = np . histogram ( filtered [ DATE_TIME ] . dt . minute , bins = 60 , range = ( 0 , 60 ))[ 0 ] chart_data = pd . DataFrame ({ \"minute\" : range ( 60 ), \"pickups\" : hist }) chart = alt . Chart ( chart_data ) . mark_area ( interpolate = 'step-after' , ) . encode ( x = alt . X ( \"minute:Q\" , scale = alt . Scale ( nice = False )), y = alt . Y ( \"pickups:Q\" ), tooltip = [ 'minute' , 'pickups' ] ) . configure_mark ( opacity = 0.5 , color = 'red' ) . properties ( width = 'container' , height = 200 ) return chart async def slider_change ( self , msg ): wp = msg . page hour = int ( self . value ) wp . all_caption . text = f 'All New York City from {hour} :00 to {hour+1}:00' hour_data = data [ data [ DATE_TIME ] . dt . hour == hour ] wp . decks [ 'main' ] . deck = map_deck ( hour_data , midpoint [ 0 ], midpoint [ 1 ], zoom_level_main ) for airport , coords in airports . items (): wp . decks [ airport ] . deck = map_deck ( hour_data , coords [ 0 ], coords [ 1 ], zoom_level_airports ) if _has_altair : wp . histogram . chart = create_histogram ( self . value ) wp . histogram_caption . text = f 'Breakdown of rides per minute between {hour} :00 and {hour+1}:00' def pydeck_demo ( request ): wp = jp . QuasarPage ( tailwind = True , title = 'Uber NYC Pickups' ) wp . decks = {} slider_div = jp . Div ( a = wp , classes = 'flex ml-4' , style = 'width: 50%; margin-top: 20px' ) jp . Div ( text = 'Select hour of pickup:' , a = slider_div , classes = 'pt-3 text-xl font-bold ' ) s1 = jp . Span ( classes = 'ml-6 mt-1' , style = 'width: 50%' , a = slider_div ) jp . QSlider ( classes = 'w-64' , min = 0 , max = 23 , a = s1 , label = True , label_always = True , markers = True , step = 1 , snap = True , color = 'red' , change = slider_change ) deck_div = jp . Div ( classes = 'flex ml-2' , a = wp ) hour_data = data [ data [ DATE_TIME ] . dt . hour == int ( 0 )] deck = map_deck ( hour_data , midpoint [ 0 ], midpoint [ 1 ], zoom_level_main ) all_div = jp . Div ( a = deck_div ) wp . all_caption = jp . Div ( text = 'All New York City from 0:00 to 1:00' , a = all_div , style = 'margin: 10px;' , classes = 'text-xl font-bold' ) wp . decks [ 'main' ] = jp . PyDeckFrame ( a = all_div , deck = deck , style = 'margin: 10px; height: 400px; width: 450px' , transition_duration = 0.5 ) for airport , coords in airports . items (): airport_deck = map_deck ( hour_data , coords [ 0 ], coords [ 1 ], zoom_level_airports ) airport_div = jp . Div ( a = deck_div ) jp . Div ( text = f ' {airport} Airport' , a = airport_div , style = 'margin: 10px;' , classes = 'text-xl font-bold' ) wp . decks [ airport ] = jp . PyDeckFrame ( a = airport_div , deck = airport_deck , style = 'margin: 10px; height: 400px; width: 250px' , transition_duration = 0.5 ) if _has_altair : chart = create_histogram ( 0 ) wp . histogram_caption = jp . Div ( text = 'Breakdown of rides per minute between 0:00 and 1:00' , a = wp , style = 'margin-left: 30px;' , classes = 'text-xl font-bold' ) wp . histogram = jp . AltairChart ( chart = chart , a = wp , style = 'padding: 10px; width: 100%;' ) return wp jp . justpy ( pydeck_demo , VEGA = True )","title":"Pydeck Visualizations"},{"location":"tutorial/request_object/","text":"The Request Object \u00b6 JustPy request handlers (functions that handle requests) can receive an optional argument, the request object . Whenever JustPy needs to run a request handler, it checks first if it is defined with an argument and if that is the case, JustPy provides the request object as the argument. URL Parameters \u00b6 URLs may include a query string with parameters: www.example.com/?num=4&name=Joe In this example the URL includes two parameters, num and name with values of 4 and 'Joe'. The request object includes (among other things) information about the URL parameters. Below is a simple program that displays a page with the parameters in the URL. Try http://127.0.0.1:8000/?number=5&name=Smith for example. import justpy as jp def demo_function ( request ): wp = jp . WebPage () if len ( request . query_params ) > 0 : for key , value in request . query_params . items (): jp . P ( text = f ' {key} : {value} ' , a = wp , classes = 'text-xl m-2 p-1' ) else : jp . P ( text = 'No URL paramaters present' , a = wp , classes = 'text-xl m-2 p-1' ) return wp jp . justpy ( demo_function ) The request object has several attributes. One of them is the Python dictionary request.query_params which includes the keys and values of the URL parameters. In the program above we iterate over this dictionary and add to the page all the keys and their corresponding values. Dog Example \u00b6 Let's do something a little more useful (well, at least more entertaining). The site https://dog.ceo provides pictures of dogs using a simple API . Please run the following program and load a browser page without any parameters in the URL: import justpy as jp async def dog_pic ( request ): wp = jp . WebPage () breed = request . query_params . get ( 'breed' , 'papillon' ) r = await jp . get ( f 'https://dog.ceo/api/breed/ {breed} /images/random' ) img_url = r [ 'message' ] jp . Img ( src = img_url , a = wp , classes = 'm-2 p-2' ) return wp jp . justpy ( dog_pic ) After a few seconds, you should see a picture of a papillon . That is the default dog breed to show (now you know the breed of my two dogs). Each time you reload the page you will get a different picture as we are asking the site for a random image. Try changing the breed of the dogs in the picture by specifying the breed parameter in the URL, for example: http://127.0.0.1:8000/?breed=corgi Let's examine the program. First, notice how we define dog_pic as an async function (if you don't know what async functions are in Python just skip this paragraph and the next). JustPy uses starlette.io , \"a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services\". To shield users from the complexities of async programming in Python, JustPy allows both functions that handle requests and functions that handle events to be either async or not. The framework checks if a function is a coroutine and runs it accordingly. When a request or event handler require I/O operations over the internet (or to access a local database or even file), it is recommended that they be of type async and that all I/O and database operations be non-blocking (this means they are run as a coroutine or in another thread). Otherwise, the application will not scale. To help with the simple case of using an API with the HTTP GET method, JustPy provides a helper function conveniently called get . The function asynchronously retrieves information which (by default in JSON format) and converts it to a Python dictionary. In the program above we call the get function with the appropriate URL. We are requesting the URL for a random image of dog with a certain breed. That URL can be found under the 'message' key in the dictionary r . We then add an image to the page using the Img class which corresponds to the HTML img tag. The src attribute is then set to the URL of the image. Finally, we return the page which the framework will then render. Dog Example with Image Click \u00b6 As the program is currently written, to get a new image we need to reload the page. Let's change this so that by clicking on the image, a new one is loaded: import justpy as jp async def get_image ( self , msg ): r = await jp . get ( f 'https://dog.ceo/api/breed/ {msg.page.breed} /images/random' ) self . src = r [ 'message' ] async def dog_pic ( request ): wp = jp . WebPage () breed = request . query_params . get ( 'breed' , 'papillon' ) wp . breed = breed r = await jp . get ( f 'https://dog.ceo/api/breed/ {breed} /images/random' ) img_url = r [ 'message' ] jp . Img ( src = img_url , a = wp , classes = 'm-2 p-2 cursor-pointer' , click = get_image ) return wp jp . justpy ( dog_pic ) We added the function get_image and assigned the image's click event to it . We also made a small design change by adding 'cursor-pointer' to the classes of the image. When the mouse cursor enters the image, it will change its shape to indicate that the image can be interacted with. Notice how we also assigned the breed to a page attribute so that get_image will have direct access to it via msg.page.breed . Path Parameters \u00b6 JustPy also supports path parameters in addition to URL query parameters. Let's change the example above so that the breed is determined by the path in the URL: import justpy as jp async def get_image ( self , msg ): r = await jp . get ( f 'https://dog.ceo/api/breed/ {msg.page.breed} /images/random' ) self . src = r [ 'message' ] @jp . SetRoute ( '/breed/ {breed} ' ) async def dog_pic ( request ): wp = jp . WebPage () breed = request . path_params . get ( 'breed' , 'papillon' ) wp . breed = breed r = await jp . get ( f 'https://dog.ceo/api/breed/ {breed} /images/random' ) img_url = r [ 'message' ] jp . Img ( src = img_url , a = wp , classes = 'm-2 p-2 cursor-pointer' , click = get_image ) return wp jp . justpy ( dog_pic ) Try going to http://127.0.0.1:8000/breed/borzoi or http://127.0.0.1:8000/breed/boxer Path parameters are defined by surrounding them with {} in the path. If JustPy can match the path to the URL, it executes the function and provides the path parameters in the dictionary request.path_params . To learn more about the different options with path parameters go to https://www.starlette.io/routing/","title":"The Request Object"},{"location":"tutorial/request_object/#the-request-object","text":"JustPy request handlers (functions that handle requests) can receive an optional argument, the request object . Whenever JustPy needs to run a request handler, it checks first if it is defined with an argument and if that is the case, JustPy provides the request object as the argument.","title":"The Request Object"},{"location":"tutorial/request_object/#url-parameters","text":"URLs may include a query string with parameters: www.example.com/?num=4&name=Joe In this example the URL includes two parameters, num and name with values of 4 and 'Joe'. The request object includes (among other things) information about the URL parameters. Below is a simple program that displays a page with the parameters in the URL. Try http://127.0.0.1:8000/?number=5&name=Smith for example. import justpy as jp def demo_function ( request ): wp = jp . WebPage () if len ( request . query_params ) > 0 : for key , value in request . query_params . items (): jp . P ( text = f ' {key} : {value} ' , a = wp , classes = 'text-xl m-2 p-1' ) else : jp . P ( text = 'No URL paramaters present' , a = wp , classes = 'text-xl m-2 p-1' ) return wp jp . justpy ( demo_function ) The request object has several attributes. One of them is the Python dictionary request.query_params which includes the keys and values of the URL parameters. In the program above we iterate over this dictionary and add to the page all the keys and their corresponding values.","title":"URL Parameters"},{"location":"tutorial/request_object/#dog-example","text":"Let's do something a little more useful (well, at least more entertaining). The site https://dog.ceo provides pictures of dogs using a simple API . Please run the following program and load a browser page without any parameters in the URL: import justpy as jp async def dog_pic ( request ): wp = jp . WebPage () breed = request . query_params . get ( 'breed' , 'papillon' ) r = await jp . get ( f 'https://dog.ceo/api/breed/ {breed} /images/random' ) img_url = r [ 'message' ] jp . Img ( src = img_url , a = wp , classes = 'm-2 p-2' ) return wp jp . justpy ( dog_pic ) After a few seconds, you should see a picture of a papillon . That is the default dog breed to show (now you know the breed of my two dogs). Each time you reload the page you will get a different picture as we are asking the site for a random image. Try changing the breed of the dogs in the picture by specifying the breed parameter in the URL, for example: http://127.0.0.1:8000/?breed=corgi Let's examine the program. First, notice how we define dog_pic as an async function (if you don't know what async functions are in Python just skip this paragraph and the next). JustPy uses starlette.io , \"a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services\". To shield users from the complexities of async programming in Python, JustPy allows both functions that handle requests and functions that handle events to be either async or not. The framework checks if a function is a coroutine and runs it accordingly. When a request or event handler require I/O operations over the internet (or to access a local database or even file), it is recommended that they be of type async and that all I/O and database operations be non-blocking (this means they are run as a coroutine or in another thread). Otherwise, the application will not scale. To help with the simple case of using an API with the HTTP GET method, JustPy provides a helper function conveniently called get . The function asynchronously retrieves information which (by default in JSON format) and converts it to a Python dictionary. In the program above we call the get function with the appropriate URL. We are requesting the URL for a random image of dog with a certain breed. That URL can be found under the 'message' key in the dictionary r . We then add an image to the page using the Img class which corresponds to the HTML img tag. The src attribute is then set to the URL of the image. Finally, we return the page which the framework will then render.","title":"Dog Example"},{"location":"tutorial/request_object/#dog-example-with-image-click","text":"As the program is currently written, to get a new image we need to reload the page. Let's change this so that by clicking on the image, a new one is loaded: import justpy as jp async def get_image ( self , msg ): r = await jp . get ( f 'https://dog.ceo/api/breed/ {msg.page.breed} /images/random' ) self . src = r [ 'message' ] async def dog_pic ( request ): wp = jp . WebPage () breed = request . query_params . get ( 'breed' , 'papillon' ) wp . breed = breed r = await jp . get ( f 'https://dog.ceo/api/breed/ {breed} /images/random' ) img_url = r [ 'message' ] jp . Img ( src = img_url , a = wp , classes = 'm-2 p-2 cursor-pointer' , click = get_image ) return wp jp . justpy ( dog_pic ) We added the function get_image and assigned the image's click event to it . We also made a small design change by adding 'cursor-pointer' to the classes of the image. When the mouse cursor enters the image, it will change its shape to indicate that the image can be interacted with. Notice how we also assigned the breed to a page attribute so that get_image will have direct access to it via msg.page.breed .","title":"Dog Example with Image Click"},{"location":"tutorial/request_object/#path-parameters","text":"JustPy also supports path parameters in addition to URL query parameters. Let's change the example above so that the breed is determined by the path in the URL: import justpy as jp async def get_image ( self , msg ): r = await jp . get ( f 'https://dog.ceo/api/breed/ {msg.page.breed} /images/random' ) self . src = r [ 'message' ] @jp . SetRoute ( '/breed/ {breed} ' ) async def dog_pic ( request ): wp = jp . WebPage () breed = request . path_params . get ( 'breed' , 'papillon' ) wp . breed = breed r = await jp . get ( f 'https://dog.ceo/api/breed/ {breed} /images/random' ) img_url = r [ 'message' ] jp . Img ( src = img_url , a = wp , classes = 'm-2 p-2 cursor-pointer' , click = get_image ) return wp jp . justpy ( dog_pic ) Try going to http://127.0.0.1:8000/breed/borzoi or http://127.0.0.1:8000/breed/boxer Path parameters are defined by surrounding them with {} in the path. If JustPy can match the path to the URL, it executes the function and provides the path parameters in the dictionary request.path_params . To learn more about the different options with path parameters go to https://www.starlette.io/routing/","title":"Path Parameters"},{"location":"tutorial/routes/","text":"Routes \u00b6 The Basics \u00b6 In all the examples above, any URL typed into the browser would render the same page. Usually, when we develop a web application, we want different URLs to load different pages. In other words, we want to define different request handlers to handle different URLs. In this part of the tutorial we will show how to do this using JustPy. Please run the following program: import justpy as jp def hello_function (): wp = jp . WebPage () wp . add ( jp . P ( text = 'Hello there!' , classes = 'text-5xl m-2' )) return wp jp . Route ( '/hello' , hello_function ) jp . justpy () Unless you go specifically to http://127.0.0.1:8000/hello you will get the 'Page not found' JustPy message. When a request arrives, JustPy checks if the route in the URL matches any of the defined routes. If it does, it runs the appropriate function and if not, it runs the function provided as the argument of justpy. If no argument is provided to justpy , the framework shows the 'Page not found' message. Try running the following program: import justpy as jp def hello_function (): wp = jp . WebPage () wp . add ( jp . P ( text = 'Hello there!' , classes = 'text-5xl m-2' )) return wp def bye_function (): wp = jp . WebPage () wp . add ( jp . P ( text = 'Goodbye!' , classes = 'text-5xl m-2' )) return wp jp . Route ( '/hello' , hello_function ) jp . justpy ( bye_function ) Type different URLs into the browser and see what happens. Unless the path is exactly '/hello', the bye_function will run and 'Goodbye!' will be displayed. Warning All paths must start with '/', otherwise an error occurs. Using Decorators \u00b6 It is common in Python web frameworks to use decorators to assign functions to routes because it is convenient and makes the code more readable. JustPy also supports assigning routes using decorators: import justpy as jp @jp . SetRoute ( '/hello' ) def hello_function (): wp = jp . WebPage () wp . add ( jp . P ( text = 'Hello there!' , classes = 'text-5xl m-2' )) return wp @jp . SetRoute ( '/bye' ) def bye_function (): wp = jp . WebPage () wp . add ( jp . P ( text = 'Goodbye!' , classes = 'text-5xl m-2' )) return wp jp . justpy () The SetRoute decorator accepts as a parameter the route and assigns the decorated function to it. The program above defines two routes, '/hello' and '/bye'. URLs that do not include these exact routes, will cause the 'Page not found' message to appear. Using Route Parameters \u00b6 It is possible to use Starlette routing syntax to define routes with parameters. Parameters are exposed in the request.path.params dictionary: import justpy as jp def greeting_function ( request ): wp = jp . WebPage () wp . add ( jp . P ( text = f 'Hello there, {request.path_params[\"name\"]} !' , classes = 'text-5xl m-2' )) return wp jp . Route ( '/hello/ {name} ' , greeting_function ) jp . justpy () For more examples using path and url parameters see request object .","title":"Routes"},{"location":"tutorial/routes/#routes","text":"","title":"Routes"},{"location":"tutorial/routes/#the-basics","text":"In all the examples above, any URL typed into the browser would render the same page. Usually, when we develop a web application, we want different URLs to load different pages. In other words, we want to define different request handlers to handle different URLs. In this part of the tutorial we will show how to do this using JustPy. Please run the following program: import justpy as jp def hello_function (): wp = jp . WebPage () wp . add ( jp . P ( text = 'Hello there!' , classes = 'text-5xl m-2' )) return wp jp . Route ( '/hello' , hello_function ) jp . justpy () Unless you go specifically to http://127.0.0.1:8000/hello you will get the 'Page not found' JustPy message. When a request arrives, JustPy checks if the route in the URL matches any of the defined routes. If it does, it runs the appropriate function and if not, it runs the function provided as the argument of justpy. If no argument is provided to justpy , the framework shows the 'Page not found' message. Try running the following program: import justpy as jp def hello_function (): wp = jp . WebPage () wp . add ( jp . P ( text = 'Hello there!' , classes = 'text-5xl m-2' )) return wp def bye_function (): wp = jp . WebPage () wp . add ( jp . P ( text = 'Goodbye!' , classes = 'text-5xl m-2' )) return wp jp . Route ( '/hello' , hello_function ) jp . justpy ( bye_function ) Type different URLs into the browser and see what happens. Unless the path is exactly '/hello', the bye_function will run and 'Goodbye!' will be displayed. Warning All paths must start with '/', otherwise an error occurs.","title":"The Basics"},{"location":"tutorial/routes/#using-decorators","text":"It is common in Python web frameworks to use decorators to assign functions to routes because it is convenient and makes the code more readable. JustPy also supports assigning routes using decorators: import justpy as jp @jp . SetRoute ( '/hello' ) def hello_function (): wp = jp . WebPage () wp . add ( jp . P ( text = 'Hello there!' , classes = 'text-5xl m-2' )) return wp @jp . SetRoute ( '/bye' ) def bye_function (): wp = jp . WebPage () wp . add ( jp . P ( text = 'Goodbye!' , classes = 'text-5xl m-2' )) return wp jp . justpy () The SetRoute decorator accepts as a parameter the route and assigns the decorated function to it. The program above defines two routes, '/hello' and '/bye'. URLs that do not include these exact routes, will cause the 'Page not found' message to appear.","title":"Using Decorators"},{"location":"tutorial/routes/#using-route-parameters","text":"It is possible to use Starlette routing syntax to define routes with parameters. Parameters are exposed in the request.path.params dictionary: import justpy as jp def greeting_function ( request ): wp = jp . WebPage () wp . add ( jp . P ( text = f 'Hello there, {request.path_params[\"name\"]} !' , classes = 'text-5xl m-2' )) return wp jp . Route ( '/hello/ {name} ' , greeting_function ) jp . justpy () For more examples using path and url parameters see request object .","title":"Using Route Parameters"},{"location":"tutorial/sessions/","text":"Sessions in JustPy \u00b6 Introduction \u00b6 JustPy supports secure, server based sessions. Sessions are supported by default. If you want to disable them, add the line: SESSIONS = False to the configuration file, justpy.env In the configuration file. You can also set the name of the cookie JustPy will use by setting the value of SESSION_COOKIE_NAME . The default value is 'jp_token'. The max age of the cookie in seconds is set using COOKIE_MAX_AGE , default is 7 days. Your justpy.env file could include for example: SESSIONS = True SESSION_COOKIE_NAME = \"my_cookie_name\" COOKIE_MAX_AGE = 108000 SECRET_KEY = \"my_very_secret_key_that_only_I_know\" When a request is received and sessions are enabled, JustPy checks if a session cookie already exits. If not, a new unique session id is generated (using uuid4 ). The value of the JustPy cookie is signed using the python package itsdangerous . In order to do so, a secret key needs to be provided. Set the secret key by setting the value of SECRET_KEY in the configuration file justpy.env. JustPy comes with a default value (\"$$$my_secret_string$$$\") but be sure to change this for production. The advantage of signing the cookie is that cookie tampering can be detected. If JustPy detects that the cookie was tampered with, a Bad Cookie response is returned to the browser. Tip If you get a Bad Cookie response while testing you site, it may mean that you changed your secret key and your cookie is signed with the previous one. Just erase the cookie in your browser and try again. If the cookie is validated, the session inserts the session id into the request object as request.session_id . Info The JustPy cookie ONLY holds the signed session id. There is no other information in the cookie. Info The JustPy cookie is an HttpOnly cookie and is inaccessible to JavaScript on the page. Simple Example \u00b6 The session id can be used as an index or key to store information about a session. In the example below we define a dictionary called session_dict and hold the information there. If you need the session data to persist between server restarts, you would use a permanent data store like a a shelve or database to hold session data. In this example, for each session, a tally is kept of the number of visits and the number of clicks. JustPy provides the session id as part of the information that event handlers receive. If the standard msg argument is used, then the session id can be found in msg.session_id . import justpy as jp session_dict = {} def session_test ( request ): wp = jp . WebPage () if request . session_id not in session_dict : session_dict [ request . session_id ] = { 'visits' : 0 , 'events' : 0 } session_data = session_dict [ request . session_id ] session_data [ 'visits' ] += 1 jp . Div ( text = f 'My session id: {request.session_id} ' , classes = 'm-2 p-1 text-xl' , a = wp ) visits_div = jp . Div ( text = f 'Number of visits: {session_data[\"visits\"]} ' , classes = 'm-2 p-1 text-xl' , a = wp ) b = jp . Button ( text = f 'Number of Click Events: {session_data[\"events\"]} ' , classes = 'm-1 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full' , a = wp ) b . visits_div = visits_div def my_click ( self , msg ): session_data = session_dict [ msg . session_id ] session_data [ 'events' ] += 1 self . text = f 'Number of Click Events: {session_data[\"events\"]} ' self . visits_div . text = f 'Number of visits: {session_data[\"visits\"]} ' b . on ( 'click' , my_click ) return wp jp . justpy ( session_test ) Run the program above. Close, open and reload browser tabs and click the button. The session information persists. Login Example \u00b6 The example below shows how you could implement a very simple login/logout mechanism. import justpy as jp import asyncio login_form_html = \"\"\" <div class=\"w-full max-w-xs\"> <form class=\"bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4\"> <div class=\"mb-4\"> <label class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"username\"> Username </label> <input class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" type=\"text\" placeholder=\"Username\" name=\"user_name\"> </div> <div class=\"mb-6\"> <label class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"password\"> Password </label> <input class=\"shadow appearance-none border border-red-500 rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline\" name=\"password\" type=\"password\" placeholder=\"******************\"> <p class=\"text-red-500 text-xs italic\">The password is 'password'</p> </div> <div class=\"flex items-center justify-between\"> <button class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline\" type=\"button\" name=\"sign_in_btn\"> Sign In </button> </div> </form> <p class=\"text-center text-gray-500 text-xs\"> Example from https://tailwindcss.com/components/forms </p> </div> \"\"\" alert_html = \"\"\" <div role=\"alert\" class=\"m-1 p-1 w-1/3\"> <div class=\"bg-red-500 text-white font-bold rounded-t px-4 py-2\"> Password is incorrect </div> <div class=\"border border-t-0 border-red-400 rounded-b bg-red-100 px-4 py-3 text-red-700\"> <p>Please enter password again.</p> </div> </div> \"\"\" users = {} async def login_test ( request ): wp = jp . WebPage () session_id = request . session_id if session_id in users : if users [ session_id ][ 'logged_in' ]: jp . Div ( a = wp , text = f 'Your session id is: {session_id} ' , classes = 'm-1 p-1 text-xl ' ) jp . Div ( a = wp , text = f 'You are already logged in...' , classes = 'm-1 p-1 text-2l' ) log_out_btn = jp . Button ( text = 'Logout' , classes = jp . Styles . button_bordered + ' m-1 p-1' , a = wp ) log_out_btn . s_id = session_id def log_out ( self , msg ): users [ self . s_id ][ 'logged_in' ] = False msg . page . redirect = '/login_test' log_out_btn . on ( 'click' , log_out ) logged_in = True else : logged_in = False else : users [ session_id ] = {} users [ session_id ][ 'logged_in' ] = False logged_in = False if not logged_in : return await login_page ( request ) # Return different page if not logged in return wp @jp . SetRoute ( '/login' ) async def login_page ( request ): try : if users [ request . session_id ][ 'logged_in' ]: return await login_test ( request ) except : pass wp = jp . WebPage () wp . display_url = 'login_page' # Sets the url to display in browser without reloading page jp . Div ( text = 'Please login' , a = wp , classes = 'm-2 p-2 w-1/4 text-xl font-semibold' ) login_form = jp . parse_html ( login_form_html , a = wp , classes = 'm-2 p-2 w-1/4' ) alert = jp . parse_html ( alert_html , show = False , a = wp ) session_div = jp . Div ( text = 'Session goes here' , classes = 'm-1 p-1 text-xl' , a = wp ) sign_in_btn = login_form . name_dict [ 'sign_in_btn' ] sign_in_btn . user_name = login_form . name_dict [ 'user_name' ] sign_in_btn . session_id = request . session_id sign_in_btn . alert = alert async def sign_in_click ( self , msg ): if login_form . name_dict [ 'password' ] . value == 'password' : session_div . text = request . session_id + ' logged in successfully' self . alert . show = False return await login_successful ( wp , request . session_id ) else : session_div . text = request . session_id + ' login not successful' self . alert . show = True sign_in_btn . on ( 'click' , sign_in_click ) return wp async def login_successful ( wp , s_id ): wp . delete_components () users [ s_id ][ 'logged_in' ] = True wp . display_url = 'login_successful' jp . Div ( text = 'Login successful. You are now logged in' , classes = 'm-1 p-1 text-2xl' , a = wp ) await wp . update () await asyncio . sleep ( 3 ) wp . redirect = '/login_test' jp . justpy ( login_test )","title":"Sessions"},{"location":"tutorial/sessions/#sessions-in-justpy","text":"","title":"Sessions in JustPy"},{"location":"tutorial/sessions/#introduction","text":"JustPy supports secure, server based sessions. Sessions are supported by default. If you want to disable them, add the line: SESSIONS = False to the configuration file, justpy.env In the configuration file. You can also set the name of the cookie JustPy will use by setting the value of SESSION_COOKIE_NAME . The default value is 'jp_token'. The max age of the cookie in seconds is set using COOKIE_MAX_AGE , default is 7 days. Your justpy.env file could include for example: SESSIONS = True SESSION_COOKIE_NAME = \"my_cookie_name\" COOKIE_MAX_AGE = 108000 SECRET_KEY = \"my_very_secret_key_that_only_I_know\" When a request is received and sessions are enabled, JustPy checks if a session cookie already exits. If not, a new unique session id is generated (using uuid4 ). The value of the JustPy cookie is signed using the python package itsdangerous . In order to do so, a secret key needs to be provided. Set the secret key by setting the value of SECRET_KEY in the configuration file justpy.env. JustPy comes with a default value (\"$$$my_secret_string$$$\") but be sure to change this for production. The advantage of signing the cookie is that cookie tampering can be detected. If JustPy detects that the cookie was tampered with, a Bad Cookie response is returned to the browser. Tip If you get a Bad Cookie response while testing you site, it may mean that you changed your secret key and your cookie is signed with the previous one. Just erase the cookie in your browser and try again. If the cookie is validated, the session inserts the session id into the request object as request.session_id . Info The JustPy cookie ONLY holds the signed session id. There is no other information in the cookie. Info The JustPy cookie is an HttpOnly cookie and is inaccessible to JavaScript on the page.","title":"Introduction"},{"location":"tutorial/sessions/#simple-example","text":"The session id can be used as an index or key to store information about a session. In the example below we define a dictionary called session_dict and hold the information there. If you need the session data to persist between server restarts, you would use a permanent data store like a a shelve or database to hold session data. In this example, for each session, a tally is kept of the number of visits and the number of clicks. JustPy provides the session id as part of the information that event handlers receive. If the standard msg argument is used, then the session id can be found in msg.session_id . import justpy as jp session_dict = {} def session_test ( request ): wp = jp . WebPage () if request . session_id not in session_dict : session_dict [ request . session_id ] = { 'visits' : 0 , 'events' : 0 } session_data = session_dict [ request . session_id ] session_data [ 'visits' ] += 1 jp . Div ( text = f 'My session id: {request.session_id} ' , classes = 'm-2 p-1 text-xl' , a = wp ) visits_div = jp . Div ( text = f 'Number of visits: {session_data[\"visits\"]} ' , classes = 'm-2 p-1 text-xl' , a = wp ) b = jp . Button ( text = f 'Number of Click Events: {session_data[\"events\"]} ' , classes = 'm-1 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full' , a = wp ) b . visits_div = visits_div def my_click ( self , msg ): session_data = session_dict [ msg . session_id ] session_data [ 'events' ] += 1 self . text = f 'Number of Click Events: {session_data[\"events\"]} ' self . visits_div . text = f 'Number of visits: {session_data[\"visits\"]} ' b . on ( 'click' , my_click ) return wp jp . justpy ( session_test ) Run the program above. Close, open and reload browser tabs and click the button. The session information persists.","title":"Simple Example"},{"location":"tutorial/sessions/#login-example","text":"The example below shows how you could implement a very simple login/logout mechanism. import justpy as jp import asyncio login_form_html = \"\"\" <div class=\"w-full max-w-xs\"> <form class=\"bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4\"> <div class=\"mb-4\"> <label class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"username\"> Username </label> <input class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" type=\"text\" placeholder=\"Username\" name=\"user_name\"> </div> <div class=\"mb-6\"> <label class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"password\"> Password </label> <input class=\"shadow appearance-none border border-red-500 rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline\" name=\"password\" type=\"password\" placeholder=\"******************\"> <p class=\"text-red-500 text-xs italic\">The password is 'password'</p> </div> <div class=\"flex items-center justify-between\"> <button class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline\" type=\"button\" name=\"sign_in_btn\"> Sign In </button> </div> </form> <p class=\"text-center text-gray-500 text-xs\"> Example from https://tailwindcss.com/components/forms </p> </div> \"\"\" alert_html = \"\"\" <div role=\"alert\" class=\"m-1 p-1 w-1/3\"> <div class=\"bg-red-500 text-white font-bold rounded-t px-4 py-2\"> Password is incorrect </div> <div class=\"border border-t-0 border-red-400 rounded-b bg-red-100 px-4 py-3 text-red-700\"> <p>Please enter password again.</p> </div> </div> \"\"\" users = {} async def login_test ( request ): wp = jp . WebPage () session_id = request . session_id if session_id in users : if users [ session_id ][ 'logged_in' ]: jp . Div ( a = wp , text = f 'Your session id is: {session_id} ' , classes = 'm-1 p-1 text-xl ' ) jp . Div ( a = wp , text = f 'You are already logged in...' , classes = 'm-1 p-1 text-2l' ) log_out_btn = jp . Button ( text = 'Logout' , classes = jp . Styles . button_bordered + ' m-1 p-1' , a = wp ) log_out_btn . s_id = session_id def log_out ( self , msg ): users [ self . s_id ][ 'logged_in' ] = False msg . page . redirect = '/login_test' log_out_btn . on ( 'click' , log_out ) logged_in = True else : logged_in = False else : users [ session_id ] = {} users [ session_id ][ 'logged_in' ] = False logged_in = False if not logged_in : return await login_page ( request ) # Return different page if not logged in return wp @jp . SetRoute ( '/login' ) async def login_page ( request ): try : if users [ request . session_id ][ 'logged_in' ]: return await login_test ( request ) except : pass wp = jp . WebPage () wp . display_url = 'login_page' # Sets the url to display in browser without reloading page jp . Div ( text = 'Please login' , a = wp , classes = 'm-2 p-2 w-1/4 text-xl font-semibold' ) login_form = jp . parse_html ( login_form_html , a = wp , classes = 'm-2 p-2 w-1/4' ) alert = jp . parse_html ( alert_html , show = False , a = wp ) session_div = jp . Div ( text = 'Session goes here' , classes = 'm-1 p-1 text-xl' , a = wp ) sign_in_btn = login_form . name_dict [ 'sign_in_btn' ] sign_in_btn . user_name = login_form . name_dict [ 'user_name' ] sign_in_btn . session_id = request . session_id sign_in_btn . alert = alert async def sign_in_click ( self , msg ): if login_form . name_dict [ 'password' ] . value == 'password' : session_div . text = request . session_id + ' logged in successfully' self . alert . show = False return await login_successful ( wp , request . session_id ) else : session_div . text = request . session_id + ' login not successful' self . alert . show = True sign_in_btn . on ( 'click' , sign_in_click ) return wp async def login_successful ( wp , s_id ): wp . delete_components () users [ s_id ][ 'logged_in' ] = True wp . display_url = 'login_successful' jp . Div ( text = 'Login successful. You are now logged in' , classes = 'm-1 p-1 text-2xl' , a = wp ) await wp . update () await asyncio . sleep ( 3 ) wp . redirect = '/login_test' jp . justpy ( login_test )","title":"Login Example"},{"location":"tutorial/static/","text":"Static Files \u00b6 The Basics \u00b6 Static resources are those that are not generated dynamically by the application. An image is an example of a static resource. By default, all static resources for JustPy can be found under the /static route (this can be changed using the configuration file). Let's look at a concrete example. Follow this link : picture of papillon Save the image in the directory where your programs are under the name \"papillon.jpg\". Now, run the following program: import justpy as jp def static_test (): wp = jp . WebPage () jp . Img ( src = '/static/papillon.jpg' , a = wp , classes = 'm-2 p-2' ) return wp jp . justpy ( static_test ) You should see the picture on the web page. If you enter the URL http://127.0.0.1:8000/static/papillon.jpg you will get the picture also. If want to keep your static resources in a separate directory, the simplest thing to do is to create a subdirectory in the directory your program is in. If you call the directory \"my_pictures\" for example, and put the image there, you would need to set the src attribute of the image to \"/static/my_pictures/papillon.jpg\". The line in the code would look like this: jp . Img ( src = '/static/my_pictures/papillon.jpg' , a = wp , classes = 'm-2 p-2' ) Advanced Configuration \u00b6 JustPy uses starlette's StaticFiles class to serve static files. The relevant configuration and mounting commands are: config = Config ( 'justpy.env' ) STATIC_DIRECTORY = config ( 'STATIC_DIRECTORY' , cast = str , default = os . getcwd ()) STATIC_ROUTE = config ( 'STATIC_MOUNT' , cast = str , default = '/static' ) STATIC_NAME = config ( 'STATIC_NAME' , cast = str , default = 'static' ) app . mount ( STATIC_ROUTE , StaticFiles ( directory = STATIC_DIRECTORY ), name = STATIC_NAME ) If you want to change JustPy's defaults, change the settings in justpy.env, the configuration file. Note STATIC_NAME is used inside JustPy's templates so there is probably no reason to change it in any application unless you change the template files also.","title":"Static Files"},{"location":"tutorial/static/#static-files","text":"","title":"Static Files"},{"location":"tutorial/static/#the-basics","text":"Static resources are those that are not generated dynamically by the application. An image is an example of a static resource. By default, all static resources for JustPy can be found under the /static route (this can be changed using the configuration file). Let's look at a concrete example. Follow this link : picture of papillon Save the image in the directory where your programs are under the name \"papillon.jpg\". Now, run the following program: import justpy as jp def static_test (): wp = jp . WebPage () jp . Img ( src = '/static/papillon.jpg' , a = wp , classes = 'm-2 p-2' ) return wp jp . justpy ( static_test ) You should see the picture on the web page. If you enter the URL http://127.0.0.1:8000/static/papillon.jpg you will get the picture also. If want to keep your static resources in a separate directory, the simplest thing to do is to create a subdirectory in the directory your program is in. If you call the directory \"my_pictures\" for example, and put the image there, you would need to set the src attribute of the image to \"/static/my_pictures/papillon.jpg\". The line in the code would look like this: jp . Img ( src = '/static/my_pictures/papillon.jpg' , a = wp , classes = 'm-2 p-2' )","title":"The Basics"},{"location":"tutorial/static/#advanced-configuration","text":"JustPy uses starlette's StaticFiles class to serve static files. The relevant configuration and mounting commands are: config = Config ( 'justpy.env' ) STATIC_DIRECTORY = config ( 'STATIC_DIRECTORY' , cast = str , default = os . getcwd ()) STATIC_ROUTE = config ( 'STATIC_MOUNT' , cast = str , default = '/static' ) STATIC_NAME = config ( 'STATIC_NAME' , cast = str , default = 'static' ) app . mount ( STATIC_ROUTE , StaticFiles ( directory = STATIC_DIRECTORY ), name = STATIC_NAME ) If you want to change JustPy's defaults, change the settings in justpy.env, the configuration file. Note STATIC_NAME is used inside JustPy's templates so there is probably no reason to change it in any application unless you change the template files also.","title":"Advanced Configuration"},{"location":"tutorial/svg_components/","text":"SVG Components \u00b6 Scalable Vector Graphics (SVG) is an XML-based markup language for describing two dimensional based vector graphics. SVG is essentially to graphics what HTML is to text. - mozilla.org JustPy comes with components for all the SVG elements. Basic Example \u00b6 import justpy as jp def svg_demo (): wp = jp . WebPage () for color in [ 'red' , 'green' , 'blue' ]: svg = jp . Svg ( viewBox = '0 0 100 100' , xmlns = 'http://www.w3.org/2000/svg' , a = wp , width = 100 , height = 100 , classes = 'm-2 inline-block' ) circle = jp . Circle ( cx = '50' , cy = '50' , r = '50' , fill = color , a = svg ) for radius in range ( 10 , 51 , 10 ): svg = jp . Svg ( viewBox = '0 0 100 100' , xmlns = 'http://www.w3.org/2000/svg' , a = wp , width = 100 , height = 100 , classes = 'm-2 inline-block' ) ellipse = jp . Ellipse ( cx = 50 , cy = 50 , rx = radius , ry = radius / 2 , fill = 'teal' , a = svg ) return wp jp . justpy ( svg_demo ) The example above puts a few circles and ellipses on the page. Simple parse_html \u00b6 The following example is based on https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill Usually, you will find some SVG graphic you would like to use on you page. The simplest way to do so is to use parse_html . import justpy as jp # Example based on https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill svg_html = \"\"\" <svg viewBox=\"0 0 300 100\" xmlns=\"http://www.w3.org/2000/svg\" width=300 height=100> <!-- Simple color fill --> <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"pink\" /> <!-- Fill circle with a gradient --> <defs> <radialGradient id=\"myGradient\"> <stop offset=\"0%\" stop-color=\"pink\"/> <stop offset=\"100%\" stop-color=\"black\" /> </radialGradient> </defs> <circle cx=\"150\" cy=\"50\" r=\"40\" fill=\"url(#myGradient)\" /> <!-- Keeping the final state of an animated circle which is a circle with a radius of 40. --> <circle cx=\"250\" cy=\"50\" r=\"20\"> <animate attributeType=\"XML\" attributeName=\"r\" from=\"0\" to=\"40\" dur=\"5s\" fill=\"freeze\" /> </circle> </svg> \"\"\" def svg_demo (): wp = jp . WebPage () jp . parse_html ( svg_html , a = wp ) return wp jp . justpy ( svg_demo ) Advanced parse_html example \u00b6 Please run the following program and click on any middle circle. import justpy as jp # Example based on https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill svg_html = \"\"\" <svg viewBox=\"0 0 300 100\" xmlns=\"http://www.w3.org/2000/svg\" width=300 height=100> <!-- Simple color fill --> <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"pink\" name=\"simple_circle\"/> <!-- Fill circle with a gradient --> <defs> <radialGradient id=\"myGradient\" name=\"gradient\"> <stop offset=\"0%\" stop-color=\"pink\" name=\"stop\"/> <stop offset=\"100%\" stop-color=\"black\" /> </radialGradient> </defs> <circle cx=\"150\" cy=\"50\" r=\"40\" fill=\"url(#myGradient)\" name=\"gradient_circle\"/> <!-- Keeping the final state of an animated circle which is a circle with a radius of 40. --> <circle cx=\"250\" cy=\"50\" r=\"20\"> <animate attributeType=\"XML\" attributeName=\"r\" from=\"0\" to=\"40\" dur=\"5s\" fill=\"freeze\" /> </circle> </svg> \"\"\" def circle_click ( self , msg ): if self . stop . stop_color == 'orange' : self . stop . stop_color = self . original_color else : self . stop . stop_color = 'orange' def svg_demo (): wp = jp . WebPage () colors = [ 'pink' , 'red' , 'blue' , 'green' , 'teal' , 'yellow' ] for color in colors : g = jp . parse_html ( svg_html . replace ( 'id=\"myGradient\"' , f 'id=\" {color} \"' ), a = wp ) g . name_dict [ \"gradient_circle\" ] . original_color = color gradient = g . name_dict [ \"gradient\" ] g . name_dict [ \"gradient_circle\" ] . fill = f 'url(# {gradient.id} )' g . name_dict [ \"gradient_circle\" ] . stop = g . name_dict [ \"stop\" ] g . name_dict [ \"gradient_circle\" ] . on ( 'click' , circle_click ) g . name_dict [ \"stop\" ] . stop_color = color g . name_dict [ \"simple_circle\" ] . fill = color return wp jp . justpy ( svg_demo ) In svg_demo , in a loop that iterates over a list of colors, an element is created from parsing a modification of of the string svg_html (we change the id of the gradient definition to be unique). Then, the result is modified using the name_dict attribute. In the HTML string we named the elements we plan to modify later and they can be found in name_dict . Notice the two lines: gradient = g . name_dict [ \"gradient\" ] g . name_dict [ \"gradient_circle\" ] . fill = f 'url(# {gradient.id} )' The fill attribute of the circle with the gradient needs to refer the id of the radialGradient element. In the HTML string it is set to \"myGradient\" which we replace with a unique id in each loop iteration.","title":"SVG Components"},{"location":"tutorial/svg_components/#svg-components","text":"Scalable Vector Graphics (SVG) is an XML-based markup language for describing two dimensional based vector graphics. SVG is essentially to graphics what HTML is to text. - mozilla.org JustPy comes with components for all the SVG elements.","title":"SVG Components"},{"location":"tutorial/svg_components/#basic-example","text":"import justpy as jp def svg_demo (): wp = jp . WebPage () for color in [ 'red' , 'green' , 'blue' ]: svg = jp . Svg ( viewBox = '0 0 100 100' , xmlns = 'http://www.w3.org/2000/svg' , a = wp , width = 100 , height = 100 , classes = 'm-2 inline-block' ) circle = jp . Circle ( cx = '50' , cy = '50' , r = '50' , fill = color , a = svg ) for radius in range ( 10 , 51 , 10 ): svg = jp . Svg ( viewBox = '0 0 100 100' , xmlns = 'http://www.w3.org/2000/svg' , a = wp , width = 100 , height = 100 , classes = 'm-2 inline-block' ) ellipse = jp . Ellipse ( cx = 50 , cy = 50 , rx = radius , ry = radius / 2 , fill = 'teal' , a = svg ) return wp jp . justpy ( svg_demo ) The example above puts a few circles and ellipses on the page.","title":"Basic Example"},{"location":"tutorial/svg_components/#simple-parse_html","text":"The following example is based on https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill Usually, you will find some SVG graphic you would like to use on you page. The simplest way to do so is to use parse_html . import justpy as jp # Example based on https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill svg_html = \"\"\" <svg viewBox=\"0 0 300 100\" xmlns=\"http://www.w3.org/2000/svg\" width=300 height=100> <!-- Simple color fill --> <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"pink\" /> <!-- Fill circle with a gradient --> <defs> <radialGradient id=\"myGradient\"> <stop offset=\"0%\" stop-color=\"pink\"/> <stop offset=\"100%\" stop-color=\"black\" /> </radialGradient> </defs> <circle cx=\"150\" cy=\"50\" r=\"40\" fill=\"url(#myGradient)\" /> <!-- Keeping the final state of an animated circle which is a circle with a radius of 40. --> <circle cx=\"250\" cy=\"50\" r=\"20\"> <animate attributeType=\"XML\" attributeName=\"r\" from=\"0\" to=\"40\" dur=\"5s\" fill=\"freeze\" /> </circle> </svg> \"\"\" def svg_demo (): wp = jp . WebPage () jp . parse_html ( svg_html , a = wp ) return wp jp . justpy ( svg_demo )","title":"Simple parse_html"},{"location":"tutorial/svg_components/#advanced-parse_html-example","text":"Please run the following program and click on any middle circle. import justpy as jp # Example based on https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill svg_html = \"\"\" <svg viewBox=\"0 0 300 100\" xmlns=\"http://www.w3.org/2000/svg\" width=300 height=100> <!-- Simple color fill --> <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"pink\" name=\"simple_circle\"/> <!-- Fill circle with a gradient --> <defs> <radialGradient id=\"myGradient\" name=\"gradient\"> <stop offset=\"0%\" stop-color=\"pink\" name=\"stop\"/> <stop offset=\"100%\" stop-color=\"black\" /> </radialGradient> </defs> <circle cx=\"150\" cy=\"50\" r=\"40\" fill=\"url(#myGradient)\" name=\"gradient_circle\"/> <!-- Keeping the final state of an animated circle which is a circle with a radius of 40. --> <circle cx=\"250\" cy=\"50\" r=\"20\"> <animate attributeType=\"XML\" attributeName=\"r\" from=\"0\" to=\"40\" dur=\"5s\" fill=\"freeze\" /> </circle> </svg> \"\"\" def circle_click ( self , msg ): if self . stop . stop_color == 'orange' : self . stop . stop_color = self . original_color else : self . stop . stop_color = 'orange' def svg_demo (): wp = jp . WebPage () colors = [ 'pink' , 'red' , 'blue' , 'green' , 'teal' , 'yellow' ] for color in colors : g = jp . parse_html ( svg_html . replace ( 'id=\"myGradient\"' , f 'id=\" {color} \"' ), a = wp ) g . name_dict [ \"gradient_circle\" ] . original_color = color gradient = g . name_dict [ \"gradient\" ] g . name_dict [ \"gradient_circle\" ] . fill = f 'url(# {gradient.id} )' g . name_dict [ \"gradient_circle\" ] . stop = g . name_dict [ \"stop\" ] g . name_dict [ \"gradient_circle\" ] . on ( 'click' , circle_click ) g . name_dict [ \"stop\" ] . stop_color = color g . name_dict [ \"simple_circle\" ] . fill = color return wp jp . justpy ( svg_demo ) In svg_demo , in a loop that iterates over a list of colors, an element is created from parsing a modification of of the string svg_html (we change the id of the gradient definition to be unique). Then, the result is modified using the name_dict attribute. In the HTML string we named the elements we plan to modify later and they can be found in name_dict . Notice the two lines: gradient = g . name_dict [ \"gradient\" ] g . name_dict [ \"gradient_circle\" ] . fill = f 'url(# {gradient.id} )' The fill attribute of the circle with the gradient needs to refer the id of the radialGradient element. In the HTML string it is set to \"myGradient\" which we replace with a unique id in each loop iteration.","title":"Advanced parse_html example"},{"location":"tutorial/tailwind/","text":"Tailwind \u00b6 Why Tailwind? \u00b6 If you are not interested in CSS or design issues of web sites, you can safely skip this section and move ahead with the tutorial. Tailwind is a \"a utility-first CSS framework for rapidly building custom designs\". Tailwind is a great companion for JustPy because \"instead of opinionated pre-designed components, Tailwind provides low-level utility classes that let you build completely custom designs without ever leaving your HTML\". In practical terms, using Tailwind makes it easier to associate design with JustPy components and does not couple design with JavaScript. Of course, you need not use Tailwind, but it is worth your while evaluating it. The Tailwind class dictionaries \u00b6 The JustPy Tailwind class has two dictionaries: tw_dict and tw_reverse_dict The first dictionary's keys are the Tailwind categories of utility classes and the value is a list of all utility classes in the category. The reverse dictionary keys are the utility classes and the value is the category they belong to. These dictionaries are used to implement the set_class and set_classes methods. They can also be used to do the following: import justpy as jp def text_colors (): wp = jp . WebPage () d = jp . Div ( classes = 'flex flex-wrap m-2' , a = wp ) for color in jp . Tailwind . tw_dict [ 'text_color' ]: jp . Div ( text = color , classes = f ' {color} font-mono p-1 text-lg bg-blue-100 hover:bg-red-500 w-48' , a = d ) return wp jp . justpy ( text_colors ) This program shows the names and colors of all Tailwind text colors. Disabling Tailwind \u00b6 To disable Tailwind add the following line to the configuration file justpy.env: TAILWIND = False","title":"Tailwind"},{"location":"tutorial/tailwind/#tailwind","text":"","title":"Tailwind"},{"location":"tutorial/tailwind/#why-tailwind","text":"If you are not interested in CSS or design issues of web sites, you can safely skip this section and move ahead with the tutorial. Tailwind is a \"a utility-first CSS framework for rapidly building custom designs\". Tailwind is a great companion for JustPy because \"instead of opinionated pre-designed components, Tailwind provides low-level utility classes that let you build completely custom designs without ever leaving your HTML\". In practical terms, using Tailwind makes it easier to associate design with JustPy components and does not couple design with JavaScript. Of course, you need not use Tailwind, but it is worth your while evaluating it.","title":"Why Tailwind?"},{"location":"tutorial/tailwind/#the-tailwind-class-dictionaries","text":"The JustPy Tailwind class has two dictionaries: tw_dict and tw_reverse_dict The first dictionary's keys are the Tailwind categories of utility classes and the value is a list of all utility classes in the category. The reverse dictionary keys are the utility classes and the value is the category they belong to. These dictionaries are used to implement the set_class and set_classes methods. They can also be used to do the following: import justpy as jp def text_colors (): wp = jp . WebPage () d = jp . Div ( classes = 'flex flex-wrap m-2' , a = wp ) for color in jp . Tailwind . tw_dict [ 'text_color' ]: jp . Div ( text = color , classes = f ' {color} font-mono p-1 text-lg bg-blue-100 hover:bg-red-500 w-48' , a = d ) return wp jp . justpy ( text_colors ) This program shows the names and colors of all Tailwind text colors.","title":"The Tailwind class dictionaries"},{"location":"tutorial/tailwind/#disabling-tailwind","text":"To disable Tailwind add the following line to the configuration file justpy.env: TAILWIND = False","title":"Disabling Tailwind"},{"location":"tutorial/transitions/","text":"Transitions \u00b6 CSS transitions are a powerful way to make components interactive and engaging. From version 1.3, Tailwind provides classes that simplify adding transitions to elements. JustPy uses Alpine's transition format to apply classes for an element's transition from hidden to a non-hidden state. Warning You must add or remove the class hidden to change the state of an element. You can do this using the set_class and remove_class methods. See the example below. The hidden class is defined both in Tailwind and Quasar pages. If you use neither, you need to define it yourself as {display: none;} A CSS transition is defined by three sets of classes. The first set of classes are classes that are associated with the element throughout the transition process. The second set of classes defines the initial state of the element. The third set of classes defines the end state of the element after the transition has ended. You can apply these three sets of classes to three types of element states. The 'enter' state applies when an element transitions from hidden to not hidden. The 'leave' state applies when an element transitions from not hidden to hidden. The 'load' state applies when the page is initially loaded. These classes are stored in a dictionary of the form: transition_dict = { 'enter' : 'transition ease-out duration-1000' , 'enter_start' : 'opacity-0 transform scale-0' , 'enter_end' : 'opacity-100 transform scale-100' , 'leave' : 'transition ease-out duration-1000' , 'leave_start' : 'opacity-100 transform scale-100' , 'leave_end' : 'opacity-0 transform scale-0' , 'load' : 'transition ease-out duration-1000' , 'load_start' : 'opacity-0 transform scale-0' , 'load_end' : 'opacity-100 transform scale-100' } To enable transitions on an element, assign this dictionary to the element's transition attribute. d = jp . Div ( text = 'hello' ) d . transition = transition_dict The transition dictionary does not need to have all the keys shown above. If you want a transition only when the element loads the dictionary could look like this: transition_dict = { 'load' : 'transition ease-out duration-1000' , 'load_start' : 'opacity-0 transform scale-0' , 'load_end' : 'opacity-100 transform scale-100' } Info If you want to transition a Quasar element, encompass it inside a Div and transition the Div. In the example below, 10 Divs are transitioned each time the button is clicked: import justpy as jp def toggle_hidden ( self , msg ): for d in self . div_list : if d . has_class ( 'hidden' ): d . remove_class ( 'hidden' ) else : d . set_class ( 'hidden' ) def transition_test (): wp = jp . WebPage () tran = jp . Dict () tran . load = \"transition ease-out duration-1000\" tran . load_start = 'opacity-0 transform scale-0' tran . load_end = 'opacity-100 transform scale-100' tran . enter = 'transition ease-out duration-1000' tran . enter_start = 'opacity-0 transform scale-0' tran . enter_end = 'opacity-100 transform scale-1000' tran . leave = \"transition ease-out duration-1000\" tran . leave_start = 'opacity-100 transform scale-1000' tran . leave_end = 'opacity-0 transform scale-0' div_list = [] flex_div = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for i in range ( 10 ): d = jp . Div ( a = flex_div , text = 'hello' , style = 'height: 150px; width:200px' ) jp . Pre ( text = ' test' , a = d ) d . transition = tran d . classes = 'border text-xl m-2 h-16 w-16 bg-blue-500' div_list . append ( d ) b = jp . Button ( text = 'Click here' , classes = jp . Styles . button_simple + ' m-2' , a = wp , click = toggle_hidden ) b . div_list = div_list return wp jp . justpy ( transition_test )","title":"Transitions"},{"location":"tutorial/transitions/#transitions","text":"CSS transitions are a powerful way to make components interactive and engaging. From version 1.3, Tailwind provides classes that simplify adding transitions to elements. JustPy uses Alpine's transition format to apply classes for an element's transition from hidden to a non-hidden state. Warning You must add or remove the class hidden to change the state of an element. You can do this using the set_class and remove_class methods. See the example below. The hidden class is defined both in Tailwind and Quasar pages. If you use neither, you need to define it yourself as {display: none;} A CSS transition is defined by three sets of classes. The first set of classes are classes that are associated with the element throughout the transition process. The second set of classes defines the initial state of the element. The third set of classes defines the end state of the element after the transition has ended. You can apply these three sets of classes to three types of element states. The 'enter' state applies when an element transitions from hidden to not hidden. The 'leave' state applies when an element transitions from not hidden to hidden. The 'load' state applies when the page is initially loaded. These classes are stored in a dictionary of the form: transition_dict = { 'enter' : 'transition ease-out duration-1000' , 'enter_start' : 'opacity-0 transform scale-0' , 'enter_end' : 'opacity-100 transform scale-100' , 'leave' : 'transition ease-out duration-1000' , 'leave_start' : 'opacity-100 transform scale-100' , 'leave_end' : 'opacity-0 transform scale-0' , 'load' : 'transition ease-out duration-1000' , 'load_start' : 'opacity-0 transform scale-0' , 'load_end' : 'opacity-100 transform scale-100' } To enable transitions on an element, assign this dictionary to the element's transition attribute. d = jp . Div ( text = 'hello' ) d . transition = transition_dict The transition dictionary does not need to have all the keys shown above. If you want a transition only when the element loads the dictionary could look like this: transition_dict = { 'load' : 'transition ease-out duration-1000' , 'load_start' : 'opacity-0 transform scale-0' , 'load_end' : 'opacity-100 transform scale-100' } Info If you want to transition a Quasar element, encompass it inside a Div and transition the Div. In the example below, 10 Divs are transitioned each time the button is clicked: import justpy as jp def toggle_hidden ( self , msg ): for d in self . div_list : if d . has_class ( 'hidden' ): d . remove_class ( 'hidden' ) else : d . set_class ( 'hidden' ) def transition_test (): wp = jp . WebPage () tran = jp . Dict () tran . load = \"transition ease-out duration-1000\" tran . load_start = 'opacity-0 transform scale-0' tran . load_end = 'opacity-100 transform scale-100' tran . enter = 'transition ease-out duration-1000' tran . enter_start = 'opacity-0 transform scale-0' tran . enter_end = 'opacity-100 transform scale-1000' tran . leave = \"transition ease-out duration-1000\" tran . leave_start = 'opacity-100 transform scale-1000' tran . leave_end = 'opacity-0 transform scale-0' div_list = [] flex_div = jp . Div ( classes = 'flex flex-wrap' , a = wp ) for i in range ( 10 ): d = jp . Div ( a = flex_div , text = 'hello' , style = 'height: 150px; width:200px' ) jp . Pre ( text = ' test' , a = d ) d . transition = tran d . classes = 'border text-xl m-2 h-16 w-16 bg-blue-500' div_list . append ( d ) b = jp . Button ( text = 'Click here' , classes = jp . Styles . button_simple + ' m-2' , a = wp , click = toggle_hidden ) b . div_list = div_list return wp jp . justpy ( transition_test )","title":"Transitions"},{"location":"tutorial/uploading_files/","text":"Downloading and Uploading Files \u00b6 Downloading Files \u00b6 Static Content \u00b6 Enabling a file download by users is done by using the JustPy component that corresponds to the a html tag . The component has a download attribute that when set, the file that the href attributes links to is downloaded and the name given to it is the value of the download attribute. import justpy as jp download_link = jp . A ( text = 'Download image' , href = '/static/image1.png' , download = 'image1.png' ) In the example above, when the element is clicked, the file 'image1.png' from the directory the server was run (the default static directory) will be downloaded and will be called 'image1.png' on the user's computer. The way JustPy handles static files is explained here Dynamic Content \u00b6 The download link does not have to be static. In the example below, the href is a non-static route that responds to a user request and inserts text into the page that is returned. Since the text is assigned to the html attribute of the page, this overrides all other page options and just the text is returned. Run it and look at the files created each time. They will be different based on the time they were downloaded. import justpy as jp from datetime import datetime def change_link_text ( self , msg ): self . set_classes ( 'text-yellow-500' ) def download_test (): wp = jp . WebPage () download_link = jp . A ( text = 'Download File' , href = '/create_file' , download = 'text_file.txt' , a = wp , classes = 'inline-block m-2 p-2 text-white bg-blue-500 text-2xl' ) download_link . on ( 'click' , change_link_text ) return wp @jp . SetRoute ( '/create_file' ) def create_file (): wp = jp . WebPage () now = datetime . now () . strftime ( '%Y-%m- %d %H:%M:%S' ) wp . html = f 'This text file was generated on {now} ' return wp jp . justpy ( download_test ) Uploading Files \u00b6 Uploading files is a three step process. 1) First the user needs to provide the files to upload using an Input element of type 'file' . In order to upload files chosen by the user, this Input element must be in a Form element and the form must have a submit button. 2) When the user submits the form, the content of the files is provided as part of the second argument of the submit event handler ( msg in this tutorial). 3) Form submission activates the form submit event handler where the file content can be saved on the server. First, let's look at the isolated behavior of an Input element of type 'file'. In the program below, one such element is put on the page and after the user selects files, information about the selected files is displayed on the page. Note In order to be compatible with all browsers, use the 'change' event with this kind of Input element and not the 'input' event import justpy as jp def download_test (): wp = jp . WebPage () in1 = jp . Input ( type = 'file' , classes = jp . Styles . input_classes , a = wp , multiple = True , change = file_input ) in1 . file_div = jp . Div ( a = wp ) return wp def file_input ( self , msg ): self . file_div . delete_components () for f in msg . files : jp . Div ( text = f ' {f.name} | {f.size} | {f.type} | {f.lastModified} ' , a = self . file_div , classes = 'font-mono m-1 p-2' ) jp . justpy ( download_test ) In the case of an Input element for file selection, JustPy adds to msg a list msg.files , that includes information about all the files selected by the user. For each file there is dictionary in the list with four keys: name - the name of the file size - the size of the file in bytes type - the MIME type of the file lastModified - time that the file was last modified as milliseconds since the epoch Run the program above to see some examples of these values. Note that the content of the files is not available to the change event handler. Only when a form with the element has been submitted, does JustPy actually read the files and insert their content in the msg of the submit event handler. Again the information is found in msg.files but with an additional key called file_content . The value under this key is the file content in base64 format . Files in this format are in printable ASCII characters and can be included in WebSocket messages and HTTP POST requests. Note When using Websockets there is currently a 1 MByte limit on total upload size in one request after the base64 conversion. If you want a large limit, run the upload page or the application with websockets=false The program below lets users upload image files and displays thumbnails of the files uploaded. When the thumbnails are clicked, the file that was uploaded is downloaded. Each user's files are stored in a directory that is unique for each session. The ThumbNail component defined in the program is an A component that includes an Img component. import justpy as jp import base64 import os class ThumbNail ( jp . A ): def __init__ ( self , ** kwargs ): self . pic_file = '' # If True, files downloaded. If False, they are opened in new browser tab self . download_files = True super () . __init__ ( ** kwargs ) self . target = '_blank' self . img = jp . Img ( a = self ) self . img . style = 'width: 150px' self . img . classes = 'p-5 m-1 border-2 rounded-lg border-gray-200 hover:shadow-lg' def react ( self , data ): self . img . src = self . pic_file self . href = self . pic_file if self . download_files : self . download = self . href . split ( '/' )[ 3 ] # href is of the form /static/session_id/file_name self . set_classes ( 'inline-block' ) def pic_submit ( self , msg ): # If directory for session does not exist, create one # The name of the directory is the session_id if not os . path . isdir ( msg . session_id ): os . mkdir ( msg . session_id ) # Find the element in the form data that contains the file information for c in msg . form_data : if c . type == 'file' : break # Write the content to a file after decoding the base64 content for i , v in enumerate ( c . files ): with open ( f ' {msg.session_id} / {v.name} ' , 'wb' ) as f : f . write ( base64 . b64decode ( v . file_content )) file_list = os . listdir ( msg . session_id ) self . image_div . delete_components () if file_list : for file in file_list : ThumbNail ( pic_file = f '/static/ {msg.session_id} / {file} ' , a = self . image_div ) else : jp . Div ( text = 'No images uploaded yet' , a = self . image_div , classes = 'text-3xl' ) def upload_test ( request ): wp = jp . WebPage () image_div = jp . Div ( a = wp , classes = 'm-2 p-2 overflow-auto border-4 flex flex-wrap content-start' , style = 'height: 80vh' ) file_list = [] if os . path . isdir ( request . session_id ): file_list = os . listdir ( request . session_id ) if file_list : for file in file_list : ThumbNail ( pic_file = f '/static/ {request.session_id} / {file} ' , a = image_div ) else : jp . Div ( text = 'No images uploaded yet' , a = image_div , classes = 'text-3xl' ) f = jp . Form ( a = wp , enctype = 'multipart/form-data' , submit = pic_submit ) f . image_div = image_div # Will be used in submit event handler jp . Input ( type = 'file' , classes = jp . Styles . input_classes , a = f , multiple = True , accept = 'image/*' ) jp . Button ( type = 'submit' , text = 'Upload' , classes = jp . Styles . button_simple , a = f ) return wp jp . justpy ( upload_test , websockets = False )","title":"Downloading and Uploading Files"},{"location":"tutorial/uploading_files/#downloading-and-uploading-files","text":"","title":"Downloading and Uploading Files"},{"location":"tutorial/uploading_files/#downloading-files","text":"","title":"Downloading Files"},{"location":"tutorial/uploading_files/#static-content","text":"Enabling a file download by users is done by using the JustPy component that corresponds to the a html tag . The component has a download attribute that when set, the file that the href attributes links to is downloaded and the name given to it is the value of the download attribute. import justpy as jp download_link = jp . A ( text = 'Download image' , href = '/static/image1.png' , download = 'image1.png' ) In the example above, when the element is clicked, the file 'image1.png' from the directory the server was run (the default static directory) will be downloaded and will be called 'image1.png' on the user's computer. The way JustPy handles static files is explained here","title":"Static Content"},{"location":"tutorial/uploading_files/#dynamic-content","text":"The download link does not have to be static. In the example below, the href is a non-static route that responds to a user request and inserts text into the page that is returned. Since the text is assigned to the html attribute of the page, this overrides all other page options and just the text is returned. Run it and look at the files created each time. They will be different based on the time they were downloaded. import justpy as jp from datetime import datetime def change_link_text ( self , msg ): self . set_classes ( 'text-yellow-500' ) def download_test (): wp = jp . WebPage () download_link = jp . A ( text = 'Download File' , href = '/create_file' , download = 'text_file.txt' , a = wp , classes = 'inline-block m-2 p-2 text-white bg-blue-500 text-2xl' ) download_link . on ( 'click' , change_link_text ) return wp @jp . SetRoute ( '/create_file' ) def create_file (): wp = jp . WebPage () now = datetime . now () . strftime ( '%Y-%m- %d %H:%M:%S' ) wp . html = f 'This text file was generated on {now} ' return wp jp . justpy ( download_test )","title":"Dynamic Content"},{"location":"tutorial/uploading_files/#uploading-files","text":"Uploading files is a three step process. 1) First the user needs to provide the files to upload using an Input element of type 'file' . In order to upload files chosen by the user, this Input element must be in a Form element and the form must have a submit button. 2) When the user submits the form, the content of the files is provided as part of the second argument of the submit event handler ( msg in this tutorial). 3) Form submission activates the form submit event handler where the file content can be saved on the server. First, let's look at the isolated behavior of an Input element of type 'file'. In the program below, one such element is put on the page and after the user selects files, information about the selected files is displayed on the page. Note In order to be compatible with all browsers, use the 'change' event with this kind of Input element and not the 'input' event import justpy as jp def download_test (): wp = jp . WebPage () in1 = jp . Input ( type = 'file' , classes = jp . Styles . input_classes , a = wp , multiple = True , change = file_input ) in1 . file_div = jp . Div ( a = wp ) return wp def file_input ( self , msg ): self . file_div . delete_components () for f in msg . files : jp . Div ( text = f ' {f.name} | {f.size} | {f.type} | {f.lastModified} ' , a = self . file_div , classes = 'font-mono m-1 p-2' ) jp . justpy ( download_test ) In the case of an Input element for file selection, JustPy adds to msg a list msg.files , that includes information about all the files selected by the user. For each file there is dictionary in the list with four keys: name - the name of the file size - the size of the file in bytes type - the MIME type of the file lastModified - time that the file was last modified as milliseconds since the epoch Run the program above to see some examples of these values. Note that the content of the files is not available to the change event handler. Only when a form with the element has been submitted, does JustPy actually read the files and insert their content in the msg of the submit event handler. Again the information is found in msg.files but with an additional key called file_content . The value under this key is the file content in base64 format . Files in this format are in printable ASCII characters and can be included in WebSocket messages and HTTP POST requests. Note When using Websockets there is currently a 1 MByte limit on total upload size in one request after the base64 conversion. If you want a large limit, run the upload page or the application with websockets=false The program below lets users upload image files and displays thumbnails of the files uploaded. When the thumbnails are clicked, the file that was uploaded is downloaded. Each user's files are stored in a directory that is unique for each session. The ThumbNail component defined in the program is an A component that includes an Img component. import justpy as jp import base64 import os class ThumbNail ( jp . A ): def __init__ ( self , ** kwargs ): self . pic_file = '' # If True, files downloaded. If False, they are opened in new browser tab self . download_files = True super () . __init__ ( ** kwargs ) self . target = '_blank' self . img = jp . Img ( a = self ) self . img . style = 'width: 150px' self . img . classes = 'p-5 m-1 border-2 rounded-lg border-gray-200 hover:shadow-lg' def react ( self , data ): self . img . src = self . pic_file self . href = self . pic_file if self . download_files : self . download = self . href . split ( '/' )[ 3 ] # href is of the form /static/session_id/file_name self . set_classes ( 'inline-block' ) def pic_submit ( self , msg ): # If directory for session does not exist, create one # The name of the directory is the session_id if not os . path . isdir ( msg . session_id ): os . mkdir ( msg . session_id ) # Find the element in the form data that contains the file information for c in msg . form_data : if c . type == 'file' : break # Write the content to a file after decoding the base64 content for i , v in enumerate ( c . files ): with open ( f ' {msg.session_id} / {v.name} ' , 'wb' ) as f : f . write ( base64 . b64decode ( v . file_content )) file_list = os . listdir ( msg . session_id ) self . image_div . delete_components () if file_list : for file in file_list : ThumbNail ( pic_file = f '/static/ {msg.session_id} / {file} ' , a = self . image_div ) else : jp . Div ( text = 'No images uploaded yet' , a = self . image_div , classes = 'text-3xl' ) def upload_test ( request ): wp = jp . WebPage () image_div = jp . Div ( a = wp , classes = 'm-2 p-2 overflow-auto border-4 flex flex-wrap content-start' , style = 'height: 80vh' ) file_list = [] if os . path . isdir ( request . session_id ): file_list = os . listdir ( request . session_id ) if file_list : for file in file_list : ThumbNail ( pic_file = f '/static/ {request.session_id} / {file} ' , a = image_div ) else : jp . Div ( text = 'No images uploaded yet' , a = image_div , classes = 'text-3xl' ) f = jp . Form ( a = wp , enctype = 'multipart/form-data' , submit = pic_submit ) f . image_div = image_div # Will be used in submit event handler jp . Input ( type = 'file' , classes = jp . Styles . input_classes , a = f , multiple = True , accept = 'image/*' ) jp . Button ( type = 'submit' , text = 'Upload' , classes = jp . Styles . button_simple , a = f ) return wp jp . justpy ( upload_test , websockets = False )","title":"Uploading Files"},{"location":"tutorial/working_with_html/","text":"Parsing and Using HTML \u00b6 Introduction \u00b6 JustPy provides several way of working directly with HTML. If you don't need any events associated with your HTML just set the inner_html of a Div instance as described below. In order to interact with the HTML, you need to use parse_html to convert the HTML to JustPy commands that create the appropriate elements. You can then assign event handlers to the elements. The inner_html Attribute \u00b6 You can set the content of an element by assigning a HTML string to the element's inner_html attribute. This is the preferred method if you don't need to interact with the HTML. As a general rule, if you are not using the name_dict attribute created by parse_html , you probably should use inner_html instead. import justpy as jp my_html = \"\"\" <div> <p class=\"m-2 p-2 text-red-500 text-xl\">Paragraph 1</p> <p class=\"m-2 p-2 text-blue-500 text-xl\">Paragraph 2</p> <p class=\"m-2 p-2 text-green-500 text-xl\">Paragraph 3</p> </div> \"\"\" def inner_demo (): wp = jp . WebPage () d = jp . Div ( a = wp , classes = 'm-4 p-4 text-3xl' ) d . inner_html = '<pre>Hello there. \\n How are you?</pre>' jp . Div ( a = wp , inner_html = my_html ) for color in [ 'red' , 'green' , 'blue' , 'pink' , 'yellow' , 'teal' , 'purple' ]: jp . Div ( a = wp , inner_html = f '<p class=\"ml-2 text- {color} -500 text-3xl\"> {color} </p>' ) return wp jp . justpy ( inner_demo ) Warning if you set inner_html , it will override any other content of your component. Inserting HTML at the WebPage level \u00b6 You can inject HTML directly into the page by setting the html attribute of a WebPage instance. import justpy as jp def html_demo (): wp = jp . WebPage () jp . Div ( text = 'This will not be shown' , a = wp ) wp . html = '<p class=\"text-2xl m-2 m-1 text-red-500\">Hello world!<p>' jp . Div ( text = 'This will not be shown' , a = wp ) return wp jp . justpy ( html_demo ) If the html attribute is set, all other additions to the page will be ignored. The parse_html Function \u00b6 To convert HTML to JustPy elements, use the parse_html function. import justpy as jp async def parse_demo ( request ): wp = jp . WebPage () c = jp . parse_html ( \"\"\" <div> <p class=\"m-2 p-2 text-red-500 text-xl\">Paragraph 1</p> <p class=\"m-2 p-2 text-blue-500 text-xl\">Paragraph 2</p> <p class=\"m-2 p-2 text-green-500 text-xl\">Paragraph 3</p> </div> \"\"\" , a = wp ) print ( c ) print ( c . components ) return wp jp . justpy ( parse_demo ) Run the program above. It renders the HTML on the page. The two print commands output the following: Div(id: 1, html_tag: div, vue_type: html_component, number of components: 3) [P(id: 2, html_tag: p, vue_type: html_component, number of components: 0), P(id: 3, html_tag: p, vue_type: html_component, number of components: 0), P(id: 4, html_tag: p, vue_type: html_component, number of components: 0)] The printout shows that c is a Div component that has 3 child components that are P components. The parsing function takes HTML and creates JustPy elements with the right relationships between them. It returns the topmost component if there is only one. If there are two or more siblings at the top level, it wraps them with a Div and returns the div. You can think of parse_html as returning the element at the base of the HTML tree. There are several way to access the child components. For example, in our specific case the first paragraph is the first child of c and therefore can be accessed as c.components[0] . The name_dict dictionary \u00b6 A more general way to access parsed elements is to use the name attribute inside the HTML. The function parse_html attaches to the component it returns an attribute called name_dict , that as its name implies, is a dictionary whose keys are the name attributes and its values are the components they correspond to. Here is an example: import justpy as jp async def parse_demo ( request ): wp = jp . WebPage () c = jp . parse_html ( \"\"\" <div> <p class=\"m-2 p-2 text-red-500 text-xl\">Paragraph 1</p> <p class=\"m-2 p-2 text-blue-500 text-xl\" name=\"p2\">Paragraph 2</p> <p class=\"m-2 p-2 text-green-500 text-xl\">Paragraph 3</p> </div> \"\"\" , a = wp ) p2 = c . name_dict [ 'p2' ] def my_click ( self , msg ): self . text = 'I was clicked!' p2 . on ( 'click' , my_click ) return wp jp . justpy ( parse_demo ) If you click the second paragraph, its text will change. Notice that we added name=\"p2\" to the HTML of the second paragraph. When the parser sees the name attribute it creates an entry in name_dict with the name as the key and the component as the value. If more than one element is given the same name in the HTML text, the dictionary value is a list with all the elements with that name. name_dict is of type Dict so its fields can be accessed using dot notation. Instead of c.name_dict['a'] you can use c.name_dict.a . Additional parsing functions \u00b6 Along with parse_html there are two additional functions in JustPy to parse HTML: parse_html_file parses a file instead of a string and parse_html_file_async is a co-routine that does the same asynchronously. The commands attribute \u00b6 The commands attribute is created by parse_html and includes a list of the Python commands (represented as strings) needed to create the element in the JustPy framework. import justpy as jp def commands_demo (): wp = jp . WebPage () c = jp . parse_html ( \"\"\" <div> <p class=\"m-2 p-2 text-red-500 text-xl\">Paragraph 1</p> <p class=\"m-2 p-2 text-blue-500 text-xl\">Paragraph 2</p> <p class=\"m-2 p-2 text-green-500 text-xl\">Paragraph 3</p> </div> \"\"\" , a = wp ) for i in c . commands : print ( i ) jp . Div ( text = i , classes = 'font-mono ml-2' , a = wp ) print () c = jp . parse_html ( \"\"\" <div> <p class=\"m-2 p-2 text-red-500 text-xl\">Paragraph 1</p> <p class=\"m-2 p-2 text-blue-500 text-xl\">Paragraph 2</p> <p class=\"m-2 p-2 text-green-500 text-xl\">Paragraph 3</p> </div> \"\"\" , a = wp , command_prefix = 'justpy.' ) for i in c . commands : print ( i ) jp . Div ( text = i , classes = 'font-mono ml-2' , a = wp ) return wp jp . justpy ( commands_demo ) The command_prefix keyword argument allows specifying the prefix for the commands. The default is 'jp.' Warning All non blank prefixes should have the '.' (period) as their last character We can then use the commands to generate the output we need without parsing HTML: import justpy as jp def commands_demo (): wp = jp . WebPage () root = jp . Div ( a = wp ) c1 = jp . Div ( a = root ) c2 = jp . P ( classes = 'm-2 p-2 text-red-500 text-xl' , a = c1 , text = 'Paragraph 1' ) c3 = jp . P ( classes = 'm-2 p-2 text-blue-500 text-xl' , a = c1 , text = 'Paragraph 2' ) c4 = jp . P ( classes = 'm-2 p-2 text-green-500 text-xl' , a = c1 , text = 'Paragraph 3' ) return wp jp . justpy ( commands_demo ) The only change needed to the commands is to add root to the page. parse_html limitations \u00b6 The parser does not handle correctly HTML in which top level text is divided. The following HTML will not parse correctly: < div > First part of text < span > span text </ span > second part of text </ div > This is because by design, JustPy has just one text attribute per element and so the parser discards the first part. In order to parse the HTML correctly, make each element have undivided text: < div > < span > First part of text </ span >< span class = \"ml-1\" > span text </ span > < span class = \"ml-1\" > second part of text </ span ></ div > Now each span has undivided text. The left margin class is required to so that there is a space between the spans. parse_html removes all white space before and after the text of the elements. Converting to HTML \u00b6 Each component in JustPy also supports the to_html() method. It returns a string with the HTML representation of the element including all its child elements. You can think of it as the inverse of parse_html() .","title":"Parsing and Using HTML"},{"location":"tutorial/working_with_html/#parsing-and-using-html","text":"","title":"Parsing and Using HTML"},{"location":"tutorial/working_with_html/#introduction","text":"JustPy provides several way of working directly with HTML. If you don't need any events associated with your HTML just set the inner_html of a Div instance as described below. In order to interact with the HTML, you need to use parse_html to convert the HTML to JustPy commands that create the appropriate elements. You can then assign event handlers to the elements.","title":"Introduction"},{"location":"tutorial/working_with_html/#the-inner_html-attribute","text":"You can set the content of an element by assigning a HTML string to the element's inner_html attribute. This is the preferred method if you don't need to interact with the HTML. As a general rule, if you are not using the name_dict attribute created by parse_html , you probably should use inner_html instead. import justpy as jp my_html = \"\"\" <div> <p class=\"m-2 p-2 text-red-500 text-xl\">Paragraph 1</p> <p class=\"m-2 p-2 text-blue-500 text-xl\">Paragraph 2</p> <p class=\"m-2 p-2 text-green-500 text-xl\">Paragraph 3</p> </div> \"\"\" def inner_demo (): wp = jp . WebPage () d = jp . Div ( a = wp , classes = 'm-4 p-4 text-3xl' ) d . inner_html = '<pre>Hello there. \\n How are you?</pre>' jp . Div ( a = wp , inner_html = my_html ) for color in [ 'red' , 'green' , 'blue' , 'pink' , 'yellow' , 'teal' , 'purple' ]: jp . Div ( a = wp , inner_html = f '<p class=\"ml-2 text- {color} -500 text-3xl\"> {color} </p>' ) return wp jp . justpy ( inner_demo ) Warning if you set inner_html , it will override any other content of your component.","title":"The inner_html Attribute"},{"location":"tutorial/working_with_html/#inserting-html-at-the-webpage-level","text":"You can inject HTML directly into the page by setting the html attribute of a WebPage instance. import justpy as jp def html_demo (): wp = jp . WebPage () jp . Div ( text = 'This will not be shown' , a = wp ) wp . html = '<p class=\"text-2xl m-2 m-1 text-red-500\">Hello world!<p>' jp . Div ( text = 'This will not be shown' , a = wp ) return wp jp . justpy ( html_demo ) If the html attribute is set, all other additions to the page will be ignored.","title":"Inserting HTML at the WebPage level"},{"location":"tutorial/working_with_html/#the-parse_html-function","text":"To convert HTML to JustPy elements, use the parse_html function. import justpy as jp async def parse_demo ( request ): wp = jp . WebPage () c = jp . parse_html ( \"\"\" <div> <p class=\"m-2 p-2 text-red-500 text-xl\">Paragraph 1</p> <p class=\"m-2 p-2 text-blue-500 text-xl\">Paragraph 2</p> <p class=\"m-2 p-2 text-green-500 text-xl\">Paragraph 3</p> </div> \"\"\" , a = wp ) print ( c ) print ( c . components ) return wp jp . justpy ( parse_demo ) Run the program above. It renders the HTML on the page. The two print commands output the following: Div(id: 1, html_tag: div, vue_type: html_component, number of components: 3) [P(id: 2, html_tag: p, vue_type: html_component, number of components: 0), P(id: 3, html_tag: p, vue_type: html_component, number of components: 0), P(id: 4, html_tag: p, vue_type: html_component, number of components: 0)] The printout shows that c is a Div component that has 3 child components that are P components. The parsing function takes HTML and creates JustPy elements with the right relationships between them. It returns the topmost component if there is only one. If there are two or more siblings at the top level, it wraps them with a Div and returns the div. You can think of parse_html as returning the element at the base of the HTML tree. There are several way to access the child components. For example, in our specific case the first paragraph is the first child of c and therefore can be accessed as c.components[0] .","title":"The parse_html Function"},{"location":"tutorial/working_with_html/#the-name_dict-dictionary","text":"A more general way to access parsed elements is to use the name attribute inside the HTML. The function parse_html attaches to the component it returns an attribute called name_dict , that as its name implies, is a dictionary whose keys are the name attributes and its values are the components they correspond to. Here is an example: import justpy as jp async def parse_demo ( request ): wp = jp . WebPage () c = jp . parse_html ( \"\"\" <div> <p class=\"m-2 p-2 text-red-500 text-xl\">Paragraph 1</p> <p class=\"m-2 p-2 text-blue-500 text-xl\" name=\"p2\">Paragraph 2</p> <p class=\"m-2 p-2 text-green-500 text-xl\">Paragraph 3</p> </div> \"\"\" , a = wp ) p2 = c . name_dict [ 'p2' ] def my_click ( self , msg ): self . text = 'I was clicked!' p2 . on ( 'click' , my_click ) return wp jp . justpy ( parse_demo ) If you click the second paragraph, its text will change. Notice that we added name=\"p2\" to the HTML of the second paragraph. When the parser sees the name attribute it creates an entry in name_dict with the name as the key and the component as the value. If more than one element is given the same name in the HTML text, the dictionary value is a list with all the elements with that name. name_dict is of type Dict so its fields can be accessed using dot notation. Instead of c.name_dict['a'] you can use c.name_dict.a .","title":"The name_dict dictionary"},{"location":"tutorial/working_with_html/#additional-parsing-functions","text":"Along with parse_html there are two additional functions in JustPy to parse HTML: parse_html_file parses a file instead of a string and parse_html_file_async is a co-routine that does the same asynchronously.","title":"Additional parsing functions"},{"location":"tutorial/working_with_html/#the-commands-attribute","text":"The commands attribute is created by parse_html and includes a list of the Python commands (represented as strings) needed to create the element in the JustPy framework. import justpy as jp def commands_demo (): wp = jp . WebPage () c = jp . parse_html ( \"\"\" <div> <p class=\"m-2 p-2 text-red-500 text-xl\">Paragraph 1</p> <p class=\"m-2 p-2 text-blue-500 text-xl\">Paragraph 2</p> <p class=\"m-2 p-2 text-green-500 text-xl\">Paragraph 3</p> </div> \"\"\" , a = wp ) for i in c . commands : print ( i ) jp . Div ( text = i , classes = 'font-mono ml-2' , a = wp ) print () c = jp . parse_html ( \"\"\" <div> <p class=\"m-2 p-2 text-red-500 text-xl\">Paragraph 1</p> <p class=\"m-2 p-2 text-blue-500 text-xl\">Paragraph 2</p> <p class=\"m-2 p-2 text-green-500 text-xl\">Paragraph 3</p> </div> \"\"\" , a = wp , command_prefix = 'justpy.' ) for i in c . commands : print ( i ) jp . Div ( text = i , classes = 'font-mono ml-2' , a = wp ) return wp jp . justpy ( commands_demo ) The command_prefix keyword argument allows specifying the prefix for the commands. The default is 'jp.' Warning All non blank prefixes should have the '.' (period) as their last character We can then use the commands to generate the output we need without parsing HTML: import justpy as jp def commands_demo (): wp = jp . WebPage () root = jp . Div ( a = wp ) c1 = jp . Div ( a = root ) c2 = jp . P ( classes = 'm-2 p-2 text-red-500 text-xl' , a = c1 , text = 'Paragraph 1' ) c3 = jp . P ( classes = 'm-2 p-2 text-blue-500 text-xl' , a = c1 , text = 'Paragraph 2' ) c4 = jp . P ( classes = 'm-2 p-2 text-green-500 text-xl' , a = c1 , text = 'Paragraph 3' ) return wp jp . justpy ( commands_demo ) The only change needed to the commands is to add root to the page.","title":"The commands attribute"},{"location":"tutorial/working_with_html/#parse_html-limitations","text":"The parser does not handle correctly HTML in which top level text is divided. The following HTML will not parse correctly: < div > First part of text < span > span text </ span > second part of text </ div > This is because by design, JustPy has just one text attribute per element and so the parser discards the first part. In order to parse the HTML correctly, make each element have undivided text: < div > < span > First part of text </ span >< span class = \"ml-1\" > span text </ span > < span class = \"ml-1\" > second part of text </ span ></ div > Now each span has undivided text. The left margin class is required to so that there is a space between the spans. parse_html removes all white space before and after the text of the elements.","title":"parse_html limitations"},{"location":"tutorial/working_with_html/#converting-to-html","text":"Each component in JustPy also supports the to_html() method. It returns a string with the HTML representation of the element including all its child elements. You can think of it as the inverse of parse_html() .","title":"Converting to HTML"}]}